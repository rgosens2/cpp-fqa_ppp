<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<title>C++ Frequently Questioned Answers</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<h1>C++ Frequently Questioned Answers</h1>
<p>
This is a single page version of <a href="http://yosefk.com/c++fqa">C++ FQA Lite</a>. C++ is a general-purpose programming language, not necessarily suitable for your special purpose. <a href="fqa.html#fqa-6.18">FQA</a> stands for &quot;frequently
questioned answers&quot;. This FQA is called
&quot;lite&quot; because it questions the answers found in <a href="http://www.parashift.com/c++-faq-lite/index.html">C++ FAQ Lite</a>.
</p>

<p>
The single page version does not include most &quot;metadata&quot; sections such as <a href="http://yosefk.com/c++fqa/faq.html">the FQA FAQ</a>.
</p>

<h2>Table of contents</h2>

<ul>
<li><a href="fqa.html#fqa-defective">Defective C++</a> - a list of major language defects</li>
<li>C++ Q&amp;A, structured similarly to C++ FAQ Lite, with links to the original FAQ answers</li>
<li style="list-style-type: none;">
<ul>
<li><a href="fqa.html#fqa-picture">Big Picture Issues</a></li>
<li><a href="fqa.html#fqa-class">Classes and objects</a></li>
<li><a href="fqa.html#fqa-ref">References</a></li>
<li><a href="fqa.html#fqa-inline">Inline functions</a></li>
<li><a href="fqa.html#fqa-ctors">Constructors</a></li>
<li><a href="fqa.html#fqa-dtor">Destructors</a></li>
<li><a href="fqa.html#fqa-assign">Assignment operators</a></li>
<li><a href="fqa.html#fqa-operator">Operator overloading</a></li>
<li><a href="fqa.html#fqa-friend">Friends</a></li>
<li><a href="fqa.html#fqa-io">Input/output via <code>&lt;iostream&gt;</code> and <code>&lt;cstdio&gt;</code></a></li>
<li><a href="fqa.html#fqa-heap">Freestore management</a></li>
<li><a href="fqa.html#fqa-exceptions">Exceptions</a></li>
<li><a href="fqa.html#fqa-const">Const correctness</a></li>
<li><a href="fqa.html#fqa-inheritance-basics">Inheritance - basics</a></li>
<li><a href="fqa.html#fqa-inheritance-virtual">Inheritance - <code>virtual</code> functions</a></li>
<li><a href="fqa.html#fqa-inheritance-proper">Inheritance - proper inheritance and substitutability</a></li>
<li><a href="fqa.html#fqa-inheritance-abstract">Inheritance - abstract base classes</a></li>
<li><a href="fqa.html#fqa-inheritance-mother">Inheritance - what your mother never told you</a></li>
<li><a href="fqa.html#fqa-inheritance-multiple">Inheritance - multiple and <code>virtual</code> inheritance</a></li>
<li><a href="fqa.html#fqa-mixing">How to mix C and C++</a></li>
<li><a href="fqa.html#fqa-function">Pointers to member functions</a></li>
<li><a href="fqa.html#fqa-templates">Templates</a></li>
</ul>
</li>
<li><a href="fqa.html#fqa-web-vs-fqa">FQA errors</a> found by readers</li>
</ul>

<a id="fqa-defective"></a><h1>Defective C++</h1>
<p>
This page summarizes the major defects of the C++ programming language
(listing all minor quirks would take eternity). To be fair, some of the items <i>by themselves</i>
could be design choices, not bugs. For example, a programming language doesn&#39;t have to provide garbage collection.
It&#39;s the <i>combination</i> of the things that makes them <i>all</i> problematic.
For example, the lack of garbage collection makes C++ exceptions and operator overloading inherently defective. Therefore, the problems are not listed in the order of &quot;importance&quot;
(which is subjective anyway - different people are hit the hardest by different problems).
Instead, most defects are followed by one of their complementary defects, so that when a defect causes
a problem, the next defect in the list makes it worse.
<ul>
<li><a href="fqa.html#defect-1">No compile time encapsulation</a></li>
<li><a href="fqa.html#defect-2">Outstandingly complicated grammar</a></li>
<li><a href="fqa.html#defect-3">No way to locate definitions</a></li>
<li><a href="fqa.html#defect-4">No run time encapsulation</a></li>
<li><a href="fqa.html#defect-5">No binary implementation rules</a></li>
<li><a href="fqa.html#defect-6">No reflection</a></li>
<li><a href="fqa.html#defect-7">Very complicated type system</a></li>
<li><a href="fqa.html#defect-8">Very complicated type-based binding rules</a></li>
<li><a href="fqa.html#defect-9">Defective operator overloading</a></li>
<li><a href="fqa.html#defect-10">Defective exceptions</a></li>
<li><a href="fqa.html#defect-11">Duplicate facilities</a></li>
<li><a href="fqa.html#defect-12">No high-level built-in types</a></li>
<li><a href="fqa.html#defect-13">Manual memory management</a></li>
<li><a href="fqa.html#defect-14">Defective metaprogramming facilities</a></li>
<li><a href="fqa.html#defect-15">Unhelpful standard library</a></li>
<li><a href="fqa.html#defect-16">Defective inlining</a></li>
<li><a href="fqa.html#defect-17">Implicitly called &amp; generated functions</a></li>
</ul>

<p>
<a id="defect-1"></a><h2>No compile time encapsulation</h2>

<p>
In naturally written C++ code, changing the private members of a class requires <a href="fqa.html#fqa-7.4">recompilation</a> of
the code using the class. When the class is used to instantiate member objects of other classes,
the rule is of course applied recursively.
</p>

<p>
This makes C++ interfaces very unstable - a change
invisible at the interface level still requires to rebuild the calling code, which can be
very problematic when that code is not controlled by whoever makes the change.
So shipping C++ interfaces to customers can be <a href="fqa.html#fqa-6.3">a bad idea</a>.
</p>

<p>
Well, at least when all relevant code is controlled by the same team of people, the only problem is the frequent
rebuilds of large parts of it. This wouldn&#39;t be too bad by itself with almost any language,
but C++ has...
</p>

<p>
<a id="defect-2"></a><h2>Outstandingly complicated grammar</h2>

<p>
&quot;Outstandingly&quot; should be interpreted literally, because <i>all popular languages</i> have <a href="http://en.wikipedia.org/wiki/Context-free_grammar">context-free</a>
(or &quot;nearly&quot; context-free) grammars, while C++ has <a href="http://en.wikipedia.org/wiki/Undecidability">undecidable</a> grammar.
If you like compilers
and parsers, you probably know what this means. If you&#39;re not into this kind of thing, there&#39;s a
<a href="fqa.html#fqa-10.19">simple example</a> showing the problem with parsing C++: is <code>AA BB(CC);</code> an object definition
or a function declaration? It turns out that the answer depends heavily on the code <i>before</i> the statement -
the &quot;context&quot;. This shows (on an intuitive level) that the C++ grammar is quite context-sensitive.
</p>

<p>
In practice, this means three things. First, C++ compiles slowly
(the complexity takes time to deal with). Second, when it doesn&#39;t compile,
the error messages are frequently incomprehensible
(the smallest error which a human reader wouldn&#39;t notice completely confuses the compiler).
 And three, parsing C++ right is very hard, so different compilers will interpret
 it differently, and tools like debuggers and IDEs periodically get awfully confused.
</p>

<p>
And <i>slow compilation</i> interacts badly with <i>frequent recompilation</i>. The latter is caused
 by the lack of encapsulation mentioned above, and the problem is amplified by the fact
 that C++ has...
</p>

<p>
<a id="defect-3"></a><h2>No way to locate definitions</h2>

<p>
OK, so before we can parse <code>AA BB(CC);</code>, we need to find out whether <code>CC</code> is defined as an object or a type.
 So let&#39;s locate the definition of <code>CC</code> and move on, right?
</p>

<p>
This would work in most modern languages, in which <code>CC</code> is either defined in the same module
(so we&#39;ve already compiled it), or it is imported from another module (so either we&#39;ve already compiled it, too,
 or this must be the first time we bump into that module - so let&#39;s compile it now, <i>once</i>, but of course <i>not</i>
 the next time we&#39;ll need it). So to compile a program, we need to compile each module, once,
no matter how many times each module is used.
</p>

<p>
In C++, things are <a href="fqa.html#fqa-23.10">different</a> - there are no modules. There are <i>files</i>, each of which can contain many
 different definitions or just small parts of definitions, and there&#39;s <i>no way</i> to tell in which
 files <code>CC</code> is defined, or which files must be parsed in order to &quot;understand&quot; its definition.
 So who is responsible to arrange all those files into a sensible string of C++ code?
 <i>You</i>, of course! In each compiled file, you <code>#include</code> a bunch of header files
 (which themselves include other files); the <code>#include</code> directive basically issues
 a copy-and-paste operation to the C preprocessor, inherited by C++ without changes.
 The compiler then parses the result of all those copy-and-paste operations. So to compile a program,
 we need to compile each file <i>the number of times it is used in other files</i>.
</p>

<p>
This causes two problems. First, it multiplies the long time it takes to compile C++ code
 by the number of times it&#39;s used in a program. Second, the only way to figure out what <i>should</i> be recompiled after a change to the code is to
 check which of the <code>#include</code> files have been changed since the last build. The set of files to rebuild generated by this
 inspection is usually a superset of the files that <i>really</i> must be recompiled according to the
 C++ rules of dependencies between definitions. That&#39;s because most files <code>#include</code> definitions
 they don&#39;t really need, since people can&#39;t spend all their time removing redundant inclusions.
</p>

<p>
Some compilers support &quot;precompiled headers&quot; - saving the result of the parsing of &quot;popular&quot;
 header files to some binary file and quickly loading it instead of recompiling from scratch.
 However, this only works well with definitions that almost never change, typically third-party libraries.
</p>

<p>
And now that you&#39;ve waited all that time until your code base recompiles, it&#39;s time to run and test the program,
 which is when the next problem kicks in.
</p>

<p>
<a id="defect-4"></a><h2>No run time encapsulation</h2>

<p>
Programming languages have rules defining &quot;valid&quot; programs - for example, a valid program shouldn&#39;t
 divide by zero or access the 7th element of an array of length 5. A valid program isn&#39;t necessarily correct
 (for example, it can delete a file when all you asked was to move it). However, an invalid program is necessarily
 incorrect (there is no 7th element in the 5-element array). The question is, what happens when an
 invalid program demonstrates its invalidity by performing a meaningless operation?
</p>

<p>
If the answer is something like &quot;an exception is raised&quot;, your program runs in a managed environment.
 If the answer is &quot;anything can happen&quot;, your program runs somewhere else. In particular, C and C++
 are not designed to run in managed environments (think about pointer casts), and while in theory
 they could run there, in practice all of them run elsewhere.
</p>

<p>
So what happens in a C++ program with the 5-element array? Most frequently, you access something
 at the address that <i>would</i> contain the 7th element, but since there isn&#39;t any, it contains something
 else, which just happens to be located there. Sometimes you can tell from the source code what that is,
 and sometimes you can&#39;t. Anyway, you&#39;re <i>really</i> lucky if the program crashes; because if it keeps
 running, you&#39;ll have hard time understanding why it ends up crashing or misbehaving <i>later</i>.
 If it doesn&#39;t scare you (you debugged a couple of buffer overflows and feel confident), wait until you get to many megabytes
 of machine code and many months of execution time. That&#39;s when the real fun starts.
</p>

<p>
Now, the ability of a piece of code to modify a random object when in fact it tries to access
 an unrelated array indicates that <a href="fqa.html#fqa-7.2">C++ has no run time encapsulation</a>. Since it doesn&#39;t
 have compile time encapsulation, either, one can wonder why it calls itself object-oriented. Two
 possible answers are warped perspective and marketing
 (these aren&#39;t mutually exclusive).
</p>

<p>
But if we leave the claims about being object-oriented aside, the fact that a language runs
  in unmanaged environments can&#39;t really be called a &quot;bug&quot;. That&#39;s because managed environments
  check things at run time to prevent illegal operations, which translates to a certain (though frequently overestimated)
  performance penalty. So when performance isn&#39;t that important, a managed environment is the way to go.
  But when it&#39;s critical, you just have to deal
  with the difficulties in debugging. However, C++ (compared to C, for example) makes <i>that</i> much harder than it already has to be, because there are...
</p>

<p>
<a id="defect-5"></a><h2>No binary implementation rules</h2>

<p>
When an invalid program finally crashes (or enters an infinite loop, or goes to sleep forever), what you&#39;re left
  with is basically the binary snapshot of its state (a common name for it is a &quot;core dump&quot;). You have to make sense of it in order to find the
  bug. Sometimes a debugger will show you the call stack at the point of crash; frequently that information is
  overwritten by garbage. Other things which can help the debugger figure things out may
  be overwritten, too.
</p>

<p>
Now, figuring out the meaning of partially corrupted memory snapshots is definitely not the most pleasant way to spend one&#39;s
  time. But with unmanaged environments you <i>have</i> to do it and it <i>can</i> be done, <i>if</i> you know how your
  source code maps to binary objects and code. Too bad that with C++, there&#39;s a ton of these rules and
  each compiler uses different ones. Think about exception handling or various kinds of inheritance or
  virtual functions or the layout of standard library containers. In C, there&#39;s no standard binary
  language implementation rules, either, but it&#39;s an order of magnitude simpler and in practice compilers
  use the same rules. Another reason making C++ code hard to debug is the above-mentioned complicated grammar,
  since debuggers frequently can&#39;t deal with many language features
  (place breakpoints in templates, parse pointer casting commands in data display windows, etc.).
</p>

<p>
The lack of a standard ABI (application binary interface) has another consequence - it makes shipping
  C++ interfaces to other teams / customers impractical since the user code won&#39;t work unless it&#39;s compiled
  with the same tools and build options. We&#39;ve already seen another source of this problem - the instability
  of binary interfaces due to the lack of compile time encapsulation.
</p>

<p>
The two problems - with debugging C++ code and with using C++ interfaces - don&#39;t show up until your project
  grows complicated in terms of code and / or human interactions, that is, until it&#39;s too late.
  But wait, couldn&#39;t you deal with both problems programmatically? You could generate C or other
  wrappers for C++ interfaces <i>and</i> write programs automatically shoveling through core dumps and deciphering
  the non-corrupted parts, using something called reflection.
  Well, actually, you couldn&#39;t, not in a reasonable amount of time - there&#39;s...
</p>

<p>
<a id="defect-6"></a><h2>No reflection</h2>

<p>
It is impossible to programmatically iterate over the methods or the attributes or the base classes of a class in a
  portable way defined by the C++ standard. Likewise, it is impossible to programmatically determine the type of an object
  (for dynamically allocated objects, this can be justified to an extent by performance penalties of RTTI, but
   not for statically allocated globals, and if you could <i>start</i> at the globals, you could decipher lots
   of memory pointed by them). Features of this sort - when a program can access the structure of programs,
in particular, its own structure - are collectively called reflection, and C++ doesn&#39;t have it.
</p>

<p>
As mentioned above, this makes generating wrappers for C++ classes and shoveling through memory snapshots a pain,
  but that&#39;s a small fraction of the things C++ programmers are missing due to this single issue.
Wrappers can be useful not only to work around the problem of shipping C++ interfaces - you could automatically handle things
  like remote procedure calls, logging method invocations, etc. A very common application of reflection is
  <a href="fqa.html#fqa-15.14">serialization</a> - converting objects to byte sequences and vice versa. With reflection, you can
  handle it for all types of objects with the same code - you just iterate over the attributes of compound objects,
  and only need special cases for the basic types. In C++, you must maintain serialization-related code
  and/or data structures for every class involved.
</p>

<p>
But perhaps we could deal with <i>this</i> problem programmatically then? After all, debuggers do manage
  to display objects somehow - the debug information, emitted in the format supported by your tool chain,
  describes the members of classes and their offsets from the object base pointer and all that sort of meta-data.
  If we&#39;re stuck with C++, perhaps we could parse this information and thus have non-standard, but working reflection?
  Several things make this pretty hard - not all compilers can produce debug information <i>and</i>
  optimize the program aggressively enough for a release build, 
  not all debug information formats are documented, and then in C++, we have a...
</p>

<p>
<a id="defect-7"></a><h2>Very complicated type system</h2>

<p>
In C++, we have standard and compiler-specific built-in types, structures, enumerations, unions, classes with single,
  multiple, virtual and non-virtual inheritance, <code>const</code> and <code>volatile</code> qualifiers, pointers, references and arrays,
  <code>typedef</code>s, global and member functions and function pointers, and <i>templates</i>, which can have specializations on (again) <i>types</i> (or integral constants),
  and you can &quot;partially specialize&quot; templates by <i>pattern matching their type structure</i>
  (for example, have a specialization for <code>std::vector&lt;MyRetardedTemplate&lt;T&gt; &gt;</code> for arbitrary values of <code>T</code>), and each template can have base classes
  (in particular, it can be <i>derived from its own instantiations recursively</i>, which is a <i>well-known practice documented
   in books</i>), and inner <code>typedef</code>s, and... We have lots of kinds of types.
</p>

<p>
Naturally, representing the types used in a C++ program, say, in debug information, is not an easy task.
  A trivial yet annoying manifestation of this problem is the expansion of <code>typedef</code>s done by debuggers when they show
  objects (and compilers when they produce error messages - another reason why these are so cryptic). You may think it&#39;s a
<code>StringToStringMap</code>, but only until the tools enlighten you - it&#39;s actually more of a...
</p>

<pre>
// don&#39;t read this, it&#39;s impossible. just count the lines
std::map&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;,
std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;,
std::less&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;
  &gt;, std::allocator&lt;std::pair&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;,
std::allocator&lt;char&gt; &gt; const, std::basic_string&lt;char, std::char_traits&lt;char&gt;,
std::allocator&lt;char&gt; &gt; &gt; &gt; &gt;
</pre>

<p>
But wait, there&#39;s more! C++ supports a wide variety of explicit and implicit <i>type conversions</i>, so now we
   have a nice set of rules describing the cartesian product of all those types, specifically, how conversion should
   be handled for each pair of types. For example, if your function accepts <code>const std::vector&lt;const char*&gt;&amp;</code>
   (which is supposed to mean &quot;a reference to an immutable vector of pointers to immutable built-in strings&quot;), and I have
   a <code>std::vector&lt;char*&gt;</code> object (&quot;a mutable vector of mutable built-in strings&quot;), then
   <a href="fqa.html#fqa-18.1">I can't pass it to your function</a> because the types aren&#39;t convertible.
    You <i>have</i> to admit that it <i>doesn&#39;t make any sense</i>, because your function guarantees
    that it won&#39;t change anything, and I guarantee that I don&#39;t even mind having anything changed,
    and still the C++ type system gets in the way and the only sane workaround is to <i>copy the vector</i>.
    And this is an <i>extremely simple</i> example - no <a href="fqa.html#fqa-25.13">virtual inheritance</a>, no user-defined conversion operators, etc.
</p>

<p>
But conversion rules by themselves are still not the worst problem with the complicated type system. The worst problem is the...
</p>

<p>
<a id="defect-8"></a><h2>Very complicated type-based binding rules</h2>

<p>
Types lie at the core of the C++ <i>binding rules</i>. &quot;Binding&quot; means &quot;finding the program entity
    corresponding to a name mentioned in the code&quot;.
When the C++ compiler compiles something like <code>f(a,b)</code> (or even <code>a+b</code>), it relies on the
   argument types to figure out which version of <code>f</code> (or <code>operator+</code>) to call. This includes
    overload resolution (is it <code>f(int,int)</code> or <code>f(int,double)</code>?), the handling of function template specializations
    (is it <code>template&lt;class T&gt; void f(vector&lt;T&gt;&amp;,int)</code> or <code>template&lt;class T&gt; void f(T,double)</code>?),
    and the argument-dependent lookup (ADL) in order to figure out the namespace
    (is it <code>A::f</code> or <code>B::f</code>?).
</p>

<p>
When the compiler &quot;succeeds&quot; (translates source code to object code), it doesn&#39;t mean that <i>you</i> are equally successful
    (that is, you think <code>a+b</code> called what the compiler thought it called). When the compiler &quot;fails&quot;
    (translates source code to error messages), most humans also fail
    (to understand these error messages; multiple screens listing all available overloads
     of things like <code>operator&lt;&lt;</code> are <a href="fqa.html#fqa-15.1">less than helpful</a>). By the way, the C++ FAQ 
    has very few items related to the <a href="fqa.html#fqa-35.11">unbelievably complicated
     static binding</a>, like
  overload resolution or ADL or template specialization. Presumably people get too depressed to ask any questions
and silently give up.
</p>

<p>
In short, the complicated type system interacts very badly with <i>overloading</i> - having multiple
    functions with the same name and having the compiler figure out which of them to use
    based on the argument types
(don&#39;t confuse it with <i>overriding</i> - <code>virtual</code> functions, though very far from perfect, do follow rules
 <a href="fqa.html#fqa-20.1">quite sane</a> by C++ standards). And probably the worst kind of overloading is...
</p>

<p>
<a id="defect-9"></a><h2>Defective operator overloading</h2>

<p>
C++ <a href="fqa.html#fqa-13.1">operator overloading</a> has all the problems of C++ function overloading (incomprehensible overload resolution rules),
and then some. For example, overloaded operators have to return their results by value - naively returning references
to objects allocated with <code>new</code> would cause temporary objects to &quot;leak&quot; when code like <code>a+b+c</code> is evaluated. That&#39;s
     because C++ doesn&#39;t have <a href="fqa.html#fqa-16.1">garbage collection</a>, since that, folks, is inefficient. Much better to have
     your code copy massive temporary objects and hope to have them optimized out by our friend the clever compiler.
     Which, of course,
<a href="fqa.html#fqa-10.9">won't happen</a> any time soon.
</p>

<p>
Like several other features in C++, operator overloading is not necessarily a bad thing <i>by itself</i> - it just happens to interact really badly
 with other things C++. The lack of automatic memory management is one thing making operator overloading less than useful. Another such thing is...
</p>

<p>
<a id="defect-10"></a><h2>Defective exceptions</h2>

<p>
Consider error handling in an overloaded operator or a <a href="fqa.html#fqa-17.2">constructor</a>. You can&#39;t use the return value, and setting/reading error
 flags may be quite cumbersome. How about throwing an exception?
</p>

<p>
This could be a good idea in some cases if <a href="fqa.html#fqa-17.1">C++ exceptions</a> were any good. They aren&#39;t, and can&#39;t be - as usual, because of another
 C++ &quot;feature&quot;, the oh-so-efficient manual memory management. If we use exceptions, we have to write exception-safe code
 - code which frees all resources when the control is transferred from the point of failure (<code>throw</code>) to the point
 where explicit error handling is done (<code>catch</code>). And the vast majority of &quot;resources&quot; happens to be <i>memory</i>,
 which is managed manually in C++. To solve this, you are supposed to use <a href="fqa.html#fqa-17.4">RAII</a>, meaning that all pointers have to be &quot;smart&quot;
 (be wrapped in classes freeing the memory in the destructor, and then you have to design their copying semantics, and...).
 Exception safe C++ code is almost infeasible to achieve in a non-trivial program.
</p>

<p>
Of course, C++ exceptions have other flaws, following from <i>still other</i> C++ misfeatures. For example, the above-mentioned lack
 of reflection in the special case of exceptions means that when you catch an exception, you
 <a href="fqa.html#fqa-17.7">can't</a> get the call stack
 describing the context where it was thrown. This means that debugging illegal pointer dereferencing may be easier
 than figuring out why an exception was thrown, since a debugger <i>will</i> list the call stack in many cases of the former.
</p>

<p>
At the bottom line, <code>throw/catch</code> are about as useful as <code>longjmp/setjmp</code>
(BTW, the former typically runs faster, but it&#39;s mere <i>existence</i> makes <i>the rest of the code</i> run slower, which is almost <a href="fqa.html#fqa-17.1">never</a> acknowledged by C++ aficionados).
So we have two features, each with its own flaws, and no interoperability between them. This is true
 for the vast majority of C++ features - most are...
</p>

<p>
<a id="defect-11"></a><h2>Duplicate facilities</h2>

<p>
If you need an <a href="fqa.html#fqa-10.5">array</a> in C++, you can use a C-like <code>T arr[]</code> or a C++ <code>std::vector&lt;T&gt;</code> or any of the array classes written
 before <code>std::vector</code> appeared in the C++ standard. If you need a <a href="fqa.html#fqa-13.6">string</a>, use <code>char*</code> or <code>std::string</code> or
 any of the pre-standard string classes. If you need to take <a href="fqa.html#fqa-8.6">the address of an object</a>,
 you can use a C-like pointer, <code>T*</code>, or a C++ reference, <code>T&amp;</code>. If you need to <a href="fqa.html#fqa-10.12">initialize</a> an object,
 use C-like aggregate initialization or C++ constructors. If you need to <a href="fqa.html#fqa-15.1">print</a> something, you can
 use a C-like <code>printf</code> call or a C++ <code>iostream</code> call. If you need to <a href="fqa.html#fqa-35.1">generate</a> many similar definitions
 with some parameters specifying the differences between them, you can use C-like macros or C++ templates. And so on.
</p>

<p>
Of course you can do the same thing in many ways in almost any language. But the C++ feature duplication is quite special.
 First, the many ways to do the same thing are usually not purely syntactic options directly supported by the compiler -
 you can compute <code>a+b</code> with <code>a-b*-1</code>, but that&#39;s different from having <code>T*</code> and <code>T&amp;</code> in the same language. Second,
 you probably noticed a pattern - C++ adds features duplicating functionality already in C. This is bad by itself,
 because the features don&#39;t interoperate well
 (you can&#39;t <code>printf</code> to an <code>iostream</code> and vice versa, code mixing <code>std::string</code> and <code>char*</code> is <a href="fqa.html#fqa-13.3">littered</a> with casts
  and calls to <code>std::string::c_str</code>, etc.). This is made even worse by the <i>pretty amazing</i> fact that the new C++
 features are actually <i>inferior</i> to the old C ones in many aspects.
</p>

<p>
And the best part is that C++ devotees <i>dare</i> to refer to the C features as
 <a href="fqa.html#fqa-6.15">evil</a>, and frequently will actually resort to finger pointing and name calling when someone uses them in C++ code
 (not to mention using plain C)! And <i>at the same time</i> they (<a href="fqa.html#fqa-6.11">falsely</a>) claim that C++ is compatible with C and
 it&#39;s one of its strengths (why, if C is so evil?). The <a href="fqa.html#fqa-6.2">real</a> reason to leave the C syntax in C++ was
 of course marketing - there&#39;s absolutely NO technical reason to <i>parse C-like syntax</i> in order to
 <i>work with existing C code</i> since that code can be compiled separately. For example, mixing C and <a href="http://www.digitalmars.com/d/">the
 D programming language</a> isn&#39;t harder than <a href="fqa.html#fqa-32.1">mixing C and C++</a>. D is a good example since its stated goals are similar
 to those of C++, but almost all other popular languages have ways to work with C code.
</p>

<p>
So IMO all that old syntax was kept for strictly commercial purposes - to market the language to non-technical
 managers or programmers who should have known better and didn&#39;t understand the difference between &quot;syntax&quot; and &quot;compatibility with existing code&quot; and
 simply asked whether the old code will compile with this new compiler. Or maybe they thought it would be easier
 to learn a pile of new syntax when you also have the (smaller) pile of old syntax than when you have just the new syntax.
Either way, C++ got wide-spread by exploiting misconceptions.
</p>

<p>
Well, it doesn&#39;t matter anymore why they kept the old stuff. What matters is that the new stuff isn&#39;t really new, either - it&#39;s obsessively
 built in ways exposing the C infrastructure underneath it. And <i>that</i> is purely a wrong design decision, made
 without an axe to grind. For example, in C++ there&#39;s...
</p>

<p>
<a id="defect-12"></a><h2>No high-level built-in types</h2>

<p>
C is a pretty low-level language. Its atomic types are supposed to fit into machine registers
 (usually one, sometimes two of them). The compound types are designed to occupy a flat chunk of memory
 with of a size known at compile time.
</p>

<p>
This design has its virtues. It makes it relatively easy to estimate the performance &amp; resource consumption of code.
 And when you have hard-to-catch low-level bugs, which sooner or later happens in unmanaged environments, having
 a relatively simple correspondence between source code definitions and machine memory helps to debug the problem.
 However, in a high-level language, which is supposed to be used when the development-time-cost / execution-time-cost ratio
 is high, you need things like resizable arrays, key-value mappings, integers that don&#39;t overflow and other
 such gadgets. Emulating these in a low-level language is possible, but is invariably painful since the tools
 don&#39;t understand the core types of your program.
</p>

<p>
C++ doesn&#39;t add any built-in types to C <i><a class="corr" href="fqa.html#correction-2">(correction)</a></i>. All higher-level types must be implemented as user-defined classes and templates,
 and this is when the defects of C++ classes and templates manifest themselves in their full glory.
 The lack of syntactic support for higher-level types
 (you can&#39;t initialize <code>std::vector</code> with <code>{1,2,3}</code> or initialize an <code>std::map</code> with something like <code>{&quot;a&quot;:1,&quot;b&quot;:2}</code>
  or have large integer constants like <code>3453485348545459347376</code>) is the small part of the problem.
 Cryptic multi-line or <i>multi-screen</i> <a href="fqa.html#fqa-35.17">compiler error messages</a>,
 debuggers that can&#39;t display the standard C++ types and <a href="fqa.html#fqa-35.12">slow build times</a> unheard of anywhere outside of the C++ world
 are the larger part of the problem. For example, here&#39;s a simple piece of code using the C++ standard library followed by an error message
 produced from it by gcc 4.2.0. Quiz: what&#39;s the problem?
</p>

<pre>
// the code
typedef std::map&lt;std::string,std::string&gt; StringToStringMap;
void print(const StringToStringMap&amp; dict) {
  for(StringToStringMap::iterator p=dict.begin(); p!=dict.end(); ++p) {
    std::cout &lt;&lt; p-&gt;first &lt;&lt; &quot; -&gt; &quot; &lt;&lt; p-&gt;second &lt;&lt; std::endl;
  }
}
// the error message
test.cpp: In function &#39;void print(const StringToStringMap&amp;)&#39;:
test.cpp:8: error: conversion from
&#39;std::_Rb_tree_const_iterator&lt;std::pair&lt;const std::basic_string&lt;char,
std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::basic_string&lt;char,
std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;&#39; to non-scalar type
&#39;std::_Rb_tree_iterator&lt;std::pair&lt;const std::basic_string&lt;char,
std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::basic_string&lt;char,
std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;&#39; requested
</pre>

<p>
The decision to avoid new built-in types yields other problems, such as the <a href="fqa.html#fqa-17.6">ability</a> to throw anything, but
 without the ability to <i>catch</i> it later. <code>class Exception</code>, a built-in base class for all exception classes treated specially by the compiler,
 could solve this problem with C++ exceptions (but not others). However, the most costly problem with having no
 new high-level built-in types is probably the lack of easy-to-use containers. But to have those, we need more
 than just new built-in types and syntax in the C++ compiler. Complicated data structures can&#39;t be manipulated
 easily when you only have...
</p>

<p>
<a id="defect-13"></a><h2>Manual memory management</h2>

<p>
Similarly to low-level built-in types, C++ manual memory management is inherited from C without changes
 (but with the mandatory addition of duplicate syntax - <code>new/delete</code>, which normally call <code>malloc/free</code>
  but don&#39;t <a href="fqa.html#fqa-16.5">have to</a> do that, and of course can be <a href="fqa.html#fqa-11.10">overloaded</a>).
</p>

<p>
Similarly to the case with low-level built-in types, what makes sense for a low-level language doesn&#39;t work
  when you add higher-level features. Manual memory management is incompatible with features such as <a href="fqa.html#fqa-17.1">exceptions</a> &amp; <a href="fqa.html#fqa-13.1">operator overloading</a>,
  and makes working with non-trivial data structures very hard, since you have to worry about the life cycles
  of objects so they won&#39;t leak or die while someone still needs them.
</p>

<p>
The most common solution is <a href="fqa.html#fqa-11.1">copying</a> -
  since it&#39;s dangerous to point to an object which can die before we&#39;re done with it, make yourself a copy
  and become an &quot;owner&quot; of that copy to control its life cycle. An &quot;owner&quot; is a C++ concept not represented
  in its syntax; an &quot;owner&quot; is the object that is responsible to deallocate a dynamically allocated chunk
  of memory or some other resource. The standard practice in C++ is to assign each &quot;resource&quot; (a fancy name for memory, most of the time)
to an owner object, which is supposed to prevent resource leaks.
  What it doesn&#39;t prevent is access to dead objects; we have copying for that.
Which is slow and doesn&#39;t work when you need many pointers to <i>the same</i> object
  (for example, when you want other modules to see your modifications to the object).
</p>

<p>
An alternative solution to copying is using &quot;smart&quot; pointer classes, which could <a href="fqa.html#fqa-16.26">emulate</a> automatic memory management
   by maintaining <a href="fqa.html#fqa-16.22">reference counts</a> or what-not. To implement the pointer classes for the many different types
  in your program, you&#39;re encouraged to use...
</p>

<p>
<a id="defect-14"></a><h2>Defective metaprogramming facilities</h2>

<p>
There are roughly two kinds of metaprogramming: code that generates other code and code that processes other code.
  The second kind is practically impossible to do with C++ code - you can&#39;t reliably process source code due to the extremely
  complicated grammar and you can&#39;t portably process compiled code because there&#39;s no reflection. So this section
  is about the first kind - code generation.
</p>

<p>
You can generate C++ code from within a C++ program using C macros and C++ templates. If you use macros, you risk
  getting <a href="fqa.html#fqa-6.15">clubbed to death</a> by C++ fanatics. Their irrational behavior left aside, these people do have a point -
  C macros are pretty lame. Too bad templates are probably even worse. They are
  <a href="fqa.html#fqa-35.1">limited in ways macros aren't</a> (however, the opposite is also true). They <a href="fqa.html#fqa-35.12">compile forever</a>.
   Being the only way to do metaprogramming, they are routinely <a href="fqa.html#fqa-35.2">abused</a> to do things they weren&#39;t designed for.
   And they are a
   <a href="fqa.html#fqa-35.16">rats' nest</a> of bizarre syntactic problems.
</p>

<p>
That wouldn&#39;t necessarily be so bad if C++ didn&#39;t <i>rely</i> on metaprogramming for doing essential programming tasks.
One reason C++ has to do so is that in C++, the common practice is to use static binding (overload resolution, etc.)
    to implement polymorphism, not dynamic binding. So you can&#39;t take an arbitrary object at run time and print it,
    but in many programs you <i>can</i> take an arbitrary <i>type</i> at compile time and print objects of this type. Here&#39;s
    one common (and broken) application of metaprogramming - the ultimate purpose is to be able to print arbitrary
    object <i>at run time</i>:
</p>

<pre>
// an abstract base class wrapping objects of arbitrary types.
// there can be several such classes in one large project
struct Obj {
  virtual void print(std::ostream&amp;) const = 0;
};
template&lt;class T&gt; struct ObjImpl : Obj {
  T wrapped;
  virtual void print(std::ostream&amp; out) const { out &lt;&lt; wrapped; }
};
// now we can wrap int objects with ObjImpl&lt;int&gt; and string objects
// with ObjImpl&lt;std::string&gt;, store them in the same collection of Obj*
// and print the entire collection using dynamic polymorphism:
void print_them(const std::vector&lt;Obj*&gt;&amp; objects) {
  for(int i=0; i&lt;(int)objects.size(); ++i) {
    objects[i]-&gt;print(std::cout); // prints wrapped ints, strings, etc.
    std::cout &lt;&lt; std::endl;
  }
}
</pre>

<p>
Typically there are 10 more layers of syntax involved, but you get the idea. This sort of code doesn&#39;t really work
    because it requires all relevant overloads of <code>operator&lt;&lt;</code> to be visible <i>before</i> the point where <code>ObjImpl</code>
    is defined, and that doesn&#39;t happen unless you routinely sort your <code>#include</code> directives according to that rule.
    Some compilers will compile the code correctly with the rule violated, some will complain, some will silently generate
    wrong code.
</p>

<p>
But the most basic reason to rely on the poor C++ metaprogramming features for everyday tasks
    is the above-mentioned ideological decision to avoid adding high-level built-in types. For example, templates
    are at the core of the...
</p>

<p>
<a id="defect-15"></a><h2>Unhelpful standard library</h2>

<p>
Most things defined by the C++ standard library are templates, and relatively sophisticated ones, causing
    the users to deal with quite sophisticated manifestations of the problems with templates, discussed above.
    In particular, a special program called <a href="http://www.bdsoft.com/tools/stlfilt.html">STLFilt</a> exists
    for <i>decrypting the error messages</i> related to the C++ standard library.
    Too bad it doesn&#39;t patch the debug information in a similar way.
</p>

<p>
Another problem with the standard library is all the functionality that&#39;s not there.
   A large part of the library duplicates the functionality from the C standard library (which is itself available to C++ programs, too).
The main new thing is containers
(&quot;algorithms&quot; like <code>max</code> and <code>adjacent_difference</code> don&#39;t count as <a href="fqa.html#fqa-7.3">"functionality"</a> in my book). The standard library
 doesn&#39;t support listing directories, opening GUI windows or network sockets. You may think that&#39;s because these things
 are non-portable. Well, the standard library doesn&#39;t have matrices or regular expressions, either.
</p>

<p>
And when you use the standard library in your code, one reason it compiles slowly to a large binary image is
 that the library extensively uses the...
</p>

<p>
<a id="defect-16"></a><h2>Defective inlining</h2>

<p>
First, let&#39;s define the terms.
</p>

<p>
&quot;Inlining&quot; in the context of compilers refers to a technique for <i>implementing</i> function calls
 (instead of generating a sequence calling the implementation of the function, the compiler integrates that implementation
  at the point where the call is made). <a href="fqa.html#fqa-9.1">"Inlining" in the context of C++</a> refers to a way to <i>define</i> functions in order to <i>enable</i>
 (as opposed to &quot;force&quot;) such implementation of the calls to the function (the decision whether to actually use the opportunity is made by the compiler).
</p>

<p>
Now, the major problem with this C++ way to enable inlining is that you have to place the definition of the function
 in header files, and have it recompiled over and over again from source. This doesn&#39;t have to be that way - the
 recompilation from source can be avoided by having higher-level object file formats
 (the way it&#39;s done in <a href="http://llvm.org">LLVM</a> and <a href="http://gcc.gnu.org">gcc starting from version 4</a>). This approach -
  link-time inlining - is one aspect of &quot;whole program optimization&quot; supported by modern compilers. But the recompilation
  from source could also be avoided in simpler ways if C++ had a way to locate definitions instead of recompiling them, which,
  as we&#39;ve seen, it hasn&#39;t.
</p>

<p>
The crude support for inlining, designed with a traditional implementation of a C tool chain in mind,
  wouldn&#39;t be as bad if it wasn&#39;t <i>used all the time</i>. People define large functions inline for two reasons.
  <a href="fqa.html#fqa-10.9">Some</a> of them &quot;care&quot; (emotionally) about performance, but never actually measure it, and someone told them
  that inlining speeds things up, and forgot to <a href="fqa.html#fqa-9.3">tell</a> them how it can slow them down. Another reason is that
  it&#39;s simply <i>annoying</i> to define functions non-inline, since that way, you place the full function definition
  in a <code>.cpp</code> file and its prototype in a <code>.h</code> file. So you write the prototype twice, <i>with small changes</i>
  (for example, if a class method returns an object of a type itself defined in the class, you&#39;ll need an extra namespace
   qualification in the <code>.cpp</code> file since you&#39;re now <i>outside of the namespace of the class</i>). Much easier
   to just have the body written right in the <code>.h</code> file, making the code compile more slowly and recompile
   more frequently (changing the function body will trigger a recompilation).
</p>

<p>
And you don&#39;t even need to actually <i>write</i> any inline functions to get most of their benefits! A large subset
   of the inline functions of a program are...
</p>

<p>
<a id="defect-17"></a><h2>Implicitly called &amp; generated functions</h2>

<p>
Here&#39;s a common &quot;design pattern&quot; in C++ code. You have a huge class.
   Sometimes there&#39;s a single pseudo-global object of this class.
   In that case, you get all the <i>drawbacks</i> of global variables because everybody has a pointer to the
 thing and modifies it and expects others to see the changes. But you get no <i>benefits </i>of global variables since
 the thing is allocated on the stack and when your program crashes with a buffer overflow, you can&#39;t
 find the object in a debugger. And at other times there are many of these objects,
   typically kept in a pseudo-global collection.
</p>

<p>
Anyway, this huge class has no constructors, no destructor and no <code>operator=</code>. Of course people create
   and destroy the objects, and sometimes even assign to them. How is this handled by the compiler?
</p>

<p>
This is handled by the compiler by generating a <i>gigantic</i> pile of code at the point where it would
   call the user-defined functions with magic names (such as <code>operator=</code>) if there were any. When you <i>crash</i> somewhere
   at that point, you get to see <i>kilobytes</i> of assembly code in the debugger, all generated
   from <i>the same source code line</i>. You can then try and figure out which variable didn&#39;t like
   being assigned to, by guessing where the class member offsets are in the assembly listing and looking
   for symbolic names of the members corresponding to them. Or you can try and guess who forgot
   all about the fact that these objects were assigned to using the &quot;default&quot; <code>operator=</code>
   and added something like built-in pointer members to the class. Because that wouldn&#39;t work,
   and could have caused the problem.
</p>

<p>
Implicit generation of functions is problematic because it slows compilation down, inflates
   the program binaries and gets in the way when you debug. But the problem with <i>implicitly calling</i> functions
   (whether or not they were <i>implicitly generated</i>) is arguably even worse.
</p>

<p>
When you see code like <code>a=f(b,c)</code> (or even <code>a=b+c</code>, thanks to operator overloading), you don&#39;t
   know whether the objects are passed by reference or by value (see <a href="fqa.html#fqa-8.6">"information hiding"</a>). In the latter case, the objects are
   copied with implicitly called functions; in the former case, that&#39;s possible, too, if implicit type
   conversions were involved. Which means that you don&#39;t really understand what the program does
   unless you know the relevant information about the relevant overloads and types.
   And by the way, the fact that you can&#39;t see whether the object is passed by reference or by value
   at the point of call is <i>another</i> example of implicit stuff happening in C++.
</p>

<p>
One more problem with automatically generated functions (such as constructors and destructors)
   is that they must be <i>regenerated</i> when you add private members to a class, so changing
   the private parts of a class triggers recompilation... Which brings us back to square 1.
</p>

<a id="fqa-picture"></a><h1>Big Picture Issues</h1>
<p>
This part deals with the Big (and somewhat Sad) Picture.
</p>

<ul>
<li><a href="fqa.html#fqa-6.1">[6.1] Is C++ a practical language?</a></li>
<li><a href="fqa.html#fqa-6.2">[6.2] Is C++ a perfect language?</a></li>
<li><a href="fqa.html#fqa-6.3">[6.3] What&#39;s the big deal with OO?</a></li>
<li><a href="fqa.html#fqa-6.4">[6.4] What&#39;s the big deal with generic programming?</a></li>
<li><a href="fqa.html#fqa-6.5">[6.5] Is C++ better than Ada? (or Visual Basic, C, FORTRAN, Pascal, Smalltalk, or any other language?)</a></li>
<li><a href="fqa.html#fqa-6.6">[6.6] Who uses C++?</a></li>
<li><a href="fqa.html#fqa-6.7">[6.7] How long does it take to learn OO/C++?</a></li>
<li><a href="fqa.html#fqa-6.8">[6.8] What are some features of C++ from a business perspective?</a></li>
<li><a href="fqa.html#fqa-6.9">[6.9] Are virtual functions (dynamic binding) central to OO/C++?</a></li>
<li><a href="fqa.html#fqa-6.10">[6.10] I&#39;m from Missouri. Can you give me a simple reason why <code>virtual</code> functions (dynamic binding) make a big difference?</a></li>
<li><a href="fqa.html#fqa-6.11">[6.11] Is C++ backward compatible with ANSI/ISO C?</a></li>
<li><a href="fqa.html#fqa-6.12">[6.12] Is C++ standardized?</a></li>
<li><a href="fqa.html#fqa-6.13">[6.13] Where can I get a copy of the ANSI/ISO C++ standard?</a></li>
<li><a href="fqa.html#fqa-6.14">[6.14] What are some &quot;interview questions&quot; I could ask that would let me know if candidates really know their stuff?</a></li>
<li><a href="fqa.html#fqa-6.15">[6.15] What does the FAQ mean by &quot;such and such is evil&quot;?</a></li>
<li><a href="fqa.html#fqa-6.16">[6.16] Will I sometimes use any so-called &quot;evil&quot; constructs?</a></li>
<li><a href="fqa.html#fqa-6.17">[6.17] Is it important to know the technical definition of &quot;good OO&quot;? Of &quot;good class design&quot;?</a></li>
<li><a href="fqa.html#fqa-6.18">[6.18] What should I tell people who complain that the word &quot;FAQ&quot; is misleading, that it emphasizes the questions rather than the answers, and that we should all start using a different acronym?</a></li>
</ul>

<a id="fqa-6.1"></a>
<h2>[6.1] Is C++ a practical language?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.1">FAQ:</a></b> Sure - not perfect, but mature and well-supported, which is good for business.
</p>

<p>
<b class="FQA">FQA:</b> It&#39;s &quot;practical&quot; in the sense that you can use it to modify and extend programs such as WebKit
(a web browser engine written in C++) or LLVM (an optimizing compiler written in C++).
</p>

<p>
It&#39;s &quot;practical&quot; in the sense that a lot of practical work is done with it, and a lot of useful things
are hard or impossible to do without it. Most of those useful things are along the lines of &quot;changing a C++ program&quot;
or &quot;using a C++ library&quot;.
</p>

<p>
C++ is not &quot;mature&quot; in the sense that different compilers will interpret it differently, and
C++ modules built by different vendors will not work with each other. C++ is not &quot;well-supported&quot; in the sense that
development tools for C++ lack features and are unreliable compared to other languages. These things make one ask &quot;Am I the first one trying to do this?&quot; all the time.
</p>

<p>
This situation is not likely to change, because it follows from the C++ definition. C++ is very complicated
for programs (or people) to understand. C++ specification leaves out most aspects crucial for interoperability,
such as modules and calling conventions. C++ has a huge installed base, and since solving these problems backward-compatibly
is impossible, they won&#39;t be solved.
</p>


<a id="fqa-6.2"></a>
<h2>[6.2] Is C++ a perfect language?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.2">FAQ:</a></b> No, and it shouldn&#39;t be, it should be practical, which, as we&#39;ve just seen, it is.
Perfect is for academy, practical is for business.
</p>

<p>
<b class="FQA">FQA:</b> No language is &quot;perfect&quot; because our requirements from a &quot;perfect&quot; language are inconsistent with each other.
So instead of perfection, good languages provide <i>consistency</i> and <i>usability</i>.
This can be called &quot;practical&quot; from the point of view of language users.
</p>

<p>
C++ is different - it&#39;s designed for perfection. Where other languages give you a feature, C++ gives you meta-features.
Instead of built-in <a href="fqa.html#fqa-13.3">strings and vectors</a>, it gives you <a href="fqa.html#fqa-35.1">templates</a>.
Instead of <a href="fqa.html#fqa-11.1">garbage collection</a>, it gives you <a href="fqa.html#fqa-17.4">smart pointers</a>. This way, you can (theoretically) implement your own &quot;perfect&quot;
(most efficient and generic) strings. In practice, this turns into a nightmare since many different kinds of strings,
smart pointers, etc., each perfect in its own way, will not work with each other. C++ sacrifices usability for perfection.
</p>

<p>
However, despite the obsession with perfection, C++ <i>is</i> &quot;practical&quot; - from a language designer&#39;s perspective
rather than from a user&#39;s point of view. The &quot;practical&quot; thing in C++ is that it&#39;s based on C. This helped the language gain popularity.
This is also the main reason for inconsistencies in the language - <a href="fqa.html#fqa-10.19">ambiguities in the grammar</a>
(declaration/definition, type name/object name...), <a href="fqa.html#fqa-8.6">duplications of functionality</a> in the different features
(pointers/references, constructors/aggregate initialization, macros/constants/templates, files/namespaces...).
C++ sacrifices consistency for popularity. This &quot;practical&quot; approach helps to increase the number of C++ users,
but it doesn&#39;t help those users to get their job done.
</p>


<a id="fqa-6.3"></a>
<h2>[6.3] What&#39;s the big deal with OO?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.3">FAQ:</a></b> Object-oriented programming is the best known way to develop complex systems. It was invented because
customers kept demanding increasingly complex systems.
</p>

<p>
<b class="FQA">FQA:</b> Object-oriented programming is very useful. For a lot of things it&#39;s so useful you&#39;re likely
to want support for it built into your language. Of course nobody knows how to build complex systems in the general case (or in your special case). OOP
can help, other things can help, but ultimately there is no simple way to deal with complexity. Which is
only surprising if you think that there should exist a reliable process to produce anything people are
willing to pay for. The laws of business are powerful, the laws of nature are more powerful.
</p>

<p>
Most kinds of built-in language support for object-oriented programming, including <a href="fqa.html#fqa-7.5">no such support</a>,
have big advantages over <a href="fqa.html#fqa-7.1">C++ classes</a>. The single biggest problem with C++ classes is that
private members are written in header files, so changing them requires <a href="fqa.html#fqa-7.4">recompiling</a>
the code using them - for important practical purposes, this makes private members a part of the interface.
C++ is built such that recompilation is very <a href="fqa.html#fqa-35.12">slow</a> (an order of magnitude slower than it is with virtually any other language), and classes are built to make recompilation a frequent event.
</p>

<p>
From a business perspective, this means two things: your C++ developers spend a significant amount of their time in recompilation cycles, and C++ interfaces provided to your customers or by your vendors will cause you major headaches (when versions are upgraded, some of the code won&#39;t be recompiled and software will fail in creative ways). Luckily, C++ interfaces are <i>hard</i> to provide (effectively all parties must use the same compiler with the same settings), so quite typically C++ modules have interfaces written in C.
</p>


<a id="fqa-6.4"></a>
<h2>[6.4] What&#39;s the big deal with generic programming?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.4">FAQ:</a></b> Generic programming allows to create components which are easy to use, widely applicable (reusable) <i>and</i> efficient. Using them makes your code faster and reduces the amount of errors. Creating them is a &quot;non-process&quot;
(a poetic description of solving hard problems follows - waking up at night and other things probably questionable from the &quot;business perspective&quot; of which the FAQ is so fond). Most people can use them, but aren&#39;t <i>cut out</i> to create their own - one must <i>like to solve puzzles</i> for that. But these generic components are so generic that you can probably find an off-the-shelf one for your needs.
</p>

<p>
<b class="FQA">FQA:</b> &quot;Generic programming&quot; in the context of C++ refers to <a href="fqa.html#fqa-35.1">templates</a>.
</p>

<p>
Templates are hard to <i>use</i> (and <i>not</i> only define &amp; implement)
due to <a href="fqa.html#fqa-35.17">cryptic compiler error messages</a>, <a href="fqa.html#fqa-35.12">extremely long compilation time</a> and remarkable hostility to symbolic debugging
- both code browsing and data inspection. The usability problems are <i>not</i> solved by using off-the-shelf components.
</p>

<p>
Templates are mostly applicable to containers or smart pointers, which can contain or point to almost anything. When the constraints on the input are less trivial, most of the time you either don&#39;t really need polymorphism, or you are better off with dynamic polymorphism (for example, the kind you get with C++ virtual functions).
That&#39;s because in most cases, the benefits (such as separate compilation) are worth the overhead of dynamic binding (which is dwarfed by the complexity of the dispatched operations themselves).
</p>

<p>
Templates are a form of code generation, and hence they don&#39;t make code faster or slower compared to code you&#39;d write manually. They do tend to make it larger since the compiler generates the same code many times. Although there are theoretical ways to avoid this, you find yourself solving someone else&#39;s problem. With the &quot;evil&quot; C macros you can at least control when they are expanded.
</p>

<p>
People who like to solve puzzles usually prefer <i>interesting</i> puzzles. With templates, the greatest puzzle is what on Earth the code means (even compilers frequently disagree). Practical people avoid fiddling with problems which nobody actually wants solved, and templates are only interesting inside the world of C++, not the real world.
</p>


<a id="fqa-6.5"></a>
<h2>[6.5] Is C++ better than Ada? (or Visual Basic, C, FORTRAN, Pascal, Smalltalk, or any other language?)</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.5">FAQ:</a></b>
 Answering this question is not very helpful because business considerations dominate technical considerations. Specifically, availability (of compile time and run time environments, tools, developers) is the most important consideration. People who don&#39;t get this are techie weenies endangering their employer&#39;s interests.
</p>

<p>
<b class="FQA">FQA:</b> Answering this question is not very helpful because the real question is what language is best for your specific purposes. The purposes are defined by the business considerations (what seems worth doing) and by technical considerations (what seems possible to do). In particular, your purposes may limit the availability of developers, tools, etc. These constraints are necessary to meet.
</p>

<p>
One thing is always true: where you can use C++, you can use C. In particular,
if someone gave you C++ interfaces, a thin layer of wrappers will hide them. Using C instead of C++ has several practical benefits: faster development cycle, reduced complexity, better support by tools such as debuggers, higher portability and interoperability. When C++ is an option, C is probably a better option.
</p>

<p>
Another thing is always true: where you can use a managed environment (where the behavior of wrong programs is defined), using it will save a lot of trouble. C++ (like C) is designed for unmanaged environments (where the behavior of wrong programs is undefined). Unmanaged environments make it very hard to locate faults and impose no limit on the damage done by an undetected fault. In theory, C++ implementations can run in managed environments, but in practice they don&#39;t because of innumerable compatibility issues.
</p>

<p>
Yet another thing is almost always true: picking up a new language is easier for an experienced C++ programmer than working in C++. This is the result of the exceeding complexity of C++.
</p>

<p>
People who think there&#39;s no point in comparing programming languages, for example because
&quot;business considerations dominate technical considerations&quot;,                                                                                                                                                                                                                                  
are free to start their new projects in <a href="http://en.wikipedia.org/wiki/COBOL">COBOL</a> (<b>CO</b>mmon <b>B</b>usiness-<b>O</b>riented <b>L</b>anguage).
</p>


<a id="fqa-6.6"></a>
<h2>[6.6] Who uses C++?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.6">FAQ:</a></b> Lots and lots and lots of people and organizations. Which is excellent for business since a lot of developers are available.
</p>

<p>
<b class="FQA">FQA:</b> Empirical studies indicate that 20% of the people drink 80% of the beer. With C++ developers, the rule is that 80% of the developers understand at most 20% of the language. It is not <i>the same</i> 20% for different people, so don&#39;t count on them to understand each other&#39;s code.
</p>

<p>
Two things are at fault: the exceptional complexity of C++ and its wide popularity, driving hordes of people who don&#39;t consider professional competence a personal priority. The few competent developers will spend much of their time dealing with problems created by the language instead of the original problems (and a subset of these developers <a href="fqa.html#fqa-14.3">will not even notice</a>).
</p>

<p>
The large number of developers at least has the advantage of motivating the development of tools for dealing with C++ code. However, the design of the language makes it notoriously hard to produce such tools - a problem motivation can&#39;t quite remedy.
Compare the quality of code browsing in C++ IDEs to IDEs of other languages and you&#39;ll get the idea.
You can look at language-specific IDEs, general-purpose programming IDEs or extensions for general-purpose text editors - C++ loses everywhere.
Don&#39;t just look at small examples, try it on large programs (especially ones using cutting-edge template libraries).
</p>


<a id="fqa-6.7"></a>
<h2>[6.7] How long does it take to learn OO/C++?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.7">FAQ:</a></b> In 6-12 months you can become proficient, in 3 years you are a local mentor. Some people won&#39;t make it - those can&#39;t learn, and/or they are lazy. Changing the way you think and what you consider &quot;good&quot; is hard.
</p>

<p>
<b class="FQA">FQA:</b> In 6-12 months you can become as proficient as it gets. It is impossible to &quot;know&quot; C++ - it keeps surprising one forever. For example, what does the code <code>cout &lt;&lt; p</code> do when p is a <code>volatile</code> pointer? Hint: as experienced people might <i>expect</i>, there&#39;s an unexpected implicit <a href="fqa.html#fqa-15.1">type</a> conversion involved.
</p>

<p>
While some people are better at learning than others, it is also true that some languages are easier to learn and use than others. C++ is one of the hardest, and your reward for the extra effort spent learning it is likely to be extra effort spent using it. If you find it hard to work in C++, trying another language may be a good idea.
</p>

<p>
Before you subvert the way you think about programming and your definition of &quot;good&quot; in this context to fit C++, it might be beneficial to ask the common sense again. For example, does compilation time <i>really</i> cost nothing (is development time that cheap, are there compilation servers with 100 GHz CPUs around)? Is run time <i>really</i> priceless (don&#39;t user keystrokes limit out speed, how much data are we processing anyway)? How efficient a C++ construct <i>really</i> is in your implementation (templates, exceptions, endless copying &amp; conversion)? The reasoning behind C++ may be consistent, but the assumptions almost never hold.
</p>

<p>
Learning OO has nothing to do with learning C++, and it is probably better to learn OO using a different language as an example. The OO support in C++ is almost a parody on OO concepts. For example, <a href="fqa.html#fqa-7.4">encapsulation</a> is supposed to hide the implementation details from the user of a class. In C++, the implementation is hidden neither at compile time (change a private member and you must recompile the calling code) nor at run time (overwrite memory where an object is stored and you&#39;ll find out a lot about the implementation of its class - although in an unpleasant way).
</p>


<a id="fqa-6.8"></a>
<h2>[6.8] What are some features of C++ from a business perspective?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.8">FAQ:</a></b> Here are a few:
</p>

<ul>
<li><a href="fqa.html#fqa-6.1">A huge installed base</a>, which means good support</li>
<li>Allows to provide <a href="fqa.html#fqa-7.1">simplified interfaces</a>, reducing the defect rate</li>
<li><a href="fqa.html#fqa-13.1">Operator overloading</a> reduces learning curves by <a href="fqa.html#fqa-13.2">exploiting</a> intuition</li>
<li>Reduces <a href="fqa.html#fqa-7.5">safety-vs-usability</a> and <a href="fqa.html#fqa-9.4">safety-vs-speed</a> trade-offs</li>
<li><a href="fqa.html#fqa-6.10">Makes it possible</a> for old code to call new code</li>
</ul>

<p>
<b class="FQA">FQA:</b> Here are a few more:
</p>

<ul>
<li>No practical implementation of C++ runs in managed environments, increasing both the defect rate and the potential damage of an undetected defect</li>
<li>Providing C++ interfaces to a software component is impossible in practice due to lack of compile time and run time interoperability</li>
<li>C++ is extremely inconsistent and complicated, increasing learning curves and the defect rate</li>
<li>C++ compilers typically fail to comply to its intricate standard, reducing portability</li>
<li>C++ compilation is both very slow and very frequent, increasing development time and defect rate (people write cryptic and dangerous code to avoid recompilation, for example, use global variables instead of adding arguments to functions, saving 1.5 hours per rebuild x 20 developers = 30 hours of downtime)</li>
<li>C++ lacks standard types representing basic data structures like strings, arrays and lists (or has more than one standard and many non-standard ones, which is the same), making it harder to reuse code (each interface works with a different kind of strings) and reducing the speed due to run time type conversion</li>
</ul>

<p>
All things mentioned in the FAQ are false for most practical purposes:
</p>

<ul>
<li>Despite the &quot;huge&quot; installed base, the tools dealing with C++ code are poor and their interoperability is a disaster (in both cases the problem is in the language definition)</li>
<li>C++ interfaces are usually very complicated (<a href="http://c2.com/cgi/wiki?RavioliCode">lots of small classes</a>, implicitly generated functions like constructors &amp; destructors, code bundled with the interface in template definitions...). As mentioned above, providing C++ interfaces to someone outside of your team is very hard in practice. And private members are for many purposes effectively a part of your interface.</li>
<li>Operator overloading is almost always counter-intuitive if one tries to understand the functionality (why does the left shift operator <i>print</i> things?), and always counter-intuitive if one tries to estimate performance (go figure if <code>*</code> multiplies two integers or two matrices, especially inside a template definition) or locate bugs (lethal ones can hide in places like <code>operator=</code>, where they are hard to see)</li>
<li>C++ doesn&#39;t reduce safety-vs-anything trade-off since it&#39;s extremely unsafe (it &quot;supports&quot; all the undefined behavior of C like buffer overflows, adds many new scenarios with undefined result like invisibility of template specializations at the point of usage, and its complexity reduces the chances that someone actually knows what a program does and can prove its correctness). Where&#39;s the &quot;trade-off&quot;?</li>
<li>Old code can call new code in almost any popular language, for example, C (the ancient <code>qsort</code> function is probably calling new code as we speak). The item is really supposed to describe the benefits of OO to non-technical people. C++ is not likely to give its user the benefits of OO.</li>
</ul>


<a id="fqa-6.9"></a>
<h2>[6.9] Are virtual functions (dynamic binding) central to OO/C++?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.9">FAQ:</a></b> Sure, that&#39;s what makes C++ an object-oriented language. Don&#39;t switch from C to C++ unless you need virtual functions!
</p>

<p>
<b class="FQA">FQA:</b> They probably are if you consider C++ an &quot;object-oriented&quot; language (a C++ debugger <a href="fqa.html#fqa-7.2">doesn't</a> - try asking it to show what &quot;object&quot; is located at a random place, for example). You have to carefully define &quot;object-oriented&quot; so that C++ fits the definition.
</p>

<p>
Dynamic binding is central to any language since otherwise old code can&#39;t call new code, making code reuse very hard. Virtual functions are one form of dynamic binding supported by C++ (function pointers, inherited from C, are another one).
</p>

<p>
Switching from any language to C++ is not necessarily a good idea.
</p>


<a id="fqa-6.10"></a>
<h2>[6.10] I&#39;m from Missouri. Can you give me a simple reason why <code>virtual</code> functions (dynamic binding) make a big difference?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.10">FAQ:</a></b> Before OO, you could only reuse old code by having new code call it. With OO, old code can call new code - more reuse. Even if the source code for the old code is not available.
</p>

<p>
<b class="FQA">FQA:</b> It is unclear why the FAQ gets this wrong - most of the time it is technically accurate. Dynamic binding - old code calling new code - exists outside of OO. There are countless examples on any scale, ranging from the C <code>qsort</code> function to operating systems, which run programs written long after the code of those systems.
</p>

<p>
The special thing in OO is that, well, it works with objects. In the case of dynamic binding, this means that not only does old code call new code - it also passes the <i>state</i> (encapsulated in the object receiving the method call) needed for this new code to work. This also happens outside of OO, but OO is an excellent unifying framework for dealing with this kind of thing. Especially if you have a <i>good</i> OO environment.
</p>

<p>
The omission of facts in the FAQ is much more typical than the technical inaccuracy. Specifically, there&#39;s a difference between theory and practice when it comes to old code <i>not available in source form</i> calling new code. In practice, code generated from C++ source is not portable, limiting the scenarios where the reuse actually works. Worse, even C++ implementations running on the same hardware and operating system are rarely compatible. For actually having old code call new code, you must limit yourself to a small subset of the language (C is one good one), and/or have both the old and the new code built with the same tools under the same settings.
</p>


<a id="fqa-6.11"></a>
<h2>[6.11] Is C++ backward compatible with ANSI/ISO C?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.11">FAQ:</a></b> Almost. But a declaration of a function without parameters means different things in C and C++, and <code>sizeof(&#39;x&#39;)</code> is likely to yield a different value, and...
</p>

<p>
<b class="FQA">FQA:</b> The pair of words &quot;almost compatible&quot; is <i>almost meaningless</i> - for many technical purposes, compatibility is a binary thing. &quot;Compatible&quot;, on the other hand, can have <i>several</i> meanings.
</p>

<p>
If your question is &quot;Can I compile C code with a C++ compiler?&quot;, the answer is &quot;no&quot; because of numerous differences in the way code is interpreted (some things will be reported by the compiler, some will be silently misinterpreted).
However, this is not a real problem, since you can compile C code with a C compiler.
</p>

<p>
If your question is &quot;Can I call C code from C++ code?&quot;, the answer is &quot;yes&quot;, but it&#39;s not special to C++. You can call C code from virtually any popular language because most of today&#39;s environments are based on C, making it both easy and beneficial to support this.
</p>

<p>
If your question is &quot;Can I call C++ code from C code?&quot;, the answer is <a href="fqa.html#fqa-32.1">"sometimes"</a>. It is possible if the C++ code exposes a C interface (no classes, no exceptions...), and even then there are problems like making sure C++ global constructors and destructors are invoked. Many platforms provide ways for this to work.
</p>

<p>
If your question is &quot;Is it easier for a C programmer to learn and use C++ than another new language, possibly object-oriented?&quot;, the answer is &quot;no&quot;. C++ is very hard to learn and use and the hardest parts are not related to the C subset, but to the new parts and the way they interact with the old parts.
</p>

<p>
If your question is &quot;Are C++ programs likely to contain bugs similar to these littering C programs, like buffer overflows?&quot;, the answer is &quot;yes&quot;. If you are willing to sacrifice performance to gain stability, a managed environment might suit your needs. If you want to improve the stability of your programs without sacrificing neither development time nor run time, you probably can&#39;t. In particular, the &quot;high-level&quot; C++ is <i>compatible</i> to the &quot;low-level&quot; C when it comes to damage caused by low-level errors.
</p>


<a id="fqa-6.12"></a>
<h2>[6.12] Is C++ standardized?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.12">FAQ:</a></b> Yes, an ISO standard was adopted in 1997. The FAQ mentions twice that it was &quot;adopted by unanimous vote&quot;.
</p>

<p>
<b class="FQA">FQA:</b> Yes, there is a document specifying what &quot;C++&quot; means, and lots of implementation vendors signed it. The important thing about standardization, however, is the practical implications. Let&#39;s examine them.
</p>

<p>
The C++ standard does not specify what source code is translated to. Unlike code built from Java source, compiled C++ code will usually only run on one hardware/OS configuration.
</p>

<p>
The C++ standard does not address interoperability between implementations. Unlike code built from C source, compiled C++ code will only be able to call C++ code built with the same compiler and the same settings. Different implementations implement exceptions, global initialization &amp; destruction, virtual functions, RTTI, mangling conventions, etc. etc. differently. The C standard leaves out interoperability between implementations just like the C++ standard - but C is an order of magnitude simpler, so you won&#39;t have these problems in practice.
</p>

<p>
The C++ standard does not define a term like &quot;module&quot; or &quot;library&quot; - only &quot;program&quot; and &quot;translation unit&quot; (roughly, the latter means a preprocessed source file). If you deliver dynamically/statically linked libraries, you&#39;re on your own. Again, you will have problems with global initialization &amp; destruction, RTTI, exceptions...
</p>

<p>
The C++ standard does not specify a machine-readable definition of the C++ grammar, and the question whether a given sequence of characters is legal C++ is undecidable. Building tools reliably processing C++ code (including <i>compilers</i>) is extremely hard.
</p>

<p>
The C++ standard has been out there for a long time. Today, different C++ compilers will interpret C++ code differently. The most frequent source of problems is <i>static binding</i> - figuring out what function calls should be generated from a given statement. Compilers implement name resolution (affected by namespaces, function &amp; operator overloading, template signature matching &amp; specialization, implicit type conversions, type qualifiers, inheritance...) differently. Neither the standard document nor common sense will easily tell you which compiler is &quot;right&quot;.
</p>

<p>
You may think that compilers will eventually catch up with the standard (which most vendors are trying to do all the time, but the tools still frequently disagree on the question what &quot;C++&quot; means). Well, the <i>next</i> version of the standard is supposed to be adopted before 2010, giving those vendors some more work. For those compiler writers with <i>really</i> too much time on their hands, there&#39;s C++/CLI.
</p>

<p>
C++ is standardized, but it may have less practical benefits than you might be used to expect from &quot;standards&quot;.
</p>


<a id="fqa-6.13"></a>
<h2>[6.13] Where can I get a copy of the ANSI/ISO C++ standard?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.13">FAQ:</a></b> Get ready to spend some money. A list of links follows.
</p>

<p>
<b class="FQA">FQA:</b> Get ready to throw away some money. Seriously, what are you going to do with your copy? The document is incomprehensible.
</p>

<p>
The document may be useful if you are a language lawyer planning to sue the people responsible for the language or a particular implementation. But if you want to build working software, it&#39;s more practical to accept the fact that your implementation is not standard-compliant in many dark areas. If you find a front-end bug (for example, many times nifty, expensive tools will <i>crash</i> trying to process complicated C++ code; all compilers I used did) - that&#39;s actually <i>your</i> problem. While you are lost in the maze of C++ features, your competitor has already released a working product written without such complications.
</p>

<p>
The document is also useful if you&#39;re into meta-programming (compilers/debuggers/profilers/verifiers...) and want to write tools dealing with C++ code. The standard may help chill your passion before you throw away too much of your time.
</p>


<a id="fqa-6.14"></a>
<h2>[6.14] What are some &quot;interview questions&quot; I could ask that would let me know if candidates really know their stuff?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.14">FAQ:</a></b> If you are a non-technical person (manager/HR), ask a technical person to help you judge the technical competence of a candidate. If you are a technical person, the FAQ is one source of good questions, separating the truly competent people from the posers.
</p>

<p>
<b class="FQA">FQA:</b> The good interview questions probably don&#39;t mention anything unique to C++.
</p>

<p>
Ultimately, you are looking for people with good will (some call them &quot;cooperative&quot;), who will do things, not just talk about them (some call them &quot;practical&quot;), and who will think, not just do (some call them &quot;intelligent&quot;). So the best questions, relevant for all candidates, are about their largest last projects. The answers give you lots of information and good answers are almost impossible to fake.
</p>

<p>
You may also need people to have some prior knowledge relevant to their work since you don&#39;t have time to have them trained and gain experience. If you are sure that&#39;s the case (despite the fact that the people you are looking for are good learners), ask specific questions. Questions about high-level software organization issues (like OO) may be useful. Questions about low-level software construction issues (like pointers) may be useful. These issues are not specific to C++.
</p>

<p>
Asking about things specific to C++ is not very useful.
</p>

<p>
First, many of these things are useless for any practical purpose and are best avoided. Whether someone knows these things is correlated quite loosely with proficiency, and there are many excellent developers out there who weren&#39;t confronted with a particular obscure C++ feature yet, or successfully forgot it. So chances are that you are going to reject a good candidate.
</p>

<p>
Second, a <i>good</i> candidate actually knowing the answer may prefer an employer asking more relevant and practical questions. So chances are that a good candidate is going to reject you.
</p>

<p>
And third, there are people who look for the most complicated way to solve a problem to show off their intelligence. These tend to stumble into the dark areas of the tools they use all the time, so they will know answers to many C++-specific questions (they won&#39;t know answers to many more, because almost nobody does). Your questions will rank these people as the best possible candidates. Later you will find out that these people are poor practitioners.
</p>


<a id="fqa-6.15"></a>
<h2>[6.15] What does the FAQ mean by &quot;such and such is evil&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.15">FAQ:</a></b> This means that a feature should be avoided whenever possible. The strong word is supposed to help people change their old thinking.
</p>

<p>
<b class="FQA">FQA:</b> This means the feature satisfies the following conditions:
</p>

<ul>
<li>It is inherited from C</li>
<li>It is easy to abuse <i>(especially when it interacts with the new C++ features)</i></li>
<li>It can cause problems when abused <i>(especially when it interacts with the new C++ features)</i></li>
<li>C++ provides one or more facilities duplicating the functionality of the feature, replacing the original problems with new and much more complicated problems</li>
</ul>

<p>
For example, macros, pointers, and arrays meet this definition (the corresponding C++ &quot;solutions&quot; are const &amp; template, references &amp; smart pointers, and vector/string classes).
Include files almost meet this definition, except that C++ doesn&#39;t duplicate this functionality (namespaces are a parallel notion of &quot;modules&quot;, but they can&#39;t be used to locate definitions). Consequently, the FAQ will not call include files &quot;evil&quot;.
On the other hand, function overloading doesn&#39;t come from C, so duplicate facilities like template specialization, default arguments, etc. are not enough for the FAQ to call function overloading &quot;evil&quot;. Still, function overloading is very commonly abused leading to major problems.
</p>

<p>
A C++ user is likely to have a different definition of &quot;evil&quot;. A user doesn&#39;t care whether something came from C or not, and whether C++ tried to offer duplicate facilities (while forcing users to deal with the original ones since they&#39;re still in the language). A user typically cares about the &quot;easy to abuse and causing trouble when abused&quot; parts. Lots and lots of parts of C++ are like that.
</p>

<p>
As to the features the FAQ does call evil - <a href="fqa.html#fqa-6.2">why</a> are they in the language? Is it good for the users of the language, or for those who designed and promoted it?
</p>


<a id="fqa-6.16"></a>
<h2>[6.16] Will I sometimes use any so-called &quot;evil&quot; constructs?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.16">FAQ:</a></b> Of course! <a href="fqa.html#fqa-6.15">Evil</a> means &quot;usually undesirable&quot;, but sometimes you have to choose from a set of bad options, and an &quot;evil&quot; feature is your best option. There are no universal rules. Think! At this point the FAQ (and your typical C++ devotee) gets quite agitated.
</p>

<p>
<b class="FQA">FQA:</b> Of course! You have no choice. They are built into the language. For example, <code>&quot;abc&quot;</code> and <code>{1,2,3}</code> are evil arrays, the keyword <code>this</code> and the standard <code>char** argv</code> are evil pointers, and you&#39;ll need an evil <code>#define</code> to define a usable interface (for the header file inclusion guards).
</p>

<p>
Note that with evil arrays, you can write <code>int a[3] = {1,2,3};</code> while with the supposedly less evil <code>std::vector</code>, you can&#39;t. You&#39;ll find out that C++ brand new features duplicating the functionality of the &quot;evil&quot; old C features are inferior to the latter in <a href="fqa.html#fqa-10.6">many</a> <a href="fqa.html#fqa-8.6">more</a> ways.
</p>

<p>
Worse, you can avoid neither the features the FAQ calls evil nor the ones the user would call evil, because if your code doesn&#39;t use a feature, it doesn&#39;t mean that someone else&#39;s code you have to live with doesn&#39;t. For example, you may try to avoid exceptions, but the C++ <code>operator new</code>, as well as code in third-party libraries, will throw exceptions, and you have to catch them.
</p>

<p>
There&#39;s a basic assumption behind C++ that extra features can&#39;t be a problem - only missing features can. That&#39;s why there are so many features in C++, and in particular so many duplicate ones. Real world analogies (&quot;imagine a dog with twelve legs&quot;) are pale compared to this reality.
</p>


<a id="fqa-6.17"></a>
<h2>[6.17] Is it important to know the technical definition of &quot;good OO&quot;? Of &quot;good class design&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.17">FAQ:</a></b> Not if you are a practitioner. <a href="fqa.html#fqa-6.5">Business considerations are the important ones</a>. Precise technical definitions of &quot;good&quot; may lead developers to ignore these considerations, so they are dangerous.
</p>

<p>
<b class="FQA">FQA:</b> Whether it&#39;s important or not, there is no technical definition of &quot;good&quot;, in particular good OO or good class design. &quot;Good&quot; is not a formal term, nor is it universal. For example, if you work for a company, it&#39;s important to consider how beneficial something ultimately is for that company in order to define &quot;good&quot;.
</p>

<p>
However, there are technical definitions of OO. So while there are no formal means to tell whether something is <i>good</i> OO, you may be able to reason whether something is OO or <i>not</i>. Which is not necessarily interesting by itself. But it may be interesting if you have reasons to believe that OO is a good tool for your job - you may want to make sure you&#39;ll actually get the benefits you expect. It may also be interesting if someone calls something OO - you may wonder whether you use the same terms or whether they know what they&#39;re talking about.
</p>

<p>
Getting obsessive about precise definitions is a bad way to make decisions. But it&#39;s also bad to ignore definitions and blindly go with the hype. For example, people promoting C++ keep telling how good OO is, and how C++ supports OO, and then you try to find out what OO actually <i>means</i>, and suddenly it turns out that it&#39;s not important. Isn&#39;t that a little strange?
</p>

<p>
It is very beneficial for a practitioner to gain familiarity with OO systems other than C++, and with OO definitions other than the &quot;encapsulation, inheritance, polymorphism&quot; trinity interpreted in special ways allowing C++ to be considered &quot;OO&quot;. For example, a claim that an environment lacking <a href="fqa.html#fqa-7.2">boundary checking</a> or <a href="fqa.html#fqa-16.1">garbage collection</a> is not an OO environment sounds outrageous to people accustomed to C++. But from many perspectives, it makes a lot of sense. If anyone can overwrite an object, where&#39;s the &quot;encapsulation&quot;? If disposing an object can lead to dangling references or memory leaks, how is the system &quot;object-oriented&quot;? What about the ability to tell what kind of object is located at a given place and time? You say the software works with objects - <i>where are they</i>? And if one can&#39;t find out, how is one supposed to debug the software?
</p>

<p>
When people claim that C++ is object-oriented and therefore &quot;good&quot;, it may be worth checking whether your <a href="fqa.html#fqa-6.7">notion of "good"</a> is similar to theirs - <a href="fqa.html#fqa-6.3">from a business perspective</a>, for example.
</p>


<a id="fqa-6.18"></a>
<h2>[6.18] What should I tell people who complain that the word &quot;FAQ&quot; is misleading, that it emphasizes the questions rather than the answers, and that we should all start using a different acronym?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/big-picture.html#faq-6.18">FAQ:</a></b> These people should get a life. Changing a term used and understood by many people is pointless, because people no longer care about the origins of the term and directly associate it with the right meaning.
</p>

<p>
<b class="FQA">FQA:</b> If people are accustomed to express an idea in a certain way, and it works for them, trying to convince them to use a new way serves no useful purpose. We could use the opportunity to ask nitpicking questions about how this wisdom is applied to C++ itself. For example, why would someone deprecate <code>static</code> variables at the translation unit scope and demand people to use anonymous namespaces to get identical behavior? And all that.
</p>

<p>
Instead, we&#39;ll use the opportunity to point out that at the time of writing (2007), &quot;FQA&quot; appears to be a less popular acronym than &quot;FAQ&quot;: a Google search yields a few results, but a Wikipedia search does not. Still, changing &quot;FQA&quot; to something else in this document is not an option: it&#39;s all over the place.
</p>

<a id="fqa-class"></a><h1>Classes and objects</h1>
<p>
One of the stated goals of C++ is support for object-oriented programming. This page introduces C++ classes and outlines the tactics they use to defeat their purpose.
</p>

<ul>
<li><a href="fqa.html#fqa-7.1">[7.1] What is a class?</a></li>
<li><a href="fqa.html#fqa-7.2">[7.2] What is an object?</a></li>
<li><a href="fqa.html#fqa-7.3">[7.3] When is an interface &quot;good&quot;?</a></li>
<li><a href="fqa.html#fqa-7.4">[7.4] What is encapsulation?</a></li>
<li><a href="fqa.html#fqa-7.5">[7.5] How does C++ help with the tradeoff of safety vs. usability?</a></li>
<li><a href="fqa.html#fqa-7.6">[7.6] How can I prevent other programmers from violating encapsulation by seeing the <code>private</code> parts of my class?</a></li>
<li><a href="fqa.html#fqa-7.7">[7.7] Is Encapsulation a Security device?</a></li>
<li><a href="fqa.html#fqa-7.8">[7.8] What&#39;s the difference between the keywords <code>struct</code> and <code>class</code>?</a></li>
</ul>

<a id="fqa-7.1"></a>
<h2>[7.1] What is a class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/classes-and-objects.html#faq-7.1">FAQ:</a></b> In OO software, &quot;the fundamental building block&quot;.
</p>

<p>
A class is a type - a representation for a set of states (much like a C <code>struct</code>) and a set of operations for
changing the state (moving from one state to another). Classes are similar to built-in types in this sense
(for example, an <code>int</code> holds a bunch of bits and provides operations like + and *).
</p>

<p>
<b class="FQA">FQA:</b> That&#39;s a correct theoretical definition. It&#39;s equally applicable to all OO languages, but they
are different when it comes to more specific, practical aspects of their particular implementation of classes.
</p>

<p>
How do I create objects? And <a href="fqa.html#fqa-16.1">what happens</a> when they are no longer needed? Is it <i>my</i> job to figure out which ones
are unused and deallocate them? Bad.
</p>

<p>
<a href="fqa.html#fqa-7.2">What happens</a> if I have bugs? If I have a pointer to an object, can it be invalid (be a random bit pattern, point to a dead object)?
It can? The program will <i>crash</i> or worse?
What about arrays of objects and out-of-bounds indexes? Crash or a modification of some other random object?
You call that encapsulation? Bad.
</p>

<p>
<a href="fqa.html#fqa-7.4">What happens</a> if I change/add/remove a private value, without changing the interface?
All code using the class has to be <i>recompiled</i>? I bet you call that encapsulation, too. Bad.
</p>

<p>
I don&#39;t like C++ classes.
</p>


<a id="fqa-7.2"></a>
<h2>[7.2] What is an object?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/classes-and-objects.html#faq-7.2">FAQ:</a></b> A chunk of memory with certain semantics. The semantics are defined by the class of the object.
</p>

<p>
<b class="FQA">FQA:</b> They are also defined by the bugs which cause the code to overwrite data of these objects without bothering
to use the interface defined by the class. People who think that real programmers write code without bugs need
to upgrade to a human brain.
</p>

<p>
Still, it sounds interesting: the memory of our C++ program is apparently broken into chunks storing
objects of various classes, with &quot;defined semantics&quot;. Looks very promising, that.
For example, we could ask a debugger about the kind of object located at such a chunk and inspect its data
(as in &quot;this is a Point with x=5 and y=6&quot;). We could even take this one step further and implement things like
garbage collectors, which can check whether an object is used by looking for pointers to it in the places which
are <i>supposed</i> to store pointers.
</p>

<p>
Unfortunately, you can&#39;t tell the class of a C++ object given a pointer to it at run time. So if you debug
a crashed C++ program and find a pointer somewhere in its guts, and you don&#39;t know its type, you&#39;ll have
to guess that &quot;0000000600000005&quot; is a Point. Which is completely obvious, because that&#39;s the way a pair of
adjacent integers looks like in hexadecimal memory listings of a little endian 32 bit machine. And two adjacent integers might be a Point.
Or some other two-integer structure. Or a part of a three-integer-and-a-float structure.
Or they might be two unrelated numbers which just happen to be adjacent.
</p>

<p>
Which is why you can&#39;t automatically collect the garbage of C++ programs.
</p>


<a id="fqa-7.3"></a>
<h2>[7.3] When is an interface &quot;good&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/classes-and-objects.html#faq-7.3">FAQ:</a></b> It is good when it hides details, so that the users see a simpler picture. It should also speak the language
of the user (a developer, not the customer).
</p>

<p>
<b class="FQA">FQA:</b> Um, sometimes you want the interface to expose the many details and speak the language of the machine,
although it&#39;s probably not very common. The generic answer is something like &quot;an interface is good if it gets the user somewhere&quot;.
</p>

<p>
For example, using <a href="http://www.opengl.org">OpenGL</a> you can render nifty 3D stuff at real time frame rates.
<a href="http://www.fftw.org">FFTW</a> delivers, well, the Fastest Fourier Transform in the West.
With <a href="http://trolltech.com/products/qt">Qt</a>, you can develop cross-platform GUI, and &quot;cross-platform&quot; won&#39;t mean
&quot;looking like an abandoned student project&quot;.
Writing that stuff from scratch is lots of work; using the libraries can save lots of work.
Apparently learning the interfaces of these libraries is going to pay off
for many people.
</p>

<p>
For a negative example, consider <code>&lt;algorithm&gt;</code>. Does <code>std::for_each</code> get us anywhere compared to a bare <code>for</code> loop,
except that now we need to define a <a href="fqa.html#fqa-33.10">functor</a> class? That&#39;s a bad interface, because learning it
doesn&#39;t make it easier to achieve anything useful.
</p>


<a id="fqa-7.4"></a>
<h2>[7.4] What is encapsulation?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/classes-and-objects.html#faq-7.4">FAQ:</a></b> The prevention of &quot;unauthorized access&quot; to stuff.
</p>

<p>
The idea is to separate the implementation (which may be changed) from the interface (which is supposed to be stable).
Encapsulation will force users to rely on the interface rather than the implementation. That will make changing
the implementation cheaper, since the code of the users won&#39;t need to be changed.
</p>

<p>
<b class="FQA">FQA:</b> That&#39;s a nice theoretical definition. Let&#39;s talk about practice - the properties of the C++ keywords <code>private</code>
and <code>protected</code>, which actually implement encapsulation.
</p>

<p>
These keywords will cause the compiler to produce an error message upon access to a non-public member outside
of the class. However, they will not cause the compiler to prevent &quot;unauthorized access&quot; by buggy code,
for example upon buffer overflow. If you debug a crashed or misbehaving C++ program, forget about encapsulation.
There&#39;s just one object now: the memory.
</p>

<p>
As to the cost of changes to the the private parts - they trigger recompilation of all code that <code>#include</code>s your class
definition. That&#39;s typically an order of magnitude more than &quot;code actually using your class&quot;, because everything ends
up including everything.
&quot;The key money-saving insight&quot;, as the business-friendly-looking FAQ puts it, is that <i>every time you change a class definition,
you are recompiling the programs using it</i>. Here&#39;s another simple observation: C++ compiles slowly. And what do we get
now when we put two and two together? That&#39;s right, kids - with C++ classes, the developers get paid primarily to wait for
recompilation.
</p>

<p>
If you want software that is &quot;easy to change&quot;, <a href="fqa.html#fqa-7.5">stay away</a> from C++ classes.
</p>


<a id="fqa-7.5"></a>
<h2>[7.5] How does C++ help with the tradeoff of safety vs. usability?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/classes-and-objects.html#faq-7.5">FAQ:</a></b> In C, stuff is either stored in <code>struct</code>s (safety problem - no encapsulation), or it is declared <code>static</code> at the file
implementing an interface (usability problem - there is no way to have many instances of that data).
</p>

<p>
With C++ classes, you can have many instances of the data (many objects) <i>and</i> encapsulation (non-<code>public</code> members).
</p>

<p>
<b class="FQA">FQA:</b> This is <i>wildly wrong</i>, and the chances that the FAQ author didn&#39;t know it are <i>extremely low</i>.
That&#39;s because you can&#39;t use <code>FILE*</code> from <code>&lt;stdio.h&gt;</code> or <code>HWND</code> from <code>&lt;windows.h&gt;</code> or in fact any widely used and/or decent C library
without noticing that the FAQ&#39;s claim is wrong.
</p>

<p>
When you need multiple instances and encapsulation
in C, you use a forward declaration of a <code>struct</code> in the header file, and define it in the implementation file.
That&#39;s actually <i>better</i> encapsulation than C++ classes - there&#39;s still no <i>run-time</i> encapsulation (memory can be accidentally/maliciously overwritten),
but at least there&#39;s <i>compile-time</i> encapsulation (you don&#39;t have to recompile the code using the interface when you change the implementation).
</p>

<p>
The fact that a crude C technique for approximating classes is better than the support for classes built into the C++ language is really
<i>shameful</i>. Apparently so shameful that the FAQ had to distort the facts in an attempt to save face
(or else the readers would wonder whether there&#39;s any point to C++ classes at all). The FQA hereby declares that it will
not go down this path. Therefore, we have to mention this: the forward declaration basically makes it impossible for the
calling code to reserve space for the object at compile time. This means that a <code>struct</code> declared in a header file
or a C++ class can sometimes be allocated more efficiently than a forward-declared <code>struct</code>. However, this is really
 about a <i>different</i> tradeoff - safety vs. <i>efficiency</i>, and there&#39;s no escape from this tradeoff. Either the caller knows
 about the details such as the size of an object at compile time - which <i>breaks</i> compile-time encapsulation - or it doesn&#39;t,
 so it can&#39;t handle the allocation.
</p>

<p>
Anyway, here&#39;s the real answer to the original question: C++ helps with the tradeoff of safety vs. usability by eliminating both.
</p>

<p>
C++ is extremely unsafe because every pointer can be used to modify every piece of memory from any point in code.
C++ is extremely unusable due to cryptic syntax, incomprehensible semantics and endless rebuild cycles.
Where&#39;s your tradeoff now, silly C programmers?
</p>


<a id="fqa-7.6"></a>
<h2>[7.6] How can I prevent other programmers from violating encapsulation by seeing the <code>private</code> parts of my class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/classes-and-objects.html#faq-7.6">FAQ:</a></b> Don&#39;t bother. The fact that a programmer knows about the inner workings of your class isn&#39;t a problem. It&#39;s
 a problem if <i>code</i> is written to depend on these inner workings.
</p>

<p>
<b class="FQA">FQA:</b> That&#39;s right. Besides, people can always access the code if a machine can. Preventing people from &quot;seeing&quot; the code
 in the sense that they can access it, but not understand it is obfuscation, not encapsulation.
</p>


<a id="fqa-7.7"></a>
<h2>[7.7] Is Encapsulation a Security device?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/classes-and-objects.html#faq-7.7">FAQ:</a></b> No. Encapsulation is about error prevention. Security is about preventing purposeful attacks.
</p>

<p>
<b class="FQA">FQA:</b> Depends on the kind of &quot;encapsulation&quot;. Some managed environments rely on their support for run time encapsulation,
 which makes it technically impossible for code to access private parts of objects, to implement security mechanisms.
C++ encapsulation evaporates at run time, and is almost non-existent even at compile time
 - use <code>#define private public</code> before including a header file and there&#39;s no more encapsulation <i><a class="corr" href="fqa.html#correction-3">(correction)</a></i>. <a href="fqa.html#fqa-7.4">It's hardly
  "encapsulation" at all</a>, so of course it has no security applications - security is harder than encapsulation.
</p>

<p>
The capital E and S in the question are very amusing. I wonder whether they are a manifestation of Deep Respect for
  Business Values or Software Engineering; both options are equally hilarious.
</p>


<a id="fqa-7.8"></a>
<h2>[7.8] What&#39;s the difference between the keywords <code>struct</code> and <code>class</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/classes-and-objects.html#faq-7.8">FAQ:</a></b> By default, <code>struct</code> members and base classes are <code>public</code>. With <code>class</code>, the default is <code>private</code>. Never rely
  on these defaults! Otherwise, <code>class</code> and <code>struct</code> behave identically.
</p>

<p>
But the important thing is how developers <i>feel</i> about these keywords. <code>struct</code> conveys the feeling that its members
  are supposed to be read and modified by the code using it, and <code>class</code> feels like one should use the class
  methods and not mess with the state directly. This difference is the important one when you decide which keyword to use.
</p>

<p>
<b class="FQA">FQA:</b> <code>struct</code> is a C keyword. <code>class</code> was added to C++ because it is easier than actually making the language object-oriented.
  And it does a good job when it comes to the <i>feeling</i> of a newbie who heard that &quot;OO is good&quot;.
</p>

<p>
Check out the emotional discussion about which keyword should be used in the FAQ. The more similar two duplicate C++
  features are, the more heated the argument about the best option to use in each case becomes. Pointers/references,
  arrays/vectors... Yawn.
</p>

<p>
By the way, <a href="fqa.html#fqa-7.5">the forward-declaration-of-struct thing</a> works in C++, and it&#39;s better than a <code>class</code> without <code>virtual</code>
  functions most of the time.
</p>

<a id="fqa-ref"></a><h1>References</h1>
<p>
This page is about C++ references - a duplicate language feature introduced in order to <a href="fqa.html#fqa-8.3">support other duplicate features</a>.
</p>

<ul>
<li><a href="fqa.html#fqa-8.1">[8.1] What is a reference?</a></li>
<li><a href="fqa.html#fqa-8.2">[8.2] What happens if you assign to a reference?</a></li>
<li><a href="fqa.html#fqa-8.3">[8.3] What happens if you return a reference?</a></li>
<li><a href="fqa.html#fqa-8.4">[8.4] What does <code>object.method1().method2()</code> mean?</a></li>
<li><a href="fqa.html#fqa-8.5">[8.5] How can you reseat a reference to make it refer to a different object?</a></li>
<li><a href="fqa.html#fqa-8.6">[8.6] When should I use references, and when should I use pointers?</a></li>
<li><a href="fqa.html#fqa-8.7">[8.7] What is a handle to an object? Is it a pointer? Is it a reference? Is it a pointer-to-a-pointer? What is it?</a></li>
</ul>

<a id="fqa-8.1"></a>
<h2>[8.1] What is a reference?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/references.html#faq-8.1">FAQ:</a></b> It&#39;s an alias for an object - another name by which it can be called. The implementation is frequently identical to that of pointers. But don&#39;t think of references as pointers - a reference <i>is</i> the object.
</p>

<p>
<b class="FQA">FQA:</b> A C++ reference is like a C++ pointer except for the following differences:
</p>

<ul>
<li>You use it as if it were a value: <code>ref.member</code>, not <code>ptr-&gt;member</code>, etc. (in this sense <code>ref</code> behaves like <code>(*ptr)</code>).</li>
<li>It must be initialized to point to an object - otherwise, the code won&#39;t compile.</li>
<li>After the initialization, you can&#39;t make it point to another object.</li>
<li>You can&#39;t take the address of a reference like you can with pointers (forming a pointer to a pointer).</li>
<li>There&#39;s no &quot;reference arithmetics&quot; (but you can take the address of an object pointed by a reference and do pointer arithmetics on it as in <code>&amp;obj + 5</code>).</li>
</ul>

<p>
Strange phrases like &quot;a reference IS the object&quot; are used quite frequently in the C++ community.
Such claims are only useful to hide the fact that C++ pointers &amp; references are so similar that having both in the language is an unnecessary complication.
In other contexts, the claims are simply false. For example, a wide class of bugs comes from accessing <i>dangling references</i> - references to objects which were already destroyed. If a reference is the object,
or just another name for it, how can that happen? Names of destroyed objects are inaccessible - it takes a previously assigned pointer to access a destroyed object
(C++ also breaks <i>that</i> rule - you can access a destroyed global object by its name from a destructor of another global object, but that&#39;s <a href="fqa.html#fqa-10.14">a different can of worms</a>).
</p>


<a id="fqa-8.2"></a>
<h2>[8.2] What happens if you assign to a reference?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/references.html#faq-8.2">FAQ:</a></b> A reference <i>is</i> the object, so of course you assign to the referent object.
</p>

<p>
<b class="FQA">FQA:</b> Which means that you can&#39;t understand the effect of a statement as simple as <code>a=b;</code> without knowing whether <code>a</code> is a reference or not. A nice feature complementary to references (which make you wonder what &quot;a&quot; means) is <a href="fqa.html#fqa-13.1">operator overloading</a> (which makes you wonder what &quot;=&quot; means). Be careful as you work your way through a quagmire of C++ code.
</p>


<a id="fqa-8.3"></a>
<h2>[8.3] What happens if you return a reference?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/references.html#faq-8.3">FAQ:</a></b> You can assign to the return value of a function. This is useful for operator overloading, as in <code>array[index] = value;</code> where array is an object of a class with overloaded <code>operator[]</code> returning a reference.
</p>

<p>
<b class="FQA">FQA:</b> Exactly - and <i>that&#39;s</i> why references exist.
</p>

<p>
C++ references are essential for supporting C++ <a href="fqa.html#fqa-13.1">operator overloading</a>. That&#39;s because C has no facility for assigning to the result of a function call (a function can return a pointer and you can assign to the pointed object, but you need to use an asterisk for dereferencing the pointer, which is different from assigning with the built-in <code>operator[]</code>). Some might say that references serve a more generic purpose - they make pointers to objects feel like objects, but for most purposes that can be achieved with <code>typedef TStruct* T;</code>.
</p>

<p>
Operator overloading, in turn, is useful (though not essential) for <a href="fqa.html#fqa-35.1">templates</a> - a duplicate facility solving some of the problems of C macros and creating new, frequently more costly and complicated problems. For example, operator overloading is at the heart of STL - user-defined iterators must have the interface of a C pointer for interoperability with STL algorithms, which can only be achieved with operator overloading.
</p>

<p>
Operator overloading is also useful for providing user-defined containers such as strings and vectors, duplicating the functionality of built-in strings and arrays.
</p>

<p>
C++ introduces duplicate facilities in order to introduce other duplicate facilities. Then its apologists try to convince everyone that the old facilities are <a href="fqa.html#fqa-6.15">"evil"</a>. Then they explain why removing the old facilities is <a href="fqa.html#fqa-6.1">"impractical"</a>.
</p>


<a id="fqa-8.4"></a>
<h2>[8.4] What does <code>object.method1().method2()</code> mean?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/references.html#faq-8.4">FAQ:</a></b> This is called method chaining. <code>method1</code> returns a reference to an object of a class having <code>method2</code>. This is used in iostream - <code>cout &lt;&lt; a &lt;&lt; endl</code> is method chaining (the method is <code>operator&lt;&lt;</code>). A &quot;slick&quot; way to use method chaining is to simulate &quot;named parameters&quot;: <code>a.setWidth(x).setHeight(y)</code>).
</p>

<p>
<b class="FQA">FQA:</b> It&#39;s just like <code>object-&gt;method1()-&gt;method2()</code>, but with references instead of pointers.
</p>

<p>
While method chaining is natural in object-oriented languages, it&#39;s good to be aware of problems related to it. At a &quot;high&quot; level of discussion concerned with  design, method chaining can be a sign of abstraction violation (for example, do we want the user of <code>object</code> to be able to do arbitrary operations with the return value of <code>method1</code>?). At a &quot;low&quot; level of discussion concerned with coding, <code>method1</code> has no way to report an error except for throwing an exception, which is not always desirable. Inferring a rule like &quot;method chaining is evil&quot; from these issues is probably an exaggeration, but an entire <i>design</i> relying on method chaining may raise questions.
</p>

<p>
For example, iostream is a library for I/O and formatting, and both are a frequent source of run-time errors. How should those errors be checked in statements like <code>cout &lt;&lt; a &lt;&lt; b &lt;&lt; c ...</code>? The method chaining used in iostream also makes formatting quite hard - consider the &quot;I/O manipulators&quot;.
</p>

<p>
The &quot;implementation&quot; of named arguments using method chaining is a particularly <a href="fqa.html#fqa-10.18">bad joke</a>.
</p>


<a id="fqa-8.5"></a>
<h2>[8.5] How can you reseat a reference to make it refer to a different object?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/references.html#faq-8.5">FAQ:</a></b> You can&#39;t. The reference <i>is</i> the object.
</p>

<p>
<b class="FQA">FQA:</b> You can&#39;t do it in portable C++. While the reference is probably implemented as a pointer by your compiler, there&#39;s no C++ operator to get the address where that pointer is stored. In particular, <code>&amp;ref</code> gives the address of the referent object.
</p>

<p>
One has to work around this extremely rarely, but the need can emerge, especially when the source code of parts of a program is unavailable. If the reference is stored inside an object, you can figure out its offset based on the sizes of other members of the class of the hosting object. You can then modify it as if it were a pointer (as in <code>*(T**)p = &amp;myobj;</code>). This is severe abstraction violation, and it isn&#39;t portable C++. Make sure you have no other way to achieve your purpose before doing this. In particular, a way involving paying money to the vendor of the code unavailable in source form is frequently a better idea than &quot;clever&quot; hacks like this.
</p>


<a id="fqa-8.6"></a>
<h2>[8.6] When should I use references, and when should I use pointers?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/references.html#faq-8.6">FAQ:</a></b>  Use references unless you can&#39;t, especially in interfaces. In particular, references can&#39;t point to <code>NULL</code>, so you can&#39;t have a &quot;sentinel reference&quot;. C programmers may dislike the fact that you can&#39;t tell whether a modified value is local or a reference to something else. But this is a form of <i>information hiding</i>, which is good because you should program in the language of a problem rather than the machine.
</p>

<p>
<b class="FQA">FQA:</b> As with most <a href="fqa.html#fqa-10.6">duplicate features</a>, there&#39;s <a href="fqa.html#fqa-9.5">no good answer to this question</a>.
</p>

<p>
C++ programmers use references to denote &quot;a pointer which can&#39;t be null and points to a single object rather than an array&quot;. Using pointers in these cases confuses people because they assume that pointers are used in the <i>other</i> cases.
You don&#39;t want to confuse people, so you use references to pass arguments to functions. Then it turns out that sometimes you want to pass a null pointer to those functions, and you change references to pointers throughout the code. C++ code ends up containing loads of pointers and references without an apparent reason for the choice made in each particular case.
</p>

<p>
If you choose to use a reference, make sure you don&#39;t need null pointers, pointer arithmetics or <a href="fqa.html#fqa-8.5">reseating</a>.
You can&#39;t have arrays of references, and you can&#39;t store references in container classes, because that would require
having uninitialized references and/or pointers to references, and you can&#39;t have that.
Member references in classes/structs must be initialized in constructors using the <a href="fqa.html#fqa-10.6">ridiculous colon syntax</a>.
This makes it harder to <a href="fqa.html#fqa-10.3">reuse initialization code in different constructors</a>, and the problem propagates to the classes using your class as a member since
you can&#39;t provide a <a href="fqa.html#fqa-10.4">default constructor</a>. There are &quot;smart pointers&quot;
(objects with overloaded <code>-&gt;</code> and <code>*</code> operators), but there are no &quot;smart references&quot;
(you can&#39;t <a href="fqa.html#fqa-9.4">overload the dot</a>), so you won&#39;t be able to easily switch to something &quot;smart&quot; later -
 but that&#39;s probably rarely bad since smart pointers are rarely good.
</p>

<p>
If you choose to use a pointer, make sure you don&#39;t confuse other C++ programmers. Pointers to objects of classes
 with <a href="fqa.html#fqa-13.1">overloaded operators</a> lead to code like <code>(*parr)[i]</code>, which gets annoying.
 In many cases the compiler won&#39;t warn you when a pointer is left uninitialized, which may lead to errors harder to
 debug than simple null pointer dereferencing (not to mention security holes - but there&#39;s enough other possibilities
                                               for these in a C++ program to make this a separate issue).
</p>

<p>
These problems mean that in many situations, you must choose between two almost equally bad alternatives.
 While many people successfully use C pointers <i>in C</i>, it doesn&#39;t mean that always choosing pointers over references
 <i>in C++</i> produces no new problems - C++ has features, and C++ programmers have habits interacting badly with pointers.
</p>

<p>
But this, in turn, <i>doesn&#39;t</i> invalidate the argument &quot;pointers are better than references because it&#39;s easy
 to see whether a side-effect is local or not&quot;. <i>Of course</i> the behavior of references is &quot;information hiding&quot; -
 but is it the kind of information you would like to be hidden? Isn&#39;t information hiding about making it <i>easy</i>
 to figure out what a program does? How does hiding side effects, which are a very basic cross-cutting semantical
 aspect of any imperative language, make the code closer to &quot;the language of the problem&quot;?
</p>


<a id="fqa-8.7"></a>
<h2>[8.7] What is a handle to an object? Is it a pointer? Is it a reference? Is it a pointer-to-a-pointer? What is it?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/references.html#faq-8.7">FAQ:</a></b> A &quot;handle&quot; is something identifying and giving access to an object. The term is meant to be vague, omitting implementation details (a handle can be a pointer or an index into an array or a database key, etc.). Handles are often encapsulated in smart pointer classes.
</p>

<p>
<b class="FQA">FQA:</b> One very common way to implement handles in C relies on incomplete types and typedefs:
</p>

<pre>
typedef struct FooState* Foo;
</pre>

<p>
The definition of <code>struct FooState</code> is included in the files implementing <code>Foo</code>, but not in the files using it.
This is probably the closest thing to <a href="fqa.html#fqa-7.4">"encapsulation"</a> you can get in an unmanaged environment.
In particular, it has important <a href="fqa.html#fqa-7.5">advantages</a> compared to <a href="fqa.html#fqa-7.1">C++ classes</a>:
</p>

<ul>
<li>When the definition of <code>FooState</code> is changed, calling code doesn&#39;t have to be <a href="fqa.html#fqa-7.4">recompiled</a> (with C++ classes, changing a private member triggers recompilation of user code). This shortens the rebuild cycles and allows to provide stable binary interfaces, simplifying upgrades in many scenarios.</li>
<li>The module defining <code>Foo</code> <a href="fqa.html#fqa-10.1">controls the allocation and deallocation of the objects</a> (with C++ classes, the user is responsible for allocation and must choose between the stack, the global data, the free store and aggregation inside another object). In particular, <code>FooState</code> may contain a pointer to the &quot;real&quot; state structure, allowing transparent reallocation of these structures.</li>
</ul>

<p>
The C handle technique is also way better than the &quot;smart pointer&quot; tricks in C++. In addition to readability problems posed by operator overloading (is it a bare pointer or a smart pointer?), and the tedious coding involved, smart pointers provide little encapsulation. That&#39;s because overloaded <code>operator-&gt;</code> must return either a bare pointer or a smart pointer, which means that the <i>last</i> smart pointer <i>must</i> return a bare pointer, or the compilation will never end (the latter is easy to achieve with templates - like many other not so useful things). So you end up returning a bare pointer to an object of a C++ class, but in a way more convoluted than average C++ code.
</p>

<p>
When implementing &quot;heavy&quot; classes (unlike, for example, simple objects representing values like points in a 2-dimensional space), using C-style handles is typically much better than pointers or references to objects of C++ classes. Which is quite surprising considering the fact that supporting OO at the language level is one of the main motivations behind C++.
</p>

<a id="fqa-inline"></a><h1>Inline functions</h1>
<p>
Inline functions are a pet feature of <a href="fqa.html#fqa-10.9">people</a> who think they care about performance, but don&#39;t bother to measure it.
</p>

<ul>
<li><a href="fqa.html#fqa-9.1">[9.1] What&#39;s the deal with inline functions?</a></li>
<li><a href="fqa.html#fqa-9.2">[9.2] What&#39;s a simple example of procedural integration?</a></li>
<li><a href="fqa.html#fqa-9.3">[9.3] Do <code>inline</code> functions improve performance?</a></li>
<li><a href="fqa.html#fqa-9.4">[9.4] How can <code>inline</code> functions help with the tradeoff of safety vs. speed?</a></li>
<li><a href="fqa.html#fqa-9.5">[9.5] Why should I use <code>inline</code> functions instead of plain old <code>#define</code> macros?</a></li>
<li><a href="fqa.html#fqa-9.6">[9.6] How do you tell the compiler to make a non-member function <code>inline</code>?</a></li>
<li><a href="fqa.html#fqa-9.7">[9.7] How do you tell the compiler to make a member function <code>inline</code>?</a></li>
<li><a href="fqa.html#fqa-9.8">[9.8] Is there another way to tell the compiler to make a member function <code>inline</code>?</a></li>
<li><a href="fqa.html#fqa-9.9">[9.9] With inline member functions that are defined outside the class, is it best to put the <code>inline</code> keyword next to the declaration within the class body, next to the definition outside the class body, or both?</a></li>
</ul>

<a id="fqa-9.1"></a>
<h2>[9.1] What&#39;s the deal with inline functions?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/inline-functions.html#faq-9.1">FAQ:</a></b> Inlining a function call means that the compiler inserts the code of the function into the calling code
(which is technically different, but logically similar to the expansion of <code>#define</code> macros). This may
 improve performance, because the compiler optimizes the callee code in the context of the calling code
 instead of implementing a function call. However, the performance impact depends on lots of things.
</p>

<p>
There&#39;s more than one way to say that a function should be inline, some of which use the <code>inline</code>
 keyword and some don&#39;t. No matter what way you use, the compiler might actually inline the function
 and it might not - you&#39;re just giving it a &quot;hint&quot;. Sounds vague? It is - and it is <i>good</i>: it lets
 the compiler generate better and/or more debuggable code.
</p>

<p>
<b class="FQA">FQA:</b> To summarize: the compiler has the right to inline or not inline any function, whether it&#39;s declared
 inline in any of the several ways or not. Doesn&#39;t this make &quot;inline functions&quot; a meaningless term?
</p>

<p>
It&#39;s impossible to make any sense of this without <a href="fqa.html#fqa-23.5">discussing the history of actual implementations</a>
 of the C language tool chain - compilers, assemblers and linkers. A straight-forward C implementation
 (which originally <i>all</i> of them were) works like this. First, a compiler generates assembly code from
 each source file, <i>separately</i> (without looking at other source files). Then the assembler converts
 the assembly code to an &quot;object file&quot;, where &quot;object&quot; means &quot;a sequence of bytes&quot; (talk about &quot;object oriented&quot;).
 For example, a function
 is one kind of &quot;object&quot; - the bytes encode the machine instructions the compiler used to implement it.
</p>

<p>
The values of the bytes making up these &quot;objects&quot; are almost completely finalized at this stage.
 The only kind of &quot;unknowns&quot; is addresses of &quot;objects&quot; - when an &quot;object&quot; refers to an address of another &quot;object&quot;
 (say, a function calls another function), the assembler can&#39;t compute the actual values of the bytes making up
 the function call instructions.
 This is done by the linker, which allocates the &quot;objects&quot; (basically by concatenating them).
 The linker then resolves the references (such as function calls) to the addresses of the &quot;objects&quot;.
</p>

<p>
What this means is that the <i>only</i> way to inline functions is to <code>#include</code> their definition in the header file -
otherwise, the compiler doesn&#39;t see the code of the function, and the linker can&#39;t do inlining, because all it
 sees is byte sequences, and it would have to <i>decompile</i> them first. Which explains why you need to
 include the source code of inline functions in header files, but doesn&#39;t explain why you need an <code>inline</code>
 keyword and other ways to explicitly declare a function as &quot;inline&quot;. After all, the compiler is free to ignore
 these hints, so what&#39;s their point?
</p>

<p>
Well, the point is that the compiler can&#39;t tell an <code>#include</code>d function from one written in your source file, because
 that&#39;s how C preprocessing works - the compiler only sees one large file of code. So unless you explicitly declare the
 <code>#include</code>d functions &quot;inline&quot;, it will generate their code like it does with normal functions. Then the linker
 will complain about multiple definitions.
</p>

<p>
Here&#39;s how code is compiled by many modern compilers, including some C and C++ compilers. The compiler transforms
 the source code to an intermediate representation, &quot;lower&quot; than the source language but &quot;higher&quot; than assembly language.
 This makes it possible to do inlining at link time, either on a per-library or a whole-program basis. The machine
 code is only generated as the final linkage step, or it can even be delayed until run time (the so called &quot;just in time compilation&quot;).
This way, you don&#39;t have to split your functions to &quot;inline&quot; (those that <i>can</i> be inlined, but the compiler gets to decide if they actually <i>are</i> inlined) and the rest (those that just <i>can&#39;t</i> be inlined).
Instead, you let the compiler make the decision for <i>all</i> functions. Unfortunately, the meaning of C and C++ is defined with
the old sort of implementation in mind, and having newer, more sophisticated implementations around can&#39;t change it.
</p>


<a id="fqa-9.2"></a>
<h2>[9.2] What&#39;s a simple example of procedural integration?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/inline-functions.html#faq-9.2">FAQ:</a></b> There&#39;s an example of a function calling another function and how inlining may save you copying the parameters
when you pass them to a function and copying the result it returns and stuff. There&#39;s also a disclaimer saying that
it&#39;s just an example and many different things can happen.
</p>

<p>
<b class="FQA">FQA:</b> Basically, code may be portable, but <i>performance</i> is typically not. For example, inlining a function may make code faster
or slower, depending on lots of things discussed in the next FAQs. This is one reason to leave the decision to
a compiler, because &quot;it understands the target platform better&quot;. This is also a reason to leave the decision to a human,
because compilers <i>don&#39;t</i> really know the target platform very well (they know the target processor but not the entire system),
and because they don&#39;t understand the problem you are solving <i>at all</i> (so they can&#39;t tell how many times each piece
of code is likely to run, etc.).
</p>

<p>
Anyway, the problem of &quot;helping the compiler to optimize code&quot; by adding &quot;hints&quot; to the code,
especially portable code, is quite hard. There are many things similar to inlining in this respect (for example, loop unrolling).
Which is why there&#39;s no <code>unroll</code> keyword forcing loop unrolling. And the <code>inline</code> keyword only exists
because there&#39;s <a href="fqa.html#fqa-9.1">no better way</a> to <i>enable</i> (as opposed to &quot;force&quot;) inlining in C/C++.
</p>


<a id="fqa-9.3"></a>
<h2>[9.3] Do <code>inline</code> functions improve performance?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/inline-functions.html#faq-9.3">FAQ:</a></b> Sometimes they do, sometimes they don&#39;t. There&#39;s no simple answer.
</p>

<p>
Inlining can make code faster by eliminating function call overhead, or slower by generating too much code, causing
instruction cache misses. It may make it larger by replicating all that callee code, or smaller by saving the
instructions used to implement function calls. It may inflate the code of an innermost loop, causing repeated
cache misses, or it may improve the locality of reference in the loop, by compiling all relevant code at adjacent
addresses. It may also be irrelevant for performance, because your system is not CPU-bound.
</p>

<p>
See? Told you there was no simple answer.
</p>

<p>
<b class="FQA">FQA:</b> However, there <i>is</i> a relatively simple answer to the legitimate question: &quot;Why do we need this language feature
if its effect is undefined?&quot;. See <a href="fqa.html#fqa-9.1">the first FAQ</a> in the section. There&#39;s also a relatively simple &amp; useful rule saying that
functions which have short code and/or are typically called with compile time constant arguments so that most of their code
computes a constant are typically good candidates for inlining. Long functions are typically worse candidates for inlining,
because the function call overhead is negligible compared to the things the functions actually do, and the main problem with
inlining - large code size - becomes dominant.
</p>

<p>
It&#39;s usually a good idea to only explicitly enable the inlining of very short functions, and performance considerations
are not the only reason. In C++ you have to place the code in header files to enable inlining. While the run time performance may or may not improve, the <i>compile time</i> performance is guaranteed
to drop. Which means changing code becomes hard, which means you&#39;ll do your best to <i>not</i> change it, which means you&#39;ll
leave wrong things unfixed. And debuggers handle inlined code pretty poorly (typically
                                                                          you can&#39;t inspect the local variables
of inlined functions or even step through their source code lines),
so debugging the optimized (production) build becomes harder. And debugging a special &quot;debug&quot; build is not always possible
(some bugs won&#39;t reproduce in that build), not to mention that you have to spend time building those binaries, too.
</p>

<p>
If your application is not CPU bound, <a href="fqa.html#fqa-10.9">you aren't getting any benefits</a> from using an unsafe language like C++ except for extra quality time
 with the debugger.
</p>


<a id="fqa-9.4"></a>
<h2>[9.4] How can <code>inline</code> functions help with the tradeoff of safety vs. speed?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/inline-functions.html#faq-9.4">FAQ:</a></b> &quot;In straight C&quot; you could implement encapsulation using a <code>void*</code>, so that users can&#39;t access the underlying data.
 Instead, the users have to call functions which access that data by casting the <code>void*</code> to the right type first.
</p>

<p>
Not only is this type-unsafe - it&#39;s also costly, since the simplest access now involves a function call. In C++ you
 can use <code>inline</code> accessors to <code>private</code> data - safe, fast.
</p>

<p>
<b class="FQA">FQA:</b> Today C has inline functions (the FAQ probably doesn&#39;t consider the current C standard &quot;straight&quot;,
                                   I wonder why).
AFAIK they were back-ported from C++ together with <code>const</code> and other useless things.
But it&#39;s irrelevant to the question, which is about the completely wrong argument that <code>inline</code> accessors to <code>private</code>
functions are a form of &quot;high-speed encapsulation&quot;.
</p>

<p>
First, the tales about <code>void*</code> are <a href="fqa.html#fqa-7.5">wrong</a> - you can use forward declarations to achieve the holy grail of (compile time)
type safety. Second, <a href="fqa.html#fqa-9.1">a good language implementation</a> can inline the small C-style accessors at link time. Third,
<code>private</code> provides little encapsulation - change a private member and you have to <a href="fqa.html#fqa-7.4">recompile</a> all code using the class.
 Fourth, most frequently <code>private</code> members with straight-forward <code>public</code> accessors are a just verbose way to implement
 a <code>public</code> member, since changing the representation is almost impossible and/or hardly useful.
</p>

<p>
And in the quite rare cases
 where it <i>is</i> possible and useful, &quot;properties&quot; - a language facility allowing to overload the <code>obj.member</code> syntax -
 could solve the problem, but C++ doesn&#39;t have properties. Or you could refactor the code automatically - if anything
 could <a href="fqa.html#fqa-10.19">reliably parse</a> it.
</p>

<p>
In the C++ world code is considered a good thing, of which there should be plenty.
 <code>private: int _n; public: int n() const { return _n; }</code> is thus better than <code>int n;</code>. The question is -
 do <i>you</i> like lots and lots of C++ code doing practically nothing?
</p>


<a id="fqa-9.5"></a>
<h2>[9.5] Why should I use <code>inline</code> functions instead of plain old <code>#define</code> macros?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/inline-functions.html#faq-9.5">FAQ:</a></b> Because macros are <a href="fqa.html#fqa-6.15">evil</a>. In particular, when a macro is expanded, the parameters are not evaluated before the
 expansion, but copied &quot;as is&quot; (they are interpreted as character sequences by the preprocessor, not as C++ expressions). Therefore,
 if a parameter is an expression with a side effect, such as <code>i++</code>, and the macro mentions it several times, the macro
 will expand to buggy code (for instance, <code>i</code> will get incremented many times). Or the generated code may be slow
 (when you use expressions like <code>functionTakingAgesToCompute()</code> as macro arguments).
</p>

<p>
Besides, inline functions check the argument types.
</p>

<p>
<b class="FQA">FQA:</b> Yeah, C macros are no picnic. But see that thing about argument types? How can you write an <code>inline</code> function
 computing the maximal value of two arguments? A <code>template</code> <code>inline</code> function, you say? Try this: <code>std::max(n,5)</code>
 with <code>short n</code>.
</p>

<p>
And how should function arguments be passed - by value or by reference? &quot;By value&quot; may cause extra copying, and &quot;by reference&quot;
 may slow down the code due to aliasing problems, forcing the compiler to actually spill values to memory in order to
 pass them <i>to the code of an inlined function</i>! How&#39;s that for &quot;performance benefits&quot;? Another problem C macros don&#39;t have.
</p>

<p>
Frequently <code>inline</code> functions are better than macros, though, because the problems with macros turn out to be more severe in many cases.
<a href="fqa.html#fqa-10.6">As usual</a>, it&#39;s you who gets the interesting job of choosing between duplicate C++ facilities, each flawed in its own unique way.
</p>


<a id="fqa-9.6"></a>
<h2>[9.6] How do you tell the compiler to make a non-member function <code>inline</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/inline-functions.html#faq-9.6">FAQ:</a></b> Prepend the <code>inline</code> keyword to its prototype, and place the code in a header file, unless it&#39;s only used in
 a single <code>.cpp</code> file, or else you&#39;ll get errors about &quot;unresolved externals&quot; from the linker.
</p>

<p>
<b class="FQA">FQA:</b> The FAQ&#39;s decision to avoid the <a href="fqa.html#fqa-9.1">discussion</a> of the <i>reasons</i> leading to these requirements is wrong.
 Clearly people who don&#39;t understand the underlying implementation issues won&#39;t survive to live the miserable life
 of competent C++ developers. That&#39;s because in C++, the <i>underlying</i> stuff tends to climb out of the basement in
 repeated attempts to make <i>you</i> the one lying under a pile of hard, urgent, mind-numbing low-level problems.
</p>

<p>
Therefore, the only legitimate excuse for telling about a totally weird language requirement and not explaining
 why it exists is brevity. See the FAQ&#39;s lengthy discussion about the performance of inline functions for a pretty good
 evidence that brevity is hardly the motivation here.
</p>


<a id="fqa-9.7"></a>
<h2>[9.7] How do you tell the compiler to make a member function <code>inline</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/inline-functions.html#faq-9.7">FAQ:</a></b> Declare the function in the class as usual. In the definition, add the <code>inline</code> keyword to the prototype.
The definition must be in a header file.
</p>

<p>
<b class="FQA">FQA:</b> Yep, it&#39;s similar to non-member functions.
</p>


<a id="fqa-9.8"></a>
<h2>[9.8] Is there another way to tell the compiler to make a member function <code>inline</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/inline-functions.html#faq-9.8">FAQ:</a></b> Yes, by writing its code right in the body of the class, instead of only writing the declaration there, and
 defining it outside of the class. This way, you don&#39;t even have to use the <code>inline</code> keyword.
</p>

<p>
It&#39;s easier when you write classes, but harder when you read them, because the interface is mixed with the implementation.
 Remember the &quot;reuse-oriented world&quot;? Think about the welfare of the many, many users of your class!
</p>

<p>
<b class="FQA">FQA:</b> What popular language forces you to write a bare interface (&quot;header file&quot;) and separately an implementation containing
 all the information in the interface (&quot;source files&quot;)? Somehow all those languages which only make you type the interface
 once are not at all that hard to use. May it be that it&#39;s because these languages are <i>parsable</i> and therefore <i>IDEs can
 do the oh-so-interesting job of extracting the interface from the implementation</i> and then you can use things like
 class view windows to inspect interfaces?
</p>

<p>
Unless you use templates and operator overloading and all that, many IDEs even have a chance of working with your C++ code.
So writing inline functions inside class definitions won&#39;t really hurt your users after all.
Even if there were no IDEs, you should probably only inline very short functions, with implementations as descriptive
                                       as a comment (is <code>return _x;</code> less of a documentation than &quot;//returns the value of the x coordinate&quot;?). If there&#39;s lots of &quot;implementation
 details&quot; to hide from the eye of a casual observer, inlining is most likely a bad idea anyway.
</p>


<a id="fqa-9.9"></a>
<h2>[9.9] With inline member functions that are defined outside the class, is it best to put the <code>inline</code> keyword next to the declaration within the class body, next to the definition outside the class body, or both?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/inline-functions.html#faq-9.9">FAQ:</a></b> The &quot;best practice&quot; is to only use it in the definition outside of the class. Blah, blah, blah, argues the FAQ
 passionately about the issue. &quot;Observable semantics&quot;, &quot;practical standpoint&quot;, blah, blah, blah.
</p>

<p>
<b class="FQA">FQA:</b> Programmers typically have a good ability to keep many details in their heads. So good that many don&#39;t realize that
                                       this ability is
 <i>finite</i>. If you litter your brain with idiotic &quot;best practices&quot; which don&#39;t even affect the <i>observable semantics</i> of code,
you do it at the expense of <i>not</i> thinking about something else when you write code. &quot;Something else&quot; may include
 really important things, like the purpose and the meaning of the code.
</p>

<p>
If you don&#39;t care about this sort of discussions, and you find yourself under an attack of &quot;software professionals&quot; buzzing
 buzzwords about your &quot;bad practices&quot;, send them a link to this page to distract them, and use the time gained
 by the distraction to go out and buy a buzzer to talk back to them.
</p>

<a id="fqa-ctors"></a><h1>Constructors</h1>
<p>
This section is about constructors, which create C++ objects, as well as a large number of problems.
</p>

<ul>
<li><a href="fqa.html#fqa-10.1">[10.1] What&#39;s the deal with constructors?</a></li>
<li><a href="fqa.html#fqa-10.2">[10.2] Is there any difference between <code>List x;</code> and <code>List x();</code>?</a></li>
<li><a href="fqa.html#fqa-10.3">[10.3] Can one constructor of a class call another constructor of the same class to initialize the <code>this</code> object?</a></li>
<li><a href="fqa.html#fqa-10.4">[10.4] Is the default constructor for <code>Fred</code> always <code>Fred::Fred()</code>?</a></li>
<li><a href="fqa.html#fqa-10.5">[10.5] Which constructor gets called when I create an array of <code>Fred</code> objects?</a></li>
<li><a href="fqa.html#fqa-10.6">[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?</a></li>
<li><a href="fqa.html#fqa-10.7">[10.7] Should you use the <code>this</code> pointer in the constructor?</a></li>
<li><a href="fqa.html#fqa-10.8">[10.8] What is the &quot;Named Constructor Idiom&quot;?</a></li>
<li><a href="fqa.html#fqa-10.9">[10.9] Does return-by-value mean extra copies and extra overhead?</a></li>
<li><a href="fqa.html#fqa-10.10">[10.10] Why can&#39;t I initialize my <code>static</code> member data in my constructor&#39;s initialization list?</a></li>
<li><a href="fqa.html#fqa-10.11">[10.11] Why are classes with <code>static</code> data members getting linker errors?</a></li>
<li><a href="fqa.html#fqa-10.12">[10.12] What&#39;s the &quot;static initialization order fiasco&quot;?</a></li>
<li><a href="fqa.html#fqa-10.13">[10.13] How do I prevent the &quot;static initialization order fiasco&quot;?</a></li>
<li><a href="fqa.html#fqa-10.14">[10.14] Why doesn&#39;t the construct-on-first-use idiom use a static object instead of a static pointer?</a></li>
<li><a href="fqa.html#fqa-10.15">[10.15] How do I prevent the &quot;<code>static</code> initialization order fiasco&quot; for my <code>static</code> data members?</a></li>
<li><a href="fqa.html#fqa-10.16">[10.16] Do I need to worry about the &quot;<code>static</code> initialization order fiasco&quot; for variables of built-in/intrinsic types?</a></li>
<li><a href="fqa.html#fqa-10.17">[10.17] How can I handle a constructor that fails?</a></li>
<li><a href="fqa.html#fqa-10.18">[10.18] What is the &quot;Named Parameter Idiom&quot;?</a></li>
<li><a href="fqa.html#fqa-10.19">[10.19] Why am I getting an error after declaring a <code>Foo</code> object via <code>Foo x(Bar())</code>?</a></li>
</ul>

<a id="fqa-10.1"></a>
<h2>[10.1] What&#39;s the deal with constructors?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.1">FAQ:</a></b> A constructor initializes an object given a chunk of memory having arbitrary (undefined) state, the way &quot;init functions&quot; do. It may acquire resource like memory, files, etc. &quot;Ctor&quot; is a common abbreviation.
</p>

<p>
<b class="FQA">FQA:</b> That&#39;s right - constructors <i>initialize</i> objects. In particular, constructors <i>don&#39;t</i> allocate the chunk of memory used for storing the object. This is done by the code calling a constructor.
</p>

<p>
The compiler thus has to know the size of a memory chunk needed to store an object of a class
(this is the value substituted for <code>sizeof(MyClass)</code>) at each point where the class is used.
That means knowing all members (public &amp; private). This is a key reason why changing the <i>private</i> parts of a C++ class
definition requires <a href="fqa.html#fqa-7.5">recompilation of all calling code</a>, effectively making the private members a part of the public
interface.
</p>

<p>
This design of C++ constructors is extremely impractical because the smallest change can trigger the largest
recompilation cycle. This would be less of a problem if C++ compiled fast, and if there was an automatic way to
detect that code was compiled with an outdated class definition - but it doesn&#39;t, and there isn&#39;t.
</p>

<p>
This is one of the many examples where C++ ignores <a href="fqa.html#fqa-6.1">practical</a> considerations in an attempt to achieve
theoretical <a href="fqa.html#fqa-6.2">perfection</a> (&quot;language features should <i>never, ever</i> impose any performance penalty!&quot;). Compare this to the approach taken in most object-oriented languages, which normally choose
true decoupling of interface, sacrificing the efficiency of allocation. Some of these languages provide ways to
optimize the allocation of <i>public</i> data. This lets you improve performance when you actually need it,
but without the illusion of <a href="fqa.html#fqa-7.4">"encapsulation"</a>, and have real encapsulation in the rest of your system.
</p>


<a id="fqa-10.2"></a>
<h2>[10.2] Is there any difference between <code>List x;</code> and <code>List x();</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.2">FAQ:</a></b> Yes, and it&#39;s a <i>big</i> one. The first statement declares an object of type <code>List</code>, the second declares a function returning an object of type <code>List</code>.
</p>

<p>
<b class="FQA">FQA:</b> There sure is quite a semantic difference. Too bad it&#39;s not accompanied by an equally noticeable syntactic difference. Which is why the question became a frequently asked one.
</p>

<p>
The problem is that it&#39;s hard to tell C++ constructor calls from C/C++ function declarations. The cases discussed here - constructors without arguments - are a relatively moderate manifestation of this problem. All you have to do is memorize a stupid special case: constructor calls look like function calls except when there are no arguments, in which case parentheses must be omitted. There are tons of weird rules in the C++ grammar, and another one doesn&#39;t make much difference.
</p>

<p>
But when there <i>are</i> arguments, things get <i>really</i> <a href="fqa.html#fqa-10.19">hairy</a>. Consider the statement <code>A f(B,C);</code> - this ought to be a function declaration. Why? B and C are surely classes, look at the capital letters. Um, wait, it&#39;s just a naming convention. What if they are objects? That makes the statement a constructor call. Let&#39;s look up the definition of B and C, that should give us the answer to our question.
</p>

<p>
Have you ever looked up C++ definitions (manually or using tools such as IDEs)? Check it out, it&#39;s fun. You can be sure of one thing: template specialization on integer parameters when the instantiation uses the size of a class defined using multiple inheritance and virtual functions as a parameter value doesn&#39;t make definition look-up easy.
</p>

<p>
When you get an incomprehensible error message from your C++ compiler, be sympathetic. Parsing C++ is a full-blown, industrial strength nightmare.
</p>


<a id="fqa-10.3"></a>
<h2>[10.3] Can one constructor of a class call another constructor of the same class to initialize the <code>this</code> object?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.3">FAQ:</a></b> No. But you can factor out the common code into a private function. In some cases you can use default parameters to &quot;merge&quot; constructors. Calling placement <code>new</code> inside a constructor is very bad, although it can &quot;seem&quot; to do the job in some cases.
</p>

<p>
<b class="FQA">FQA:</b> You can&#39;t - one of the many good reasons to avoid constructors. And anyway, having more than one constructor may be problematic for another reason: they must all have the same name (that of the class), so in fact you&#39;re dealing with overloading, and C++ overload resolution is a huge can of worms.
</p>

<p>
If you&#39;re OK with that, you can surely use the FAQ&#39;s advice to factor out common code, unless you follow <i>another</i> <a href="fqa.html#fqa-10.6">FAQ's advice</a> - the one suggesting to use the ugly colon syntax for initializing member variables. You can&#39;t move these things to a function.
</p>

<p>
If you&#39;re in a mood for breaking rules and doing clever tricks, this may be the right time to look for a real problem where such skills are really needed. Breaking C++ rules by calling placement <code>new</code> is probably a bad idea - not because C++ rules are any <i>good</i>, but because they are pretty <i>bad</i> (astonishingly and inconsistently complicated). This is not the kind of rules you can get away with breaking - your maze of hacks is doomed to collapse, and there&#39;s enough weight in C++ to bury your entire project when this happens. And anyway, why invest energy into an artificial syntactic problem when there are so many real ones out there?
</p>


<a id="fqa-10.4"></a>
<h2>[10.4] Is the default constructor for <code>Fred</code> always <code>Fred::Fred()</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.4">FAQ:</a></b> No, the default constructor is the one that can be called without arguments - either because it takes none or because it defines default values for them.
</p>

<p>
<b class="FQA">FQA:</b> Yep, the rule is that the default constructor is the one that can be called &quot;by default&quot; - that is, when the user of a class didn&#39;t specify any parameters.
</p>

<p>
Another neat thing about default constructors is that they get <i>generated</i> &quot;by default&quot;. For example, if the author of class <code>Fred</code> didn&#39;t write any constructors for it, a C++ compiler will automatically generate a default constructor for it. You don&#39;t see a <code>Fred::Fred</code>, but it still exists - invisible C++ functions are great for readability and debugging. The same will happen with other things, for example the <i>copy constructor</i>. If you think you can use C++ and simply avoid the features you don&#39;t like, you&#39;re in for a rude awakening: the invisible compiler-generated stuff is lethal when your class acquires resources (most frequently memory). In for a penny - in for a pound: if you want to write C++ classes, you have to learn pretty much everything about them, and there&#39;s plenty.
</p>

<p>
Where&#39;s all this code generated? At the caller&#39;s side, of course. To generate it near the rest of the class definition, the C++ compiler would have to know where that definition is, and there&#39;s no good way to tell (it may be scattered across as many source files as the author damn pleases). C++ is just like C in this respect - there&#39;s no way to narrow the search range for a definition of an entity based on its name and/or namespace; it can be anywhere in the program. In particular, this means that the default constructor will be automatically generated at all points where a class is used, from scratch - yet another reason why C++ code compiles slowly.
</p>

<p>
And what&#39;s needed in order to generate this code? The default constructor generated by default (I hope you follow) calls the default constructors of all class members (which in turn may take auto-generation). Add a private member, and all default constructors generated at the calling code must be regenerated - yet another reason why C++ code must be <a href="fqa.html#fqa-7.5">recompiled frequently</a>.
</p>


<a id="fqa-10.5"></a>
<h2>[10.5] Which constructor gets called when I create an array of <code>Fred</code> objects?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.5">FAQ:</a></b> The default constructor. If there isn&#39;t any, your code won&#39;t compile. But if you use <code>std::vector</code>, you can call any constructor. And you should use <code>std::vector</code> anyway since arrays are <a href="fqa.html#fqa-6.15">evil</a>. But sometimes you <a href="fqa.html#fqa-6.16">need</a> them. In that case, you can initialize each element as in <code>Fred arr[2] = {Fred(3,4), Fred(3,4)};</code> if you need to call constructors other than the default. And finally you can use placement new - it will take ugly declarations and casts, you should be careful to align the storage right (which can&#39;t be done portably), and it&#39;s hard to make this exception-safe. See how evil those arrays are? Use <code>std::vector</code> - it gets all this complicated stuff right.
</p>

<p>
<b class="FQA">FQA:</b> And all you did was asking a simple question! OK, let&#39;s start making our way through the pile of rules, exceptions, amendments and excuses.
</p>

<p>
Given syntax like <code>MyClass arr[5];</code> the compiler will generate a loop calling the default constructor of <code>MyClass</code>. Pick some time when you have a barf bag handy and look at the generated assembly code. There are two nice things: sometimes compilers will emit a loop even when it&#39;s clear that the default constructor has nothing to do; and for automatically generated default constructors, you&#39;ll get inline calls to the constructor of each member (for the latter thing you don&#39;t really need an array, a single object will do). Bottom line: your program gets bigger and bigger and you don&#39;t know why - <i>you</i> didn&#39;t do anything.
</p>

<p>
Syntax like <code>std::vector&lt;Fred&gt; arr(5,Fred(3,4));</code> gets translated to 5 calls to the copy constructor (in practice - in theory other things could happen; in general, C++ is excellent in theory). This is functionally equivalent to calling <code>Fred(3,4)</code> 5 times. The FAQ doesn&#39;t mention that it&#39;s normally slower though - typically the numbers 3 and 4 must be fetched from the memory allocated for the copied object instead of being passed in registers or inlined into the assembly code.
</p>

<p>
Of course <code>std::vector</code> of a fixed size known at compile time is less efficient than a built-in array anyway. Which is one reason to prefer a built-in array. Initializing such an array with multiple <code>Fred(3,4)</code> objects will force you to replicate the initializer, and will produce the biggest possible initialization code. No, the compiler is not likely to notice that you&#39;re doing the same thing over and over again, it will repeat the same code N times. On the other hand, if your class does nothing in the constructor but has an &quot;init function&quot;, you can call it in a loop. Another reason to avoid constructors.
</p>

<p>
The horror stories the FAQ tells you about placement new are all true. However, it doesn&#39;t mention that <code>std::vector</code> always allocates memory on the free store. And there&#39;s no standard container you can use for allocating memory on the stack, for example, so if you want one, you&#39;ll have to write it yourself. And placement new is necessary to make such containers work with C++ classes without default constructors. Yet another reason to avoid constructors.
</p>

<p>
Anyway, saying &quot;use <code>std::vector</code> because it gets that horrible placement new stuff right&quot; is a little strange if you consider the following assumptions, one of which must apparently hold:
</p>

<ul>
<li>C++ guys want people to build their own container classes - then why is placement new, which is required to do this right, so hard to use?</li>
<li>C++ guys don&#39;t want people to build their own container classes - then why isn&#39;t <code>std::vector</code> built into the language, so that things like aggregate initialization could work with it, and maybe we could get rid of those oh-so-evil arrays?</li>
</ul>

<p>
Maybe you can&#39;t expect more consistency from the promoters of a language than there is in that language itself.
</p>


<a id="fqa-10.6"></a>
<h2>[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.6">FAQ:</a></b> Initialization lists - that&#39;s more efficient, except for built-in types (with initializers, you avoid the construction of an &quot;empty&quot; object and the overhead of cleaning it up at the assignment). And some things can&#39;t be initialized using assignment, like member references and const members and things without default constructors. So it&#39;s best to always use initialization lists even if you don&#39;t have to for the sake of &quot;symmetry&quot;. There are exceptions to this rule. There&#39;s no need for an exhaustive list of them - search your feelings.
</p>

<p>
<b class="FQA">FQA:</b> There are good reasons to avoid initialization lists:
</p>

<ul>
<li>You can&#39;t write most kinds of code in the initialization lists - no local variables to reuse results of computations, no loops... Basically there&#39;s C++ and there&#39;s this initializer land, where you must speak a crippled dialect without any reward for the effort.</li>
<li>You can&#39;t <a href="fqa.html#fqa-10.3">move initializers to a common function</a> to reuse initialization code.</li>
<li>If you want to pass a pointer to one member to the constructor of another member, you must make sure its constructor is called first, and these constraints can get complicated.</li>
<li>To help you manage those constraints, some compilers produce annoying warnings when the order of your initializers differs from the order in which you declare the class members, even when it doesn&#39;t matter.</li>
<li>The efficiency argument is wrong for a very common case when the default constructor of a member does nothing.</li>
<li>Typically compilers attribute all code in initializer lists to the same source code line - for example, the one with the opening brace of the constructor body. When a program crashes inside an initializer, you can&#39;t easily tell which one it is using a symbolic debugger.</li>
<li>Not that it&#39;s very different from the rest of C++, but the colon syntax is just plain ugly.</li>
</ul>

<p>
The trouble with initialization lists, like with any duplicate language feature, is that you <i>can&#39;t</i> really avoid using it. For example, there are classes without default constructors, or with relatively heavy ones. So &quot;never use initialization lists&quot; is not a very useful rule, and the best answer, as usual, is that there&#39;s no good answer.
</p>

<p>
However, initialization lists are really less than useful, so it&#39;s probably good to avoid them unless you can&#39;t. In particular, avoiding reference and const members and having lightweight default constructors in your classes may help.
</p>


<a id="fqa-10.7"></a>
<h2>[10.7] Should you use the <code>this</code> pointer in the constructor?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.7">FAQ:</a></b> Some people think you can&#39;t since the object is not fully initialized, but you can if you know the rules. For example, you can always access members inside the constructor body (after the opening brace). But you can never access members of a derived class by calling virtual functions (the function call will <a href="fqa.html#fqa-23.5">invoke the implementation of the class defining the constructor</a>, not that of the derived class). Sometimes you can use a member to initialize another member in an initializer list and sometimes you can&#39;t - you must know the order in which members are initialized.
</p>

<p>
<b class="FQA">FQA:</b> That&#39;s right - all problems and questionable scenarios come from tricky C++ things, like initialization lists and virtual function calls from constructors. If you avoid initialization lists and use plain old assignment or initialization function calls in the constructor body, you can be sure all members can be used - you have one problem solved. Use init functions instead of constructors and virtual function calls will <a href="fqa.html#fqa-23.6">invoke functions of the derived class</a> - another problem solved.
</p>

<p>
An alternative to avoiding the dark corners of C++ is to spend time learning them. For example, you can memorize the rules defining the order of initialization, and rely on them heavily in your code. That way people who need to understand and/or maintain your code will have to get pretty good at these things, too, so you won&#39;t end up being the only one around knowing tons of useless obscure stuff. Or they will have to ask you, which increases your weight in the organization. You win big either way, at least as long as nobody chooses the path of physical aggression to deal with the problems you create.
</p>


<a id="fqa-10.8"></a>
<h2>[10.8] What is the &quot;Named Constructor Idiom&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.8">FAQ:</a></b> It&#39;s when you have static functions (&quot;named constructors&quot;) returning objects in your class. For example, this way you can have two &quot;constructors&quot; returning 2D point objects: one getting rectangular coordinates (2 <code>float</code>s), and another getting polar coordinates (also 2 <code>float</code>s). With C++ constructors you couldn&#39;t do it because they all have the same name, so that would be ambiguous overloading. And this can be as <i>fast</i> as regular constructors! And you can use a similar technique to enforce an allocation policy, like having all objects allocated with <code>new</code>.
</p>

<p>
<b class="FQA">FQA:</b> Three cheers! This is almost like C init functions - a step in the right direction. Namely, this way we don&#39;t have overloading problems, and we can get rid of the pesky <a href="fqa.html#fqa-10.1">separation of allocation from initialization</a> - client code doesn&#39;t really have to <a href="fqa.html#fqa-7.5">know about our private members</a> anymore.
</p>

<p>
The only thing left to do is to ditch the whole class thing, and use C pointers to incomplete types as object handles - that way we can actually modify private members without recompiling the calling code. Or we can use a real object-oriented language, where the problem doesn&#39;t exist in the first place.
</p>


<a id="fqa-10.9"></a>
<h2>[10.9] Does return-by-value mean extra copies and extra overhead?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.9">FAQ:</a></b> &quot;Not necessarily&quot;. A truly exhausting, though not necessarily exhaustive list of examples follows, with many stories about &quot;virtually all commercial-grade compilers&quot; doing clever things.
</p>

<p>
<b class="FQA">FQA:</b> Let&#39;s enumerate the possibilities using boring binary logic:
</p>

<ul>
<li>You care about performance.</li>
<li>You don&#39;t care about performance.</li>
</ul>

<p>
In the first case, &quot;not necessarily&quot; is not a good answer for you. You don&#39;t want your code to be littered with things like return-by-value and later wonder why your &quot;commercial-grade&quot; compiler emits huge and slow code in some of the performance-critical places. If performance is one of your goals, you&#39;re better off writing code in ways making it as easy as possible to predict performance, without knowing an infinite amount of details specific for each of the compilers you use for production code. And if you have experience with optimization, you&#39;ve probably noticed another thing - most C++ compilers work hard on optimizing the C subset, but are pretty dumb when it comes to C++-specific parts. Compiler writers are probably happy if they can correctly <i>parse</i> C++ code and somehow lower it to C and have the back-end optimize stuff at the C level. Basically to get performance you need C, because that&#39;s what today&#39;s optimizers are best at, and you&#39;re wasting time with C++.
</p>

<p>
If you don&#39;t care about performance, you are <i>also</i> wasting time using C++. There are hordes of programming languages designed for managed environments, so you won&#39;t have problems coming from undefined behavior of all kinds. And the vast majority of languages are way simpler and more consistent than C++, so you&#39;ll get another huge burden off your back.
</p>

<p>
Of course our boring binary logic fails to represent the <a href="fqa.html#fqa-35.10">developers</a> who <i>think</i> they care about performance, although they have a very vague idea about the actual performance of their programs. Those are the people who use the von Neumann model (&quot;you access memory using pointers which are actually indexes of individual bytes&quot;) to think about computers, and call this &quot;the low level&quot;. They are typically less aware of things like instruction caches (which make <i>big</i> programs <i>slow</i>), SIMD instruction sets (which can give performance gains <i>way beyond</i> &quot;generic&quot; template implementations of numerical algorithms), assembly language and optimizers in general (for example, how <code>restrict</code> helps optimization but <code>const</code> <a href="fqa.html#fqa-18.14">doesn't</a>). These people engage in lengthy discussions about complicated high-level optimizations, their ultimate goal being very generic code which can be compiled to a very efficient program by a very smart compiler, which will never exist. These people are welcome to waste as much time thinking about return-by-value optimizations as they wish, as long as it prevents them from causing actual damage.
</p>


<a id="fqa-10.10"></a>
<h2>[10.10] Why can&#39;t I initialize my <code>static</code> member data in my constructor&#39;s initialization list?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.10">FAQ:</a></b> Because you must define such data explicitly as in <code>static MyClass::g_myNum = 5;</code>.
</p>

<p>
<b class="FQA">FQA:</b> Because it&#39;s meaningless. <code>static</code> members are global variables with respect to allocation and life cycle, the only difference is in the name look-up and access control. So they are instantiated and initialized once per program run. Initialization lists initialize the members of objects which are instantiated with each object, which can happen more or less times than once per program run.
</p>

<p>
One possible reason making this question frequently asked is that you can <i>assign</i> to static variables in the body of a constructor, as in <code>g_numObjs++</code>. People trying to follow the <a href="fqa.html#fqa-10.6">advice</a> to use the crippled C++ subset available in the initialization lists might attempt to translate this statement to initializer-like <code>g_numObjs(g_numObjs + 1)</code> or something, which doesn&#39;t work.
</p>

<p>
You can probably look at it both ways - &quot;initializers are used to initialize things instantiated per object&quot; and &quot;the subset of C++ available in initialization lists makes it impossible to do almost anything&quot;.
</p>


<a id="fqa-10.11"></a>
<h2>[10.11] Why are classes with <code>static</code> data members getting linker errors?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.11">FAQ:</a></b> Because you must define such data explicitly as in <code>static MyClass::g_myNum = 5;</code>.
</p>

<p>
<b class="FQA">FQA:</b> Beyond being annoying, this is quite weird. At the first glance it looks reasonable: after all, C++ is just a thick layer of syntax on top of C, but the basic simpleton mechanisms are the same. For instance, definition look-up is still done using header files holding random declarations and object files holding arbitrary definitions - each function can be declared anywhere (N times) and defined anywhere (1 time).
</p>

<p>
So the compiler can&#39;t let you define something which becomes a global variable at the C/assembly level in a header file as in <code>static int g_myNum = 5;</code> - that way, you&#39;d get multiple definitions (at each file where the class definition is included). Consequently, the C++ syntax is defined in a way forcing you to solve the compiler&#39;s problem by choosing a source file and stuffing the definition there (most frequently the choice is trivial since a class is implemented in a single source file, but this is a <i>convention</i>, not a rule the compiler can use to simplify definition look-up).
</p>

<p>
While this explanation doesn&#39;t make the syntax and the weird &quot;undefined external&quot; errors any nicer, at least it seems to make sense. Until you realize that there are <i>tons</i> of definitions compiled to C/assembly globals in C++ that <i>must</i> be placed at header files. Consider <a href="fqa.html#fqa-23.10">virtual function tables</a> and template classes. These definitions are compiled over and over again each time a header file gets included, and then the linker must throw away N-1 copies and keep one (if the copies are different because of different compiler settings and/or preprocessor flags, it&#39;s your problem - it won&#39;t bother to check).
</p>

<p>
It turns out that C++ <i>can&#39;t</i> be implemented on top of any linker that supports C - the linker must support the &quot;generate N times and throw away N-1 copies&quot; feature (or is it a documented bug?), instead of issuing a &quot;multiple definition&quot; error. In GNU linkers this is called &quot;linkonce&quot; or something. To support C++, you must add features to the linker. Too bad they didn&#39;t think of adding type-safe linkage (checking the consistency of definitions used in different object files) while they were at it.
</p>

<p>
The conclusion is that there is no technical reason whatsoever, even inside the twisted C++ universe, to make the syntax harder for the user in this case. On the other hand, there&#39;s no reason to make the syntax <i>easier</i> either. That would just introduce inconsistency with the rest of the language.
</p>


<a id="fqa-10.12"></a>
<h2>[10.12] What&#39;s the &quot;static initialization order fiasco&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.12">FAQ:</a></b> A subtle, frequently misunderstood source of errors, which are hard to catch because they occur before <code>main</code> is called. The errors can happen when the constructor of a global object defined in <code>x.cpp</code> accesses (directly or indirectly) a global object defined in <code>y.cpp</code>. The order of initialization of these objects is undefined, so you&#39;ll see the problem in 50% of the cases (an error may be triggered by a rebuild). &quot;It&#39;s that simple&quot;.
</p>

<p>
<b class="FQA">FQA:</b> And it&#39;s <i>that</i> stupid. Just look at this:
</p>

<ul>
<li>C++ doesn&#39;t define the order of initialization of global objects.</li>
<li>C++ lets you write code that depends on the order of initialization of global objects.</li>
<li>C++ doesn&#39;t have a mechanism to automatically detect these errors, neither at compile time nor at run time.</li>
<li>C++ doesn&#39;t make the slightest effort to help you debug the problem (for example, go figure in which actual order the objects were initialized).</li>
</ul>

<p>
With most duplicate language features, one can&#39;t simply say &quot;avoid the new broken C++ features&quot; because the language <a href="fqa.html#fqa-10.6">works so hard</a> to get you in trouble if you do. But in this particular case it&#39;s probably a good rule. Consider the reasons to avoid instantiating global objects with non-trivial constructors (ones that do more than nothing), and instead use plain old C aggregate initialization:
</p>

<ul>
<li>You have to worry about this &quot;fiasco&quot; business, which is quite nasty. With C initializers, once you passed compilation and linkage, there are no problems - the linker creates a snapshot of the initial state of your global variables, and there are no failure modes.</li>
<li>You have all this initialization code before <code>main</code>, with corresponding clean-up code called after <code>main</code>. What if you want to clean up and re-initialize things <i>without</i> exiting <code>main</code>? People calling <code>getenv</code> or accessing the command line using platform-specific tricks in code called before <code>main</code> further improve the life of other people working on the project.</li>
<li>Your program contains a huge bulk of slow initialization code. A C statement like <code>Point p={4,5};</code> gets translated to 8 bytes representing the integers 4 and 5 in the executable. A C++ statement like <code>Point p(4,5);</code> gets translated to <i>code</i> storing 4 and 5 to <code>p</code>. What are the benefits except for getting large programs starting up slowly?</li>
</ul>

<p>
Some people believe that you need non-trivial global constructors, or else you&#39;ll have to make your user call an initialization function to work with your module. The fact is that the experienced users <i>prefer</i> to initialize modules explicitly rather than having them autonomously kicking in, possibly crashing the program because of dependency issues, not to mention printing messages and popping up configuration dialogs. All of these implicit things tend to become quite <i>explicit</i> on the day when you least need them to. Quoting the FAQ&#39;s favorite expression, just say no.
</p>


<a id="fqa-10.13"></a>
<h2>[10.13] How do I prevent the &quot;static initialization order fiasco&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.13">FAQ:</a></b> By using the &quot;Construct On First Use&quot; idiom, as in
</p>

<pre>
MyClass&amp; getMyObj()
{
  static MyClass* p = new MyClass;
  return *p;
}
</pre>

<p>
This solution may &quot;leak&quot;. There&#39;s another solution working around this problem, but it creates other problems.
</p>

<p>
<b class="FQA">FQA:</b> By not instantiating global objects with constructors doing more than nothing. That prevents this and other kinds of &quot;fiasco&quot;. The technique in the FAQ, frequently referred to as an implementation of &quot;the singleton design pattern&quot; (BTW, you can put quotes wherever you like in that one, for example the &quot;singleton&quot; &quot;design&quot; &quot;pattern&quot;), has the following problems:
</p>

<ul>
<li>As mentioned by the FAQ, it leaks memory <i>and possibly other resources</i> (C++ people love to talk about how memory is &quot;just one kind of resource&quot;, overlooking the fact that it accounts for 99% of &quot;resources&quot; actually used by a program, so special, &quot;non-generic&quot; things like <a href="fqa.html#fqa-16.1">garbage collection</a> may be appropriate to manage it - but they suddenly forget all about it when it comes to this &quot;construct on first use&quot; business). Practitioners may find it intolerable to have these memory leaks reported by tools designed to detect leaks, even if their platform is capable of disposing the garbage left by a program automatically. People interested in a more theoretical discussion may enjoy the recommendation to violate the C++ rules regarding memory management found in a &quot;standard practice&quot;.</li>
<li>It is slow, not to mention thread safety. When you have a plain C global initialized by a plain C explicit initialization function, accessing it is quite easy (function arguments may be faster to fetch, or they may be not). In this case, you call a function (which can be inlined - that doesn&#39;t necessarily help though) that contains a hidden <code>if</code> statement. You don&#39;t see it? Well, how do you think the clever function manages to only call <code>new</code> once? There&#39;s a global boolean (sometimes called &quot;guard variable&quot;) which it checks each time. To access a global, you now need to access two globals. If you find it interesting, you can list the symbols of your program (using a program like <code>nm</code>), and then filter the output using a C++ name demangler (like <code>c++filt</code>). You may find lots of &quot;guard variable of something&quot; kind of names there.</li>
</ul>

<p>
The C++ global initialization and destruction support is broken. As usual, the &quot;idiom&quot; in the FAQ &quot;solves&quot; the problem by creating worse problems.
</p>


<a id="fqa-10.14"></a>
<h2>[10.14] Why doesn&#39;t the construct-on-first-use idiom use a static object instead of a static pointer?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.14">FAQ:</a></b> It solves one problem and creates another problem. Namely, you avoid the resource leak, but your program can crash because now you achieved &quot;construct-on-first-use&quot;, but not &quot;destroy-after-last-use&quot;, so someone can access a dead object (using <code>new</code> means &quot;never destroy&quot;, which is at least guaranteed to be <i>after</i> last use).
</p>

<p>
Actually there&#39;s a <i>third</i> approach solving <i>both</i> problems (initialization and destruction order), having &quot;non-trivial cost&quot;. The FAQ author feels &quot;too lazy and busy&quot; to explain - go buy his &quot;C++ FAQ Book&quot; to read about it.
</p>

<p>
<b class="FQA">FQA:</b> The FAQ is right - this variant, known as &quot;the Meyers&#39; singleton&quot;, is also broken. And it&#39;s probably the hardest to work around, too. At least with the <code>new</code> variant you <i>can</i> delete the object with <code>delete &amp;getMyObj();</code> - increasingly ugly, but it may yield a working (though unmaintainable) program. With the static variable technique, C++ records a pointer to the destructor in some global array, so you won&#39;t be able to control the order of destruction (it&#39;s always the order of construction, reversed - and you <i>didn&#39;t</i> want to control the order of construction, you wanted it to &quot;just work&quot;, right?).
</p>

<p>
As to other approaches - I do have enough energy and spare time to repeat a <i>free</i> advice: use explicit initialization and clean-up functions, and realize that the initialization and destruction sequences are part of the <i>design</i> of your modules and your program.
</p>

<p>
If it&#39;s hard to get out of the state of mind where you think initialization should somehow work out by itself, as opposed to the really interesting things your program does afterwards (the &quot;steady state&quot;), maybe an analogy with hardware can help. In a simplified model of synchronous hardware design, you have two &quot;trees&quot; of signals (basically wires) reaching almost every place in your system: the <i>clock</i> (which synchronizes things done at the steady state), and the <i>reset</i> (upon which all the initialization is conditioned). A common milestone in hardware design is getting the reset right. When you buy hardware, a large portion of it is devoted to initialization (which is why you can <i>reboot</i> it and it enters a reasonable state - you can&#39;t do that with biological &quot;computers&quot; like the human brain).
</p>

<p>
By the way, I didn&#39;t read the C++ FAQ book (I really don&#39;t have time for a C++ FQA book at the moment, so why bother?). But I did read &quot;Modern C++ Design&quot;, which also offers a solution. So if you buy the FAQ book and find the third &quot;solution&quot; and it involves having your singletons instantiated from a hairy template with a global data structure keeping &quot;priorities&quot; or some such and registering <code>atexit</code> callbacks which can in turn call <code>atexit</code> which detects dark areas in the C and C++ standards because nobody thought anyone would ever do that - if that&#39;s the third way, be sure that the cost is <i>really</i> &quot;non-trivial&quot;.
</p>


<a id="fqa-10.15"></a>
<h2>[10.15] How do I prevent the &quot;<code>static</code> initialization order fiasco&quot; for my <code>static</code> data members?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.15">FAQ:</a></b> Using the same techniques <a href="fqa.html#fqa-10.14">just described</a>, except for using static member functions instead of global functions. For some reason a long list of examples follows, as well as a discussion on performance.
</p>

<p>
<b class="FQA">FQA:</b> There&#39;s no difference between static data members and global variables except for name look-up and access control. So you can either use the broken &amp; slow techniques from the FAQ, or you can avoid non-trivial constructors and live happily ever after.
</p>

<p>
There&#39;s no point in having separate discussions on static data members and plain global variables. Well, except for mentioning that static data members are a brand new C++ feature, and it&#39;s particularly nice that C++ recommends to wrap its own syntax with another layer of its syntax for &quot;safety&quot;. An alternative approach to safety is to use zero layers of C++ syntax.
</p>


<a id="fqa-10.16"></a>
<h2>[10.16] Do I need to worry about the &quot;<code>static</code> initialization order fiasco&quot; for variables of built-in/intrinsic types?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.16">FAQ:</a></b> Yes, if you use function calls to initialize them as in <code>int g = f();</code> - that way <code>f</code> can access <code>g</code>, or you can have other dependency problems.
</p>

<p>
<b class="FQA">FQA:</b> Exactly - and this code doesn&#39;t compile in C. We seem to have a <a href="fqa.html#fqa-10.7">pretty clear picture</a> here, don&#39;t we? As a rule of thumb, the answer to the more general version of the question - &quot;Do I need to worry when I use a C++ feature not available in C?&quot; - is also &quot;Yes&quot;.
</p>

<p>
Not that plain C is very safe, mind you. If you <a href="fqa.html#fqa-10.9">don't need the performance</a>, you can always switch to a safer, higher-level language. But at least C doesn&#39;t pretend to be very high-level, and makes less promises it can&#39;t keep (like &quot;go ahead, use whatever code you like to initialize global variables - see how high-level our language is?&quot;).
</p>


<a id="fqa-10.17"></a>
<h2>[10.17] How can I handle a constructor that fails?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.17">FAQ:</a></b> Throw an exception.
</p>

<p>
<b class="FQA">FQA:</b> Right.
</p>

<p>
Q: What do you do when a ship is on fire?<br>
A: Drown it. The fire will stop immediately.
</p>

<p>
Seriously, <a href="fqa.html#fqa-17.10">C++ exceptions</a> are a leading candidate for the title &quot;the worst way to handle run time errors ever invented&quot;. But constructors can&#39;t return values. Even though they <i>don&#39;t</i> technically return an object - they merely initialize a chunk of memory they are passed. So they <i>could</i> return status information despite the C/C++ limitation of at most one return value per function. Which itself has no technical justification. This is <a href="fqa.html#fqa-10.5">yet another</a> reason to avoid constructors that do more than nothing. It&#39;s also <a href="fqa.html#fqa-10.12">yet another</a> illustration how <a href="fqa.html#fqa-10.6">hard</a> it is to use only some of C++ features and avoid others (&quot;we want classes, but we don&#39;t need exceptions&quot; - until you want to handle an error in a constructor).
</p>

<p>
It is also notable that the C++ standard library <i>doesn&#39;t</i> handle errors in constructors (or overloaded operators, which pose the same problem) using exceptions (for example, consider <code>ifstream</code> and <code>ofstream</code>).
</p>


<a id="fqa-10.18"></a>
<h2>[10.18] What is the &quot;Named Parameter Idiom&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.18">FAQ:</a></b> A useful application of method chaining. It works around the fact that C &amp; C++ don&#39;t have keyword arguments, and it does that better than combining the parameters in a string or a bit mask. It works like this:
</p>

<pre>
File f = OpenFile(&quot;language-abuse.txt&quot;)
         .useWeirdLineBreakRules(true)
         .writeLotsOfGoryDetails(true)
         .averageNumberOfExcuses(ZILLION);
/* a sizable implementation with two classes and friends
   and methods returning *this and what-not omitted */
</pre>

<p>
And if method calls are inlined, there&#39;s no speed overhead (but the code size may &quot;slightly&quot; increase - but that&#39;s a long story).
</p>

<p>
<b class="FQA">FQA:</b> Let&#39;s have a closer look at this Named Parameter Idiocy.
</p>

<ul>
<li>The implementation in the FAQ pushes these parameters into a temporary structure, which is normally slower than argument passing.</li>
<li>And the multiple method calls, inlined or not, are no picnic either. Compare assembly code generated by <code>printf</code> and <code>iostream</code> calls if you doubt. This way you can compare your notion of &quot;slightly&quot; with that used by the designers of C++.</li>
<li>All ways to implement this require the author of the class to write a lot of code ultimately doing nothing. Which is OK because in theory, <a href="fqa.html#fqa-13.4">each class is written once and used thousands of times</a>. In practice most classes keep changing forever and are used in a couple of places. Which doesn&#39;t matter as long as you only use C++ in theory where it belongs.</li>
<li>But that would be justified to an extent if it made things easier for the user. But it doesn&#39;t. Try reading the header file with the <code>class OpenFile</code> and figuring out how to open files.</li>
<li>And now that we have this <code>OpenFile</code> class, people will start storing objects of this class and passing them around. Which could be a good idea in some cases, except that the class has a stupid function-like name, further enhancing readability.</li>
<li>Or we could use a different implementation, chaining the methods of <code>class File</code> and avoiding the second class. But this way, we can&#39;t detect errors easily, because there&#39;s no point where we see all of the parameters at once, we get them one by one.</li>
</ul>

<p>
This syntactic sugar of the bitter kind raises two questions. First, why don&#39;t we have keyword arguments in C++? They are much easier to implement in a compiler than virtually any feature C++ added to C, and are way more useful, too. And second, if for some reason you have to work in C++, what&#39;s the problem with accepting the fact that it doesn&#39;t have keyword arguments, and using a structure of parameters in way at least making it <i>clear</i> that you use a structure of parameters? For example:
</p>

<pre>
OpenFileParams params;
params.useNormalLineBreaks(true);
params.quitFiddlingWithSyntax(true);
File file; //trivial constructor
if(!file.open(&quot;grow-up.txt&quot;,params)) {
  //handle errors without the &quot;help&quot; of C++ exceptions
}
</pre>

<p>
This doesn&#39;t solve the problems with code speed &amp; size, but at least the code of the class and the code using the class are reasonably readable and writable. And there seem to be no new problems, unless someone considers the fact that our code is now pretty close to C and we no longer rely on C++ method chaining a problem.
</p>

<p>
Abusing C++ syntax in order to cover up deficiencies of C++ syntax, thus creating real problems in attempts to solve non-problems, is a popular hobby among C++ professionals. Let&#39;s check if it makes sense by imagining that someone spent the better part of the day writing all this wrapper code doing trivial things. Let&#39;s try to help that someone explain what was accomplished to someone else, and further assume that the other someone has a mind not entirely buried in C++ quirks. &quot;I was writing this... Um, you see, I was opening a file... I wrote this interface of 2 screens of code... And then...&quot; Sheesh, that&#39;s embarrassing.
</p>


<a id="fqa-10.19"></a>
<h2>[10.19] Why am I getting an error after declaring a <code>Foo</code> object via <code>Foo x(Bar())</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/ctors.html#faq-10.19">FAQ:</a></b> This <i>hurts</i>. <i>Sit down</i>.
</p>

<p>
The &quot;simple&quot; explanation: this doesn&#39;t really declare an object; <code>Foo x = Foo(Bar());</code> does. The complete explanation for &quot;those caring about their professional future&quot;: this actually declares a function named <code>x</code> returning a <code>Foo</code>; the single argument of this <code>x</code> function is of type &quot;a function with no argument returning a <code>Bar</code>&quot;.
</p>

<p>
Don&#39;t get all excited about it. Don&#39;t &quot;extrapolate from the obscure to the common&quot;. Don&#39;t &quot;worship consistency&quot;. That&#39;s not &quot;wise&quot;. The FAQ actually says all these quoted things.
</p>

<p>
<b class="FQA">FQA:</b> Those who use computers to do any useful work are probably immune to brain-crippled syntax, because there are more painful things, like brain-crippled semantics. So sitting down is only necessary if you find it comfortable. For similar reasons, don&#39;t worry about your professional future too much if this looks boring and stupid and you don&#39;t feel like understanding it. It really is what you think it is, and programming is not supposed to be about this kind of thing. If someone rejects you in an <a href="fqa.html#fqa-6.14">interview</a> because you don&#39;t know the answer to a question like this, you are lucky - you&#39;ve just escaped a horrible working environment.
</p>

<p>
Anyway, if for some reason you <i>are</i> curious to find out why this happens, it turns out the FAQ has no answers, it just presents it as an arbitrary rule. It doesn&#39;t help to understand anything. The statement is ambiguous - you can read it both as a constructor call and a declaration of a peculiar function. How does the compiler know? Let&#39;s try to see.
</p>

<p>
Apparently the key problem is that in order to tell a function declaration from a constructor call, you need to know whether the things in the parentheses are objects or types. This makes parsing <code>A f(B);</code> <a href="fqa.html#fqa-10.2">non-trivial</a>. In our example, things are complicated by the fact that <code>Bar()</code> itself presents <i>the very same problem</i> - is it a function declaration or a constructor call? Worse, this time the darn thing accepts no arguments, so you can&#39;t use them to figure it out. Well, C++ has an arbitrary rule to help the compiler (but not necessarily the user): things with empty parentheses are function declarations, unless that&#39;s entirely impossible (list of special cases follows). That&#39;s why <code>A x();</code> declares a function but <code>A x;</code> defines an object. And that&#39;s why <code>Bar()</code> is interpreted as a function declaration, which means that it&#39;s an argument type, not an object, so the whole statement is actually a function declaration. I think.
</p>

<p>
The problem with <code>Foo</code> and <code>Bar</code> is that the C++ grammar is FUBAR. In a language designed in a more orderly way (which is most of them), there are no such ambiguities. A relatively simple way to make sure there are none is to use a formal grammar specification and feed it to a program that generates a parser for the language, checking the consistency of the grammar on the way. <code>yacc/bison</code> is one mature program of this kind; there are newer ones with more features, which can represent more complicated grammars (but AFAIK no generic tool is capable of representing the extremely complicated, inconsistent and actually undecidable C++ grammar).
</p>

<p>
It could help the users if the people promoting C++ realized that the consistency of a grammar is not something you &quot;worship&quot;, but a technical property which is far easier to achieve than it is to deal with the consequences of not having it. This example is just one drop in the ocean of such problems. The complexity of the C++ grammar guarantees that compiler error messages will remain cryptic, debuggers will stay ignorant, and IDEs will be unhelpful compared to those available for other languages forever.
</p>

<a id="fqa-dtor"></a><h1>Destructors</h1>
<p>
Destructors are one of the many pieces of the puzzle that is the C++ <a href="fqa.html#fqa-16.1">memory management</a>.
</p>

<ul>
<li><a href="fqa.html#fqa-11.1">[11.1] What&#39;s the deal with destructors?</a></li>
<li><a href="fqa.html#fqa-11.2">[11.2] What&#39;s the order that local objects are destructed?</a></li>
<li><a href="fqa.html#fqa-11.3">[11.3] What&#39;s the order that objects in an array are destructed?</a></li>
<li><a href="fqa.html#fqa-11.4">[11.4] Can I overload the destructor for my class?</a></li>
<li><a href="fqa.html#fqa-11.5">[11.5] Should I explicitly call a destructor on a local variable?</a></li>
<li><a href="fqa.html#fqa-11.6">[11.6] What if I want a local to &quot;die&quot; before the close <code>}</code> of the scope in which it was created? Can I call a destructor on a local if I <i>really</i> want to?</a></li>
<li><a href="fqa.html#fqa-11.7">[11.7] OK, OK already; I won&#39;t explicitly call the destructor of a local; but how do I handle the above situation?</a></li>
<li><a href="fqa.html#fqa-11.8">[11.8] What if I can&#39;t wrap the local in an artificial block?</a></li>
<li><a href="fqa.html#fqa-11.9">[11.9] But can I explicitly call a destructor if I&#39;ve allocated my object with <code>new</code>?</a></li>
<li><a href="fqa.html#fqa-11.10">[11.10] What is &quot;placement <code>new</code>&quot; and why would I use it?</a></li>
<li><a href="fqa.html#fqa-11.11">[11.11] When I write a destructor, do I need to explicitly call the destructors for my member objects?</a></li>
<li><a href="fqa.html#fqa-11.12">[11.12] When I write a derived class&#39;s destructor, do I need to explicitly call the destructor for my base class?</a></li>
<li><a href="fqa.html#fqa-11.13">[11.13] Should my destructor throw an exception when it detects a problem?</a></li>
<li><a href="fqa.html#fqa-11.14">[11.14] Is there a way to force <code>new</code> to allocate memory from a specific memory area?</a></li>
</ul>

<a id="fqa-11.1"></a>
<h2>[11.1] What&#39;s the deal with destructors?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.1">FAQ:</a></b> A destructor, abbreviated &quot;dtor&quot;, is a &quot;you&#39;re about to die&quot; member function. It is used to release
resources, for example, semaphores. Most frequently the resource is memory allocated by <code>new</code>;
the destructor frees it with <code>delete</code>.
</p>

<p>
<b class="FQA">FQA:</b> Yep, <a href="fqa.html#fqa-16.1">C++ has no garbage collection</a>, which makes &quot;memory&quot; a manually managed &quot;resource&quot;. Die-hard C++ programmers
firmly believe that <a href="fqa.html#fqa-17.4">RAII</a> - acquiring resources in constructors and releasing them in destructors - is the silver
bullet for resource management. The problem with this approach is that many objects can point to the same piece of data,
but only one of them is the &quot;owner&quot;, and when the owner dies, its destructor promptly blows the piece of data
to even smaller little pieces.
</p>

<p>
The most common way around this is <i>copying</i>. For example, you load a large file representing a 3D object model
or an XML document or something. You find an interesting leaf on the 3D tree model or in the XML tree or whatever.
Now you want to release the memory of the whole model so that you can free some space for processing the part.
You need to either convince the model object that it doesn&#39;t own the stuff in your leaf, or you have to copy
that stuff. The latter is way easier
(try to convince an owner such as <code>std::list</code> to let a couple of nodes go out of its jurisdiction).
</p>

<p>
Which is one reason that can cause garbage collection to outperform manual memory management. But of course with garbage
 collection you&#39;ll never master your debugging tools to an extent anywhere near the expertise you&#39;ll reach with
 manual memory management
(you&#39;ll have 10 times less bugs to practice on). It&#39;s up to you to choose the right tradeoff.
</p>

<p>
There are two common counter arguments: not all resources are memory, and not all systems can afford garbage collection.
 Well, surely more than 95% of resources <i>are</i> memory, and surely more than 95% of C++ code runs in systems which <i>can</i> afford garbage collection.
These arguments are yet another evidence that <a href="fqa.html#fqa-6.2">C++ is about theory, not practice</a>. And the resources which are not memory
and must be released deterministically usually aren&#39;t handled very well be C++ destructors anyway. That&#39;s because a C++
 destructor can&#39;t handle errors (it has no return value and <a href="fqa.html#fqa-11.13">it can't throw exceptions</a>).
</p>


<a id="fqa-11.2"></a>
<h2>[11.2] What&#39;s the order that local objects are destructed?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.2">FAQ:</a></b> In reverse order of construction - the stuff declared last is destroyed first.
</p>

<p>
<b class="FQA">FQA:</b> Which makes sense, but are you sure you want to write code that depends on this?
</p>


<a id="fqa-11.3"></a>
<h2>[11.3] What&#39;s the order that objects in an array are destructed?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.3">FAQ:</a></b> In reverse order of construction - the last element is destroyed first.
</p>

<p>
<b class="FQA">FQA:</b> Which sort of makes sense, but you <i>surely</i> don&#39;t want to write code that depends on that one, do you?
</p>

<p>
By the way, don&#39;t forget to use <code>delete[]</code>, not just <code>delete</code>, to free arrays allocated with <code>new[]</code>, otherwise the stupid thing
 <a href="fqa.html#fqa-16.12">will not bother</a> to check the number of elements pointed by your pointer and some of your destructors won&#39;t get called
 (actually, in theory it could be worse - the behavior is undefined).
</p>


<a id="fqa-11.4"></a>
<h2>[11.4] Can I overload the destructor for my class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.4">FAQ:</a></b> No. Destructors never have parameters or return values. And you&#39;re not supposed to call destructors explicitly,
so you couldn&#39;t use parameters or return values anyway.
</p>

<p>
<b class="FQA">FQA:</b> Why do you want to overload destructors? Do you like C++ overloading? Are you sure? But the lack of return values
 <i>is</i> a pity - <a href="fqa.html#fqa-11.13">no way to handle errors</a>. Let&#39;s hope they won&#39;t happen, shall we?
</p>


<a id="fqa-11.5"></a>
<h2>[11.5] Should I explicitly call a destructor on a local variable?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.5">FAQ:</a></b> Don&#39;t do that! The destructor will be called again at the end of scope. And the second call will do nasty things,
 like crashing your program or something.
</p>

<p>
<b class="FQA">FQA:</b> There are standard questions to ask in these cases, like &quot;if this syntax is never useful, why does it compile&quot;? Anyway, you <i>can</i> call a destructor
 on a local variable, but you have to make sure you call a constructor after that and before the object goes out of scope.
 For example:
</p>

<pre>
AMiserableFileClass file(&quot;f1.txt&quot;);
//use file... now we want to close it, but there&#39;s no close() method, so:
file.~AMiserableFileClass();
//open another file
new (&amp;file) AMiserableFileClass(&quot;f2.txt&quot;);
</pre>

<p>
<code>AMiserableFileClass</code> is a miserable file class because it has no <code>close</code> method, so you might feel the need to close it
 in the ugly way above. Try to avoid this, because most people won&#39;t understand it, and they shouldn&#39;t, because <a href="fqa.html#fqa-6.4">there
 are better things to do</a> than <a href="fqa.html#fqa-10.19">fiddling with the many ugly bits of C++</a>.
</p>


<a id="fqa-11.6"></a>
<h2>[11.6] What if I want a local to &quot;die&quot; before the close <code>}</code> of the scope in which it was created? Can I call a destructor on a local if I <i>really</i> want to?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.6">FAQ:</a></b> No, no, no! See the next FAQ for a simple solution. But don&#39;t call the destructor!
</p>

<p>
<b class="FQA">FQA:</b> If you ever get into the situation of promoting an especially disgusting product, such as the C++ programming language, there are better ways to handle it
than get all excited. You can try and find a less disgusting product to center your money-making around, or you can
just relax.
</p>

<p>
&quot;Don&#39;t call the destructor&quot;. There has to be <i>some</i> reason for the destructor call to compile, doesn&#39;t it? Perhaps
sharing it with us could help calm down.
</p>


<a id="fqa-11.7"></a>
<h2>[11.7] OK, OK already; I won&#39;t explicitly call the destructor of a local; but how do I handle the above situation?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.7">FAQ:</a></b> Now you&#39;re talking! Here&#39;s a tip - you can simply surround the object with an <i>artificial block</i>:
</p>

<pre>
{
  AMiserableFileClass file(&quot;f1.txt&quot;);
} //the file object dies here
</pre>

<p>
<b class="FQA">FQA:</b> Is this ugly code supposed to be better than <a href="fqa.html#fqa-11.5">the ugly code</a> calling a destructor and than a constructor? On a level,
this version is more cryptic
(at least it&#39;s easy to see what gets called when in that other ugly piece of code). But the truth is that
for many actual C++ programmers the &quot;artificial blocks&quot; (isn&#39;t all code &quot;artificial&quot;?) are more readable.
</p>


<a id="fqa-11.8"></a>
<h2>[11.8] What if I can&#39;t wrap the local in an artificial block?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.8">FAQ:</a></b> If you absolutely have to, do something like adding a <code>close</code> method to <code>AMiserableFileClass</code> which closes the file
 in its destructor. So you can achieve the effect of the destructor call without calling the destructor. Which is a taboo,
 get it?
</p>

<p>
The FAQ also points out how hard it is to write a <code>close</code> function so that the destructor doesn&#39;t try to close a closed
 file.
</p>

<p>
<b class="FQA">FQA:</b> If you can change <code>AMiserableFileClass</code>, it&#39;s better than using ugly code to work around its deficiencies. But
 where&#39;s the FAQ&#39;s brave new <a href="fqa.html#fqa-13.4">reuse-oriented world</a> now? What about all those classes with stable interfaces
 you can&#39;t change? Seriously, it can happen with classes not available in source form.
</p>

<p>
I sincerely believe that the not-so-appetizing &quot;call the destructor, then call a constructor&quot; method is legal C++.
 If this is indeed so, I fail to understand the problem with mentioning it in the answer.
</p>

<p>
As to the problem of having destructors and close functions respect each other - one way around this is to <a href="fqa.html#fqa-10.5">avoid
non-trivial constructors</a> and destructors and always use init and close functions. Next, you can replace <a href="fqa.html#fqa-7.1">C++ classes</a>
 with their <a href="fqa.html#fqa-7.4">metaphysical "encapsulation"</a> with <a href="fqa.html#fqa-7.5">forward-declared</a> C <code>struct</code>s, which can actually yield stable binary interfaces
 and save recompilation. Next, you can replace C++ with C (where execution time matters) or with one of the many sane, safe
languages (where development time matters). There, doesn&#39;t it feel <a href="fqa.html#fqa-6.5">much better</a> now?
</p>


<a id="fqa-11.9"></a>
<h2>[11.9] But can I explicitly call a destructor if I&#39;ve allocated my object with <code>new</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.9">FAQ:</a></b> You can&#39;t, unless the object was allocated with placement <code>new</code>. Objects created by <code>new</code> must be <code>delete</code>d, which
 does two things (remember them): calls the destructor, then frees the memory.
</p>

<p>
<b class="FQA">FQA:</b> Translation: <code>delete</code> <i>is</i> a way to explictly call a destructor, but it <i>also</i> deallocates the memory. You can
also call a destructor without deallocating the memory. It&#39;s ugly and useless in most cases,
 but you can do that.
</p>

<p>
Questions like &quot;What <i>exactly</i> does <code>delete</code> do?&quot; probably cross the fine line separating between the questions everyone claiming to know
 C++ should be able to answer and the questions identifying people with too much C++-related garbage in their brains.
People can be quite productive by simply calling
 <code>new</code> and <code>delete</code> without thinking too much about the two steps involved, so not knowing about the two steps is probably no big deal.
 The most interesting thing about the two steps is that the idea of <a href="fqa.html#fqa-10.1">having the code using the class managing the memory
 of its objects</a> is the main reason C++ code is <a href="fqa.html#fqa-7.4">recompiled so frequently</a>.
</p>


<a id="fqa-11.10"></a>
<h2>[11.10] What is &quot;placement <code>new</code>&quot; and why would I use it?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.10">FAQ:</a></b> There are many uses for placement <code>new</code>. For example, you can allocate an object in a particular location,
 you can pass the pointer to this location to placement <code>new</code> like this: <code>C* p = new(place) C(args);</code>
</p>

<p>
Don&#39;t use this unless you really care where the object lives (say, you have a memory-mapped hardware device
 like a timer, and you want to have a <code>Timer</code> object at the particular location).
</p>

<p>
Beware! It is your job to make sure that the address where you allocate the object is properly aligned and that
you have enough space for the object. You are also responsible for calling the destructor with <code>p-&gt;~C();</code>.
</p>

<p>
<b class="FQA">FQA:</b> Size is relatively easy to deal with because we have <code>sizeof</code>, alignment can be more painful. Here&#39;s an advice:
if you care where your objects are allocated, don&#39;t make them objects of classes with constructors and destructors and stuff.
This way, you can create <a href="fqa.html#fqa-11.14">memory pools</a> with code like <code>C pool[N];</code>, which takes care of alignment <i>and</i> &quot;type safety&quot;.
But if the class <code>C</code> has a constructor, it&#39;s going to get called N times by this statement (slow and stupid), and if you want someone to use
placement <code>new</code> with the pool, you&#39;ll have to <i>call the destructors</i> after the constructors finish running
(slow, stupid and cryptic). Or you can use <code>char pool[N*sizeof(C)];</code> with platform-specific additions to handle
alignment, and then you won&#39;t be able to easily inspect the pool in a debugger (the object <code>pool</code> has the wrong type), etc.
</p>

<p>
And you have to be <i>out of your mind</i> to call placement <code>new</code> when you <a href="fqa.html#fqa-13.3">deal with memory-mapped hardware</a>.
Do you realize that the constructor is going to <i>directly modify the state of the hardware</i>?
Even if you get this right (yes, there are ways to get this wrong, too boring to enumerate here),
this is one very unmaintainable way to write this kind of code. If you think that&#39;s &quot;intuitive&quot;, think again.
What is the constructor doing - &quot;creating&quot; the timer? Come on, it&#39;s <i>hardware</i>, it was already physically there. Oh, it &quot;initializes&quot; it?
So why don&#39;t use a function with &quot;init&quot; in its name instead of a &quot;constructor&quot;?
</p>

<p>
You have enough trouble thinking about the semantics
of the hardware interface, so why would anyone want to add the complexity of C++ to the problem?
</p>

<p>
At least the FAQ has finally disclosed the <a href="fqa.html#fqa-11.5">top secret information</a> about explicitly calling destructors.
</p>


<a id="fqa-11.11"></a>
<h2>[11.11] When I write a destructor, do I need to explicitly call the destructors for my member objects?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.11">FAQ:</a></b> No, they are called implicitly in the reverse order of their declaration in the class.
</p>

<p>
<b class="FQA">FQA:</b> Pay attention to the details. If your member is a pointer
to something allocated with <code>new</code>, <i>the pointer&#39;s destructor</i>, which is a purely metaphysical entity doing nothing
                                                         physically observable,
is called, but it&#39;s <i>your</i> job to call <code>delete</code> on the pointer, which calls the destructor of the pointed object.
The pointed object is technically <i>not</i> a member of your class (the pointer is). The difference between
the intuitive feeling that &quot;it&#39;s part of the class&quot; and the formal definition of the term &quot;member&quot; is one reason making
<code>const</code> <a href="fqa.html#fqa-18.2">less than useful</a> (is changing the object pointed by a member &quot;changes&quot; the object itself or not?).
</p>

<p>
Experienced C++ programmers find this natural since the C++ approach to these issues is relatively uniform.
If you have the tough luck of using C++ a lot, this point is obvious
(but you wouldn&#39;t ask the question in the first place).
</p>

<p>
There&#39;s a nifty thing called <a href="fqa.html#fqa-16.1">"garbage collection"</a> that&#39;s been around for nearly half a century. The run time system
automatically figures out which objects are not pointed by anything and collects this garbage. Check it out, it&#39;s quite nice.
</p>


<a id="fqa-11.12"></a>
<h2>[11.12] When I write a derived class&#39;s destructor, do I need to explicitly call the destructor for my base class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.12">FAQ:</a></b> No, this is done implicitly, in the reverse order of the appearance of the classes in the inheritance list
 (but <code>virtual</code> inheritance complicates matters), and after the destruction of the class members.
</p>

<p>
<b class="FQA">FQA:</b> The FAQ says that if someone is <a href="fqa.html#fqa-11.3">relying</a> on more complicated details of the finalization order, you&#39;ll need information outside the scope
 of the FAQ. The remark probably refers to useful information like locations of mental institutions and drug prescriptions.
</p>

<p>
Seriously, a Usenet language FAQ is already a place normally visited only by language lawyers. If you need <i>more</i>
obscure information to get your job done, the only legitimate reason is that you&#39;re writing a C++ compiler.
 If that&#39;s the case, and you feel miserable, cheer up - it could be worse. For example, imagine the misery of the people who&#39;ll <i>use</i> your compiler!
</p>


<a id="fqa-11.13"></a>
<h2>[11.13] Should my destructor throw an exception when it detects a problem?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.13">FAQ:</a></b> THAT IS DANGEROUS! Which is discussed in <a href="fqa.html#fqa-17.3">a FAQ about exceptions</a>.
</p>

<p>
<b class="FQA">FQA:</b> It shouldn&#39;t. And you can&#39;t return an error code either. However, on many systems you can send an e-mail with the word
 &quot;BUMMER&quot; to your support e-mail address.
</p>

<p>
If you want your destructor to detect problems, make it a <code>close</code> function.
</p>


<a id="fqa-11.14"></a>
<h2>[11.14] Is there a way to force <code>new</code> to allocate memory from a specific memory area?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/dtors.html#faq-11.14">FAQ:</a></b> Oh, yessssss! Pools! Pools, pools, pools, pools, pools...
</p>

<p>
Please forgive me this time. I can&#39;t summarize what the FAQ is saying. It&#39;s almost as long as
 <i>all the previous answers</i>. And it&#39;s totally out of control. If you feel like it, fasten your seat belt,
 grab a barf bag, follow the link
 and knock yourself out.
</p>

<p>
<b class="FQA">FQA:</b> Oh, nooooooo! Don&#39;t do that!
</p>

<p>
I know that your system has more than one kind of memory and/or you have real time requirements and
 you can&#39;t use a traditional <code>malloc</code> implementation. But trust me, you&#39;re going to hate the day you&#39;ve
 heard about those pools. Pools have arbitrary size limits (at most 20 objects of this, at most 30 objects of that...).
 Everybody is going to have a paranoia attack and set the limits to huge values, and then you&#39;re out of memory,
 and then you start thinking about the &quot;right&quot; limits, and it turns out that it&#39;s extremely hard to figure that out,
 because seemingly independent modules have related memory requirements (say, they handle mutually exclusive situations
                                                                         so you&#39;d like them to use the same memory, but how?),
 and then you need some hairy logic to compute those values on a per-configuration basis, which means building several
 versions of the program, and maybe creating scripts for computing the values at build time, and you&#39;re going to <i>hate the day you&#39;ve
 heard about those pools</i>.
</p>

<p>
If you&#39;re absolutely sure you can&#39;t create a single allocator managing your memory, at least <i>don&#39;t allocate objects
of classes with constructors</i> from pools, <a href="fqa.html#fqa-11.10">use C-like structs instead</a>. If you refuse to give up and admit that you&#39;re
 doing a pretty low-level thing and instead want to keep pretending that you&#39;re <a href="fqa.html#fqa-8.6">"programming in the problem domain"</a>,
 and for some reason you think C++ classes help you with that - go ahead. The punishments for your crime are
                                                                         discussed throughout the FQA.
</p>

<a id="fqa-assign"></a><h1>Assignment operators</h1>
<p>
This section is about <code>operator=</code>. It&#39;s rather strange that of all possible things, people only &quot;frequently ask&quot; about self assignment, but those are the only questions listed in the FAQ.
</p>

<ul>
<li><a href="fqa.html#fqa-12.1">[12.1] What is &quot;self assignment&quot;?</a></li>
<li><a href="fqa.html#fqa-12.2">[12.2] Why should I worry about &quot;self assignment&quot;?</a></li>
<li><a href="fqa.html#fqa-12.3">[12.3] OK, OK, already; I&#39;ll handle self-assignment. How do I do it?</a></li>
</ul>

<a id="fqa-12.1"></a>
<h2>[12.1] What is &quot;self assignment&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/assignment-operators.html#faq-12.1">FAQ:</a></b> It&#39;s assigning the object to itself, directly or indirectly. For example:
</p>

<pre>
void f(C&amp; x, C&amp; y) { x=y; }
void g(C&amp; x) { f(x,x); }
</pre>

<p>
<b class="FQA">FQA:</b> The tricky part is that the assignment operator may be overloaded, and you are expected to overload it in the
classes that &quot;own&quot; resources (most frequently memory obtained with <code>new</code>). Incidentally, these are exactly
the cases when self assignment may lead to trouble, which is why we have the next question. Which will also show
that the FAQ&#39;s definition of &quot;self assignment&quot; is unfortunately too conservative, as &quot;self&quot; is a vague concept.
</p>


<a id="fqa-12.2"></a>
<h2>[12.2] Why should I worry about &quot;self assignment&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/assignment-operators.html#faq-12.2">FAQ:</a></b> If you don&#39;t, your <code>operator=</code> will probably misbehave severely upon self-assignment:
</p>

<pre>
YetAnotherSoCalledSmartPointer&amp; YetAnotherSoCalledSmartPointer::operator=(const YetAnotherSoCalledSmartPointer&amp; p)
{
  delete _p;
  _p = new TheThingPointedByTheSmartPointer(*p._p);
  return *this;
}
</pre>

<p>
Self assignment will first delete <code>_p</code>, and then dereference it, which is nasty. And it is all <i>your</i> fault - you
should have handled self assignment!
</p>

<p>
<b class="FQA">FQA:</b> Oh, so it&#39;s my fault, is it? Then why isn&#39;t this question listed in any other programming language FAQ on the planet?
I mean, it&#39;s the same me all the time, it&#39;s the languages that are different. So why don&#39;t we lose the feelings of guilt
and check what it is about C++ that causes the problem?
</p>

<p>
Most languages daring to call themselves &quot;object-oriented&quot; have garbage collection, so you don&#39;t spend your
time writing stupid functions for deallocating stuff, then copying stuff. These functions are all alike, but
with C++ you get to write this kind of code over and over again.
</p>

<p>
C++ doesn&#39;t have garbage collection, so a problem arises - if people are creating all those objects,
how are they going to dispose them, especially if they <a href="fqa.html#fqa-13.1">overload operators</a> and do things like <code>a+b+c</code>, without
even keeping the pointers to the temporary objects created when sub-expressions are evaluated? The C++ answer is to have an &quot;owner&quot; object for
each chunk of allocated memory, and let <code>operator=</code> and the destructor worry about freeing the memory.
The most common manifestation of this quite unique language design decision is <a href="fqa.html#fqa-16.1">unnecessary copying</a>,
which happens when objects are passed to functions or returned by value or &quot;cut out&quot; from larger
data structures.
</p>

<p>
The self assignment problem is another manifestation of this same thing. If objects were passed by pointers/references
and garbage-collected automatically, self assignment (setting the pointer to the value of itself) would be harmless.
And the worst part is that there are actually more cases of self assignment than <code>x=x</code>. For example, consider
<code>std::vector::push_back()</code>. What if someone passes an object from the vector itself, as in <code>v.push_back(v.back())</code>?
<code>push_back</code> may need to allocate more memory, which may cause it to free the buffer it already uses, destroying
its argument. <a href="fqa.html#fqa-18.2">Where</a> does the &quot;self&quot; of an object end?
</p>

<p>
You have to be really smart to get all those smart pointer and container classes right. Too bad it&#39;s still worse
than good containers <a href="fqa.html#fqa-6.2">built into a language</a>.
</p>


<a id="fqa-12.3"></a>
<h2>[12.3] OK, OK, already; I&#39;ll handle self-assignment. How do I do it?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/assignment-operators.html#faq-12.3">FAQ:</a></b> By adding a test like <code>if(this==&amp;that) { return *this; }</code> or by copying the members of the input object before deallocating members
of <code>this</code>.
</p>

<p>
<b class="FQA">FQA:</b> This avoids the destruction of your function argument via self-destruction in <code>operator=</code>.
However, there are <a href="fqa.html#fqa-12.2">other cases when that can happen</a> - consider <code>std::vector::push_back()</code>.
</p>

<p>
When performance is more important to you than simplicity &amp; generality, one way to deal with this family of
problems is to document them and pass them on to the user of your code
(&quot;it is illegal to push an element of a vector into that vector, if you need to do it, copy the element explicitly&quot;).
</p>

<p>
When simplicity &amp; generality are more important than performance, you can use a language automatically tracking
references to objects, guaranteeing that used objects won&#39;t get destroyed.
</p>

<a id="fqa-operator"></a><h1>Operator overloading</h1>
<p>
This section is about operator overloading - a way to make the code &quot;readable&quot; as long as the reader doesn&#39;t care what the code actually does.
</p>

<ul>
<li><a href="fqa.html#fqa-13.1">[13.1] What&#39;s the deal with <code>operator</code> overloading?</a></li>
<li><a href="fqa.html#fqa-13.2">[13.2] What are the benefits of operator overloading?</a></li>
<li><a href="fqa.html#fqa-13.3">[13.3] What are some examples of operator overloading?</a></li>
<li><a href="fqa.html#fqa-13.4">[13.4] But <code>operator</code> overloading makes my class look ugly; isn&#39;t it supposed to make my code clearer?</a></li>
<li><a href="fqa.html#fqa-13.5">[13.5] What operators can/cannot be overloaded?</a></li>
<li><a href="fqa.html#fqa-13.6">[13.6] Can I overload <code>operator==</code> so it lets me compare two <code>char[]</code> using a string comparison?</a></li>
<li><a href="fqa.html#fqa-13.7">[13.7] Can I create a <code>operator**</code> for &quot;to-the-power-of&quot; operations?</a></li>
<li><a href="fqa.html#fqa-13.8">[13.8] Okay, that tells me the operators I <i>can</i> override; which operators <i>should</i> I override?</a></li>
<li><a href="fqa.html#fqa-13.9">[13.9] What are some guidelines / &quot;rules of thumb&quot; for overloading operators?</a></li>
<li><a href="fqa.html#fqa-13.10">[13.10] How do I create a subscript <code>operator</code> for a <code>Matrix</code> class?</a></li>
<li><a href="fqa.html#fqa-13.11">[13.11] Why shouldn&#39;t my <code>Matrix</code> class&#39;s interface look like an array-of-array?</a></li>
<li><a href="fqa.html#fqa-13.12">[13.12] I still don&#39;t get it. Why shouldn&#39;t my <code>Matrix</code> class&#39;s interface look like an array-of-array?</a></li>
<li><a href="fqa.html#fqa-13.13">[13.13] Should I design my classes from the outside (interfaces first) or from the inside (data first)?</a></li>
<li><a href="fqa.html#fqa-13.14">[13.14] How can I overload the prefix and postfix forms of operators <code>++</code> and <code>--</code>?</a></li>
<li><a href="fqa.html#fqa-13.15">[13.15] Which is more efficient: <code>i++</code> or <code>++i</code>?</a></li>
</ul>

<a id="fqa-13.1"></a>
<h2>[13.1] What&#39;s the deal with <code>operator</code> overloading?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.1">FAQ:</a></b> Overloaded operators provide an &quot;intuitive interface&quot; for the users of your class. They also allow templates
to work &quot;equally well&quot; with classes and built-in types.
</p>

<p>
The idea is to call functions using the syntax of C++ operators. Such functions can be defined to accept
parameters of user-defined types, giving the operators user-defined meaning. For example:
</p>

<pre>
Matrix add(const Matrix&amp; x, const Matrix&amp; y);
Matrix operator+(const Matrix&amp; x, const Matrix&amp; y);
Matrix use_add(const Matrix&amp; a, const Matrix&amp; b, const Matrix&amp; c)
{
  return add(a,add(b,c));
}
Matrix use_plus(const Matrix&amp; a, const Matrix&amp; b, const Matrix&amp; c)
{
  return a + b + c;
}
</pre>

<p>
<b class="FQA">FQA:</b> Operator overloading provides strong source code encryption
(the time needed to figure out what <code>a+b</code> actually means is an exponential
 function of the number of types, implicit conversions, template specializations and overloaded operator versions involved).
</p>

<p>
It is also one way to have <a href="fqa.html#fqa-35.1">templates</a> malfunction equally miserably with user-defined and built-in types -
if <code>BraindeadPseudoTypeSafeIterator&lt;T&gt;</code> supports the syntax <code>*p</code> and <code>++p</code>, it can be used just like the built-in <code>T*</code> in a template &quot;algorithm&quot; like <code>std::for_each</code>.
However, it could also work without operator overloading - for example, you can have a global <code>increment</code> function
for all &quot;iterator&quot; types, and implement it for all pointer types using a global template wrapper calling <code>++p</code>.
Which means that operator overloading is pure syntactic sugar even if you don&#39;t consider templates a pile of toxic waste
you&#39;d rather live without.
</p>

<p>
This syntactic sugar can only be added to a language like C++ together with more than a grain of salt. For example,
what if <code>a+b</code> fails? There&#39;s no good way to return an error status, because the language is &quot;strongly typed&quot;,
so <code>a+b</code> always returns objects of the same type, for example, a <code>Matrix</code>. There&#39;s no natural &quot;bad matrix value&quot;, and anyway
the whole point of <code>a+b</code> is that you can also write <code>a+b+c</code>. If you need to test each addition with an <code>if</code> statement,
<code>a+b</code> is not much better than <code>add(a,b)</code>. What about throwing an <a href="fqa.html#fqa-17.1">exception</a> upon error? Not a bad idea, in a language
<i>supporting</i> exceptions, as opposed to merely providing non-local <code>goto</code> using <code>throw/try/catch</code> syntax and having <i>you</i>
care about &quot;exception safety&quot; in each and every bit of code.
</p>

<p>
What about the allocation of our result - where does that <code>Matrix</code> live? If it&#39;s allocated dynamically with <code>new</code> and returned by reference,
who is supposed to <a href="fqa.html#fqa-16.1">clean it up</a>, in particular, who keeps the list of all temporaries created by <code>a+b+c...</code>? But if it&#39;s
returned by value, then the copy constructor is going to copy lots of matrices. Bad if you <a href="fqa.html#fqa-10.9">care about performance</a>.
And if you don&#39;t,
you <i>surely</i> wouldn&#39;t mind the smaller run time overhead of <i>garbage collection</i> (not to mention run time boundary checking and other kinds of safety belt),
so you&#39;d probably choose a different language in the first place.
</p>

<p>
Operator overloading is not necessarily a bad idea - if you can actually keep the promise about &quot;readability&quot;.
To do that, you need at least three things: comprehensible overload resolution rules, easy-to-use exceptions
and easy-to-use automatic memory management. C++ offers none of those.
</p>


<a id="fqa-13.2"></a>
<h2>[13.2] What are the benefits of operator overloading?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.2">FAQ:</a></b> You can &quot;exploit the intuition&quot; of the users of your classes. Their code will speak in the language of the problem
instead of the language of the machine. They&#39;ll learn faster and make less errors.
</p>

<p>
<b class="FQA">FQA:</b> The keyword in the FAQ&#39;s answer is &quot;exploit&quot;. Your intuition tells you that <code>a+b</code> just works - and in the &quot;problem domain&quot;, you are right.
But in C++, it doesn&#39;t take the machine too long to <a href="fqa.html#fqa-23.5">raise its ugly iron head</a> and start talking to you in its
barbaric language, and it has all the means to make you listen.
</p>

<p>
If you want to program &quot;in the problem domain&quot;, use a language designed for that problem domain. Prototype numerical
algorithms in <a href="http://www.mathworks.com/products/matlab/">Matlab</a> or the like, not in C++ with some matrix library. Design hardware in <a href="http://www.verilog.com">Verilog</a> or the like, not <a href="http://www.systemc.org">SystemC</a> (which is C++ with some hardware description primitives library).
</p>

<p>
The next best alternative is to use a general-purpose language where operator overloading and other metaprogramming features <a href="fqa.html#fqa-13.1">actually work</a>.
It is typically worse, but may be cheaper - special-purpose tools are used by less people than general-purpose ones,
so the vendor must charge each user a higher price.
And it will make you happy if you&#39;re one of those people who think that there&#39;s nothing a special-purpose language
can do that can&#39;t be done equally well or better using the wonderful metaprogramming facilities of the awesome language X
(typically <i>wrong</i>, but strong programmers can be very productive operating under this assumption - unless X=C++).
</p>

<p>
Operator overloading and other features sure make C++ equally adaptable to any problem domain. This is achieved
by making it the wrong tool for every job.
</p>


<a id="fqa-13.3"></a>
<h2>[13.3] What are some examples of operator overloading?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.3">FAQ:</a></b> Here are a few (some real, some hypothetical), there are many more.
</p>

<ul>
<li> <code>str1 + str2</code> concatenates a couple of <code>std::string</code> objects. </li>
<li> <code>NapoleonsBirthday++</code> increments an object of class <code>Date</code>. </li>
<li> <code>a*b</code> multiplies two <code>Number</code>s. </li>
<li> <code>a[i]</code> accesses the i&#39;th element of a user-defined <code>Array</code> class object. </li>
<li> <code>x = *p</code> dereferences a &quot;smart pointer&quot; which actually represents an address of a disk record; the
dereferencing seeks to that location on the disk and fetches the record into <code>x</code>. </li>
</ul>

<p>
<b class="FQA">FQA:</b> C++ operator overloading is a bad way to implement all of these things. It&#39;s an equally bad way to implement almost
everything that comes to mind.
</p>

<ul>
<li> <i>Strings</i>: a general purpose high-level language should have a good <a href="fqa.html#fqa-6.2">built-in string type</a>, because text processing is a very common task.
In particular, a string is an extremely
common type of function parameter, so if you have no built-in string type, each kind of interface will use its own kind
of string, and the users will have to spend most of their time converting between string types.
Even <code>char*</code> and <code>std::string</code>, which are both <i>standard</i> string types (there are <i>lots and lots</i> of non-standard ones),
have interactions that operator overloading fails to hide. For example, <code>dir + &quot;/&quot; + file</code> compiles with <code>std::string dir</code>
and <code>char* file</code>, but fails to compile with <code>char* dir</code> and <code>std::string file</code>, <a href="fqa.html#fqa-13.2">"exploiting"</a> the intuition of users. </li>
<li> <i>Dates</i>: what does <code>date++</code> <i>mean</i>? Does it add a day or a minute or a second? This question is especially interesting
if someone had a severe <a href="fqa.html#fqa-15.1">modeling-the-universe-using-type-systems</a> attack and defined a <code>Time</code> class (incremented by seconds),
a <code>Date</code> class (incremented by days) and implicit conversions between them. And if you know that dates are incremented
in day intervals, so 1 means &quot;one day&quot;, why not just use <code>int</code> instead of <code>Date</code>? <a href="fqa.html#fqa-7.4">"Encapsulation"</a> - of what exactly? </li>
<li> <i>Numbers</i>: should be built into your language, or you should stop pretending that you&#39;re &quot;programming in the
problem domain&quot; (both approaches are perfectly legitimate). See the discussion about strings. </li>
<li> <i>Arrays</i>: should be built into the language, too. And if you use a tricky data structure because
resizable arrays built into your language are not good enough, making it look like an array is not necessarily a good idea. For
example, people might want to find the definition of the <code>operator[]</code> in <code>a[i]</code>. What should they do - search for &quot;[&quot;?
Oh, they are using an IDE that actually understands 75% of C++ syntax? Now what - select the opening bracket and ask
for its definition? Never worked for me. </li>
<li> <i>Smart pointers to disk records</i>: I wish all C++ weenies used an operating system which implements file systems
using this advanced technique. This way, whenever the &quot;dereferencing&quot; would fail, either the error wouldn&#39;t be reported, or an <a href="fqa.html#fqa-17.1">exception</a>
would be mishandled, and the weenies would lose their files, which would be good for everybody. </li>
</ul>

<p>
Basically most operator overloading use cases fall into one or more of the following categories:
</p>

<ul>
<li> the thing can&#39;t be implemented
well unless it&#39;s built into the language (arrays, strings, numbers, &quot;smart pointers&quot; doing things like reference counting)</li>
<li> the thing is tricky and shouldn&#39;t be confused with built-in types, so the interface should be different 
(&quot;smart pointers&quot; doing things like disk access, complicated data structures)</li>
<li> the thing is obscure and shouldn&#39;t be implemented at all
(incrementing dates by unclear amounts of time, <a href="fqa.html#fqa-15.2">transferring</a> output streams into hexadecimal mode without an option to restore the previous mode)</li>
</ul>

<p>
However, it doesn&#39;t mean that operator overloading is never useful - that is, in the languages that can actually <a href="fqa.html#fqa-13.1">support</a> it.
</p>


<a id="fqa-13.4"></a>
<h2>[13.4] But <code>operator</code> overloading makes my class look ugly; isn&#39;t it supposed to make my code clearer?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.4">FAQ:</a></b> No - it&#39;s supposed to make the code <i>using</i> your class clearer! For example, you may claim that <code>T&amp; operator[](int i)</code>
is less readable than <code>T&amp; getAt(int i)</code>, but surely <code>arr[i]</code> is more readable than <code>arr.getAt(i)</code>!
</p>

<p>
You should realize that &quot;in a reuse-oriented world&quot;, <i>usually</i> (yes, the FAQ says &quot;usually&quot;)
many people will use your class, but only one writes its code
(that one person is you). Think about the good of the majority - your users!
</p>

<p>
<b class="FQA">FQA:</b> Those guys living in the &quot;reuse-oriented&quot; worlds are very noble characters. Too bad we&#39;re stuck on planet Earth,
which didn&#39;t seem to have any particular &quot;orientation&quot; last time I checked. On this planet, most classes you write
are used exclusively by yourself, the majority of the rest is used by two or three people, and once in a while
you get to write a class to be used by N people for N&gt;3 - typically it&#39;s not an array class, but something with
<i>a little bit less trivial functionality</i>. Here on Earth, this is considered <i>good</i>: the more interaction
between people and components, the more errors there are likely to be (insert the FAQ&#39;s favorite pseudo-business-oriented statements about
&quot;defect rate&quot; here).
</p>

<p>
Of course this doesn&#39;t mean that <i>the other</i> claims make any sense. For example, users have to figure out
what your class does before they use it, so its interface must be <a href="fqa.html#fqa-10.18">defined in a readable way</a>, not just look
readable when used. And your users will probably need to understand your implementation, too, because even
when your code no longer has bugs (this might take a while), bugs in other pieces of code may end up corrupting <i>your</i> data
(this is C++), so people will have to <a href="fqa.html#fqa-7.2">inspect</a> what&#39;s left of that data in order to find the original error.
So an unreadable and/or complicated implementation is not a very good idea even in a &quot;reuse-oriented&quot; world.
</p>

<p>
Last but not least, <code>arr.getAt(i)</code> is <i>not that bad</i>.
</p>


<a id="fqa-13.5"></a>
<h2>[13.5] What operators can/cannot be overloaded?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.5">FAQ:</a></b> Most can be overloaded. You can&#39;t overload the C operators <code>.</code> and <code>?:</code> (and <code>sizeof</code>). And you can&#39;t overload the
C++ operators <code>::</code> and <code>.*</code>. You can overload everything else.
</p>

<p>
<b class="FQA">FQA:</b> There are other restrictions, for example there can&#39;t be a global <code>operator[]</code> overload - you can only overload
this operator using a class member function. Which is not necessarily bad.
</p>


<a id="fqa-13.6"></a>
<h2>[13.6] Can I overload <code>operator==</code> so it lets me compare two <code>char[]</code> using a string comparison?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.6">FAQ:</a></b> No, at least one parameter of an overloaded operator must be a user-defined type.
</p>

<p>
But even if you could do it, you shouldn&#39;t - you should use a class like <code>std::string</code>. Arrays are <a href="fqa.html#fqa-6.15">evil</a>!
</p>

<p>
<b class="FQA">FQA:</b> C++ doesn&#39;t let you do it for a good reason - if you could do it, how would you make sure that your
program is compiled consistently in the sense that your operator is called <i>everywhere</i> - in all contexts
calling <code>operator==</code> on <code>char[]</code> arguments? And what if two such operators are defined by two different modules?
</p>

<p>
Unfortunately, these problems are almost equally severe with user-defined types. For example, <code>std::map</code> doesn&#39;t have
an overloaded <code>operator&lt;&lt;</code> printing it to an <code>ostream</code>. You can define one, but <a href="fqa.html#fqa-15.10">so can I</a>, and then our libraries
are linked together into a single program. The result is unpredictable, ranging from a link-time error to
a program printing some maps using your code and some with mine.
</p>

<p>
As to the &quot;arrays are evil&quot; mantras - how about chanting them to the authors of the C++ standard library that defined
an <code>std::ifstream</code> constructor accepting <code>const char*</code>, but not <code>std::string</code>? And they didn&#39;t define an <code>operator const char*</code>
in <code>std::string</code>, either. <code>std::ifstream in((std::string(dir) + &quot;/&quot; + file).c_str());</code>. Give me a break.
</p>

<p>
And why does the FAQ say &quot;a <code>std::string</code>-like class&quot;, not just &quot;<code>std::string</code>&quot;? Because if it did, the majority
of the audience stuck with one (or more) of the many, many &quot;string-like&quot; classes developed before one was added to the C++
standard library would laugh quite bitterly.
</p>


<a id="fqa-13.7"></a>
<h2>[13.7] Can I create a <code>operator**</code> for &quot;to-the-power-of&quot; operations?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.7">FAQ:</a></b> You can&#39;t. You can only overload operators already in C++, without changing the number of arguments, the associativity
or the precedence. If you think it&#39;s wrong, consider the problem of <code>a**p</code>, which means &quot;a times the result of dereferencing p&quot;.
If you could define <code>operator**</code>, you&#39;d make such expressions ambiguous.
</p>

<p>
And you know what? Operator overloading is just syntactic sugar. You can always define a function instead. Why not
overload <code>pow</code>?
</p>

<p>
Or you could overload <code>operator^</code>, which works but has the wrong precedence and associativity.
</p>

<p>
<b class="FQA">FQA:</b> Sure, there&#39;s lots of grammar in C++, and making an unambiguous addition is
almost impossible. The fact is that, informally speaking, there&#39;s a finite amount of &quot;good&quot; syntax you can have in your language.
This is a valid argument if you advocate domain-specific languages (which can make the short, simple syntax map to stuff most useful in that domain),
or if you argue that &quot;languages should have no syntax&quot; (Lisp, Smalltalk and Forth are examples of languages with almost no syntax).
However, it&#39;s funny when this argument is used by the C++ FAQ. It is hardly compatible with the
<a href="fqa.html#fqa-13.2">claims that C++ is applicable everywhere</a>.
And then there&#39;s the <i>huge</i> amount of <i>completely pointless</i> complications in the C++ grammar
(like the constructor/function declaration <a href="fqa.html#fqa-10.19">puzzle</a>).
</p>

<p>
What&#39;s that? &quot;Operator overloading doesn&#39;t provide anything fundamental, it&#39;s just syntactic sugar&quot;? Now you&#39;re talking.
Make that &quot;syntactic cyanide&quot; and I&#39;m in.
</p>

<p>
Overload <code>pow</code>? Can somebody tell what&#39;s the <i>point</i> of all this overloading? If you want obfuscation, there are tools
you can use that allow you to keep the source in the unobfuscated form, which may be very handy at times. Besides,
isn&#39;t it <code>std::pow</code>? AFAIK you are not allowed to add names to the <code>std</code> namespace. And if you add a global function
pow, you&#39;ll lose the precious &quot;transparency&quot; (<code>std::pow(x,y)</code> will never call your version of <code>pow</code>, only <code>pow(x,y)</code> will),
so what&#39;s the point?
</p>

<p>
The idea to overload &quot;bitwise exclusive or&quot; to mean &quot;power&quot; is just stupid. I wonder where they get these ideas.
It&#39;s as if someone decided to overload &quot;bitwise left shift&quot; to mean &quot;print to file&quot;. Wait a minute - they did that,
too... Oh well.
</p>


<a id="fqa-13.8"></a>
<h2>[13.8] Okay, that tells me the operators I <i>can</i> override; which operators <i>should</i> I override?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.8">FAQ:</a></b> You want to help your users, not confuse them. Overload operators if it makes the life of your users easier.
</p>

<p>
<b class="FQA">FQA:</b> Translation: don&#39;t overload C++ operators. While we&#39;re at it, don&#39;t overload C++ functions, either. C++
overload resolution <i>always</i> ends up confusing users. And you can&#39;t add error handling without using the horrible
C++ <a href="fqa.html#fqa-17.1">exceptions</a>, and you can&#39;t <a href="fqa.html#fqa-16.1">allocate objects</a> simply and efficiently.
</p>


<a id="fqa-13.9"></a>
<h2>[13.9] What are some guidelines / &quot;rules of thumb&quot; for overloading operators?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.9">FAQ:</a></b> 22 (!!) &quot;rules of thumb&quot; are listed (actually 20, 2 just say &quot;use common sense&quot;). Basically, the rules are about
making overloaded operators behave similarly to built-in operators - if you define +, make it associative and
don&#39;t change the parameters, etc. The FAQ warns that the list is not exhaustive, nor should it be interpreted as
strict rules that can&#39;t have exceptions.
</p>

<p>
<b class="FQA">FQA:</b> Rule of thumb #23: things which have simple functionality but are very hard to get right <i>linguistically</i>
should be in the compiler.
</p>

<p>
Use common sense. Do you have the time for all that thinking when all you get is &quot;syntactic sugar&quot; of questionable taste?
How about implementing some <a href="fqa.html#fqa-7.2">user-visible functionality</a> instead? Not only is it what people (customers, employers, colleagues, friends)
ultimately care about, it&#39;s also much more fun.
</p>


<a id="fqa-13.10"></a>
<h2>[13.10] How do I create a subscript <code>operator</code> for a <code>Matrix</code> class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.10">FAQ:</a></b> Use <code>operator()</code> which can get two indexes, i and j. Don&#39;t use <code>operator[]</code>, which can only get one index.
A code listing follows.
</p>

<p>
<b class="FQA">FQA:</b> Oh, dear. You&#39;re writing a <code>Matrix</code> class. My condolences.
</p>

<p>
Once you define your subscript operator, be prepared to answer many more questions. How do you <a href="fqa.html#fqa-16.1">allocate</a> the result
of <code>operator+</code>? How do you map expressions like <code>A+B*C</code> to optimized implementations of several operations (for example, <code>multiply_add</code>)?
Why are you writing a <code>Matrix</code> class with overloaded operators instead of prototyping the code in Matlab or the like
and then implementing the prototype in C so that it runs fast and anybody can tell how and why from the code,
instead of figuring out how <code>A+B*C</code> actually works?
</p>


<a id="fqa-13.11"></a>
<h2>[13.11] Why shouldn&#39;t my <code>Matrix</code> class&#39;s interface look like an array-of-array?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.11">FAQ:</a></b> The &quot;array-of-array&quot; alternative uses <code>operator[]</code> to return an array object, which in turn has an <code>operator[]</code>
returning a single element.
</p>

<p>
This approach is likely to be worse because of performance issues having to do with the optimal layout of the
matrix in memory, says the FAQ. Or maybe it says something else similar to it. It talks a lot about the issue.
</p>

<p>
<b class="FQA">FQA:</b> You can&#39;t implement the array-of-array syntax with a single function call, because C++ has no <code>operator[][]</code>.
You need to return some temporary object with an <code>operator[]</code>.
</p>

<p>
This means extra work for you, because instead of writing a function you write a whole class and a function returning
its objects. This also means extra work for the user who has to read all these interfaces. This also means extra
work for the compiler. The chances of a compiler from planet Earth to optimize out the temporary objects are very close to zero.
Which means it&#39;s also extra work for the machine running your code.
</p>

<p>
And what did you achieve? &quot;Syntactic sugar&quot;. This reasoning can frequently be used to optimize the entire <code>Matrix</code> class
with all its overloaded operators out of your schedule. And it doesn&#39;t depend on performance-related claims about memory layout and stuff.
</p>


<a id="fqa-13.12"></a>
<h2>[13.12] I still don&#39;t get it. Why shouldn&#39;t my <code>Matrix</code> class&#39;s interface look like an array-of-array?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.12">FAQ:</a></b> Because it makes checking the arguments or changing the data structure harder. The FAQ then explains how this
can still be done, and claims that the compiler will optimize the temporaries out, but doesn&#39;t like the fact that
it&#39;s a lot of work.
</p>

<p>
<b class="FQA">FQA:</b> The FQA primarily doesn&#39;t like the fact that it&#39;s a lot of work. But it would also like to point out that:
1. The compiler will probably <i>not</i> optimize the temporaries out. 2. Key performance-critical data structures are
extremely <a href="fqa.html#fqa-16.17">costly</a> to change no matter how much &quot;encapsulation&quot; you use, because optimizations depend on the
representation. 3. Checking the arguments is <i>always</i>
hard with operator overloading, because what would <code>operator()</code> do once an error <i>was</i> found - return -1 (how?), set a global error flag, throw
a C++ exception? All these options are not really acceptable.
</p>

<p>
Anyway, if you want to waste some time without getting useful work done, there are ways to do it that are much more fun than getting <code>operator[][]</code>
sort of work. And this is where the FAQ and the FQA agree.
</p>


<a id="fqa-13.13"></a>
<h2>[13.13] Should I design my classes from the outside (interfaces first) or from the inside (data first)?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.13">FAQ:</a></b> Outside, of course.
</p>

<p>
A long discussion about the accessors one should have in a <code>LinkedList</code> class follows. A ground-breaking conclusion
is reached: you should give accessors to the elements of the list, but not the &quot;infrastructure&quot; (say, the pointer to the first node).
</p>

<p>
<b class="FQA">FQA:</b> <i>What?</i> What does this question have to do with operator overloading? And what does the kind of accessors you
want to have in your class (the final code) have to do with the way you design it (think before you code)?
</p>

<p>
There&#39;s no single good way to design classes or any kind of software. Sometimes the interfaces are the important
thing, sometimes the implementation, and sometimes both. Designing is a kind of thinking. Sometimes you need to think
about the data in order to figure out what kind of interfaces are ultimately possible to implement efficiently.
Sometimes you must figure out the interface first to make sure the whole thing is actually useful. Frequently you have to think
about both and possibly iteratively refine them.
</p>

<p>
The idea that implementations are not important (because you can always <a href="fqa.html#fqa-13.2">change</a> them or for other reasons)
may only emerge from implementing boringly trivial things, or from
doing nothing
(one way of doing nothing in the software industry is to obsessively seek the best way to spell the iteration over the elements of a list for a living).
</p>

<p>
By the way, the FAQ mentions &quot;a billion-line app&quot;. C++ doesn&#39;t scale to many lines of code in the sense that a large monolithic
C++ application (one where all code runs in a single address space) can hardly be maintainable. This claim
may be made about other languages as well, but the problem is especially severe with languages assuming <a href="fqa.html#fqa-6.5">unmanaged environments</a>,
where a buffer overflow in module A may silently corrupt the data of module B. If you have lots of unmanaged code,
breaking it into processes can save several tons of your bacon (of course you have to build the system from the beginning that way - retro-fitting it is extremely expensive).
</p>


<a id="fqa-13.14"></a>
<h2>[13.14] How can I overload the prefix and postfix forms of operators <code>++</code> and <code>--</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.14">FAQ:</a></b> Like this:
</p>

<pre>
Iter&amp; operator++ ();    // ++p
Iter  operator++ (int); // p++
</pre>

<p>
The postfix version should return something equivalent to the copy of <code>*this</code> made before the operator call.
</p>

<p>
<b class="FQA">FQA:</b> Silly syntax, isn&#39;t it? If you do overload operators, please read and follow all the boring rules about their
syntax and semantics. This will help you soften the blow on your users, or even fall asleep and forget about the
whole thing if we are lucky.
</p>


<a id="fqa-13.15"></a>
<h2>[13.15] Which is more efficient: <code>i++</code> or <code>++i</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html#faq-13.15">FAQ:</a></b> It&#39;s the same for built-in types. <code>++i</code> may be faster for user-defined types, because there&#39;s no need to create
a copy that the compiler may fail to optimize out. Most likely the overhead is small, but why not pick the habit of
using <code>++i</code>?
</p>

<p>
<b class="FQA">FQA:</b> Oh, suddenly the all-mighty compiler can&#39;t <a href="fqa.html#fqa-13.12">optimize out a temporary</a>!
I actually picked that habit at some point. That was before I picked the even more useful habit of avoiding overloaded C++ operators.
</p>

<p>
The <a href="fqa.html#fqa-13.10">really interesting questions</a> are about the performance of <code>A+B*C</code> compared to <code>D=B;D*=C;D+=A</code> compared to
an optimized <code>multiply_and_add_matrices(A,B,C)</code> function.
</p>

<a id="fqa-friend"></a><h1>Friends</h1>
<p>
The questions here are about <code>friend</code> declarations. A short answer to them all: you probably don&#39;t need <code>friend</code> declarations.
</p>

<ul>
<li><a href="fqa.html#fqa-14.1">[14.1] What is a <code>friend</code>?</a></li>
<li><a href="fqa.html#fqa-14.2">[14.2] Do friends violate encapsulation?</a></li>
<li><a href="fqa.html#fqa-14.3">[14.3] What are some advantages/disadvantages of using <code>friend</code> functions?</a></li>
<li><a href="fqa.html#fqa-14.4">[14.4] What does it mean that &quot;friendship isn&#39;t inherited, transitive, or reciprocal&quot;?</a></li>
<li><a href="fqa.html#fqa-14.5">[14.5] Should my class declare a member function or a <code>friend</code> function?</a></li>
</ul>

<a id="fqa-14.1"></a>
<h2>[14.1] What is a <code>friend</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/friends.html#faq-14.1">FAQ:</a></b> A class can declare other classes and/or functions as friends. The declaration allows the friends to
access non-<code>public</code> class members unaccessible to other code outside of the class.
</p>

<p>
<b class="FQA">FQA:</b> In other words, <code>friend</code> refines the access control provided by the <code>private</code> keyword.
Which means it&#39;s almost useless, simply because <code>private</code> is <a href="fqa.html#fqa-7.4">almost useless</a>. Specifically,
it fails to provide <i>encapsulation</i>, and therefore is little more than a <i>comment</i>.
</p>

<p>
If you define interfaces between modules developed independently and want these interfaces to be stable,
it&#39;s better to <a href="fqa.html#fqa-6.3">use C for the interface definitions</a>, not C++. If you insist on using C++ (forcing both modules to be built with the same tools),
relying on <code>private</code> to provide encapsulation is a bad idea, because changing private members triggers recompilation
of the client code. You can use <a href="fqa.html#fqa-7.5">forward declarations</a> and/or <a href="fqa.html#fqa-20.1">pure abstract classes</a> to
provide a more stable interface.
</p>

<p>
If you work on the internal interfaces between the different classes of a module, and you&#39;re stuck with C++,
using <code>private</code> is surely better than defining all members <code>public</code>. This way, someone can easily tell
that a member is not accessed outside of the class, and clarity is good. However, there is little reason
to obsess with the fine details of access control in the internal interfaces.
</p>

<p>
Most of the time, the distinction
between <code>private</code> and <code>public</code> is good enough to describe what you want. If you feel a strong urge to split
tightly coupled functions between several classes, you can do it with <code>friend</code>, or you can make the members
<code>public</code>. Of course it&#39;s possible to argue forever about this (&quot;But it&#39;s bad design to allow <i>everyone</i> to access the members!&quot;,
&quot;But it&#39;s bad design to have tightly coupled classes!&quot;). However, these are some of the internal classes of a module,
nothing more, nothing less.
If the module has reasonable size, the access control is not that big a deal. If the module is huge, you have a huge
problem either way, especially with C++, which compiles forever and doesn&#39;t localize the damage of run time errors.
</p>

<p>
Therefore, <code>friend</code> is totally useless for the external interfaces and almost useless for the internal interfaces.
So there you are.
</p>


<a id="fqa-14.2"></a>
<h2>[14.2] Do friends violate encapsulation?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/friends.html#faq-14.2">FAQ:</a></b> On the contrary - they enhance it. If used properly, of course.
</p>

<p>
For example, you can use them to split code into two classes and have their data inaccessible for code in all other classes.
Or you can use them as &quot;a syntactic variant&quot; of member functions.
</p>

<p>
Think of the friends as part of the class interface instead of something outside the class.
</p>

<p>
<b class="FQA">FQA:</b> What encapsulation? C++ doesn&#39;t have encapsulation. It has access control
(code outside of a class using <code>private</code> members of this class will not compile), but it has neither compile time encapsulation
(stable binary interfaces) nor run time encapsulation (safe memory access). What&#39;s there to violate?
</p>

<p>
The case of two classes was discussed in <a href="fqa.html#fqa-14.1">the previous FAQ</a>; this argument only sounds convincing if you think C++ classes
are a good way to define the important, stable interfaces in your system.
</p>

<p>
As to the &quot;syntactic variant&quot; business, it&#39;s probably about <a href="fqa.html#fqa-13.1">overloaded operators</a>. The C++ syntax makes it impossible
to define overloaded operators as class members unless the first argument is an object of the class. Since C++
uses <code>stream&lt;&lt;obj</code> to print things, many classes declare
a <code>friend operator&lt;&lt;</code>, for example. This argument is only interesting if you think C++ operator overloading is any good.
</p>


<a id="fqa-14.3"></a>
<h2>[14.3] What are some advantages/disadvantages of using <code>friend</code> functions?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/friends.html#faq-14.3">FAQ:</a></b> Advantage: they allow the designer to choose between <code>obj.func()</code> and <code>func(obj)</code>, which &quot;lowers maintenance costs&quot;.
</p>

<p>
Disadvantage: they require more code to achieve dynamic binding. Non-member functions can&#39;t be <code>virtual</code>, so if the
designer&#39;s syntax of choice is <code>func(obj)</code>, and dynamic binding is needed, <code>func</code> will have to delegate to a <code>protected virtual</code>
member with <code>obj.func()</code>.
</p>

<p>
<b class="FQA">FQA:</b> Listen carefully, this is an excellent opportunity to learn about the C++ approach to writing software.
Choosing between two equivalent syntactic forms is called &quot;design&quot;. The availability of many forms and the
&quot;right&quot; choice between them is expected to &quot;lower maintenance costs&quot;. Does this make any sense at all?
Have you seen headlines such as &quot;An engineer replaced <code>obj.func()</code> with <code>func(obj)</code>, profits sky-rocket&quot;
or &quot;A researcher wins the Turing award for discovering a new way to replace <code>obj.func()</code> with <code>func(obj)</code>&quot;?
</p>

<p>
And why not say out loud that the real choice is between <code>obj&lt;&lt;stream</code> and <code>stream&lt;&lt;obj</code> or something like this?
This is really about operator overloading, because that&#39;s where the member/global function distinction matters most
syntactically. Why not just say <code>obj.print(stream)</code> instead of shifting streams by the amount of bits in an object
or something?
</p>


<a id="fqa-14.4"></a>
<h2>[14.4] What does it mean that &quot;friendship isn&#39;t inherited, transitive, or reciprocal&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/friends.html#faq-14.4">FAQ:</a></b> It means that classes derived from a friend class don&#39;t automatically become friends (do <i>you</i> trust the kids of your friends?),
a friend of a friend doesn&#39;t automatically become a friend (do <i>you</i> trust the friends of your friends?), and that a class
declaring another class as &quot;friend&quot; doesn&#39;t automatically become a friend of that class (do <i>you</i> trust anyone who calls you a friend?).
</p>

<p>
<b class="FQA">FQA:</b> The real life analogies are too scary for a detailed discussion. &quot;Do <i>your</i> friends have access to your members&quot;?
</p>

<p>
One reason to avoid friends is that the only possible benefit is a little extra clarity, but this benefit can be
dwarfed by the extra obfuscation - not everyone is (or should be) 100% sure what <code>friend</code> means when it comes
to class hierarchies and stuff.
</p>


<a id="fqa-14.5"></a>
<h2>[14.5] Should my class declare a member function or a <code>friend</code> function?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/friends.html#faq-14.5">FAQ:</a></b> Use a member function unless you must use a <code>friend</code> function. For example, you may need <code>friend</code> for operator overloading.
</p>

<p>
<b class="FQA">FQA:</b> The FAQ says it at last! See? It was about operator overloading <a href="fqa.html#fqa-14.3">all the way</a>.
</p>

<p>
The FAQ&#39;s advice may be further simplified if we use the observation that C++ operator overloading is just a pain in the neck.
</p>

<a id="fqa-io"></a><h1>Input/output via &lt;iostream&gt; and &lt;cstdio&gt;</h1>
<p>
This section explains the benefits of <code>iostream</code> - a <i>&quot;type-safe&quot;</i> I/O library (which does not mean it will <i>save</i> keystrokes when you <i>type</i> some code).
</p>

<ul>
<li><a href="fqa.html#fqa-15.1">[15.1] Why should I use <code>&lt;iostream&gt;</code> instead of the traditional <code>&lt;cstdio&gt;</code>?</a></li>
<li><a href="fqa.html#fqa-15.2">[15.2] Why does my program go into an infinite loop when someone enters an invalid input character?</a></li>
<li><a href="fqa.html#fqa-15.3">[15.3] How can I get <code>std::cin</code> to skip invalid input characters?</a></li>
<li><a href="fqa.html#fqa-15.4">[15.4] How does that funky <code>while (std::cin &gt;&gt; foo)</code> syntax work?</a></li>
<li><a href="fqa.html#fqa-15.5">[15.5] Why does my input seem to process past the end of file?</a></li>
<li><a href="fqa.html#fqa-15.6">[15.6] Why is my program ignoring my input request after the first iteration?</a></li>
<li><a href="fqa.html#fqa-15.7">[15.7] Should I end my output lines with <code>std::endl</code> or <code>&#39;\n&#39;</code>?</a></li>
<li><a href="fqa.html#fqa-15.8">[15.8] How can I provide printing for my <code>class Fred</code>?</a></li>
<li><a href="fqa.html#fqa-15.9">[15.9] But shouldn&#39;t I always use a <code>printOn()</code> method rather than a <code>friend</code> function?</a></li>
<li><a href="fqa.html#fqa-15.10">[15.10] How can I provide input for my <code>class Fred</code>?</a></li>
<li><a href="fqa.html#fqa-15.11">[15.11] How can I provide printing for an entire hierarchy of classes?</a></li>
<li><a href="fqa.html#fqa-15.12">[15.12] How can I open a stream in binary mode?</a></li>
<li><a href="fqa.html#fqa-15.13">[15.13] How can I &quot;reopen&quot; <code>std::cin</code> and <code>std::cout</code> in binary mode?</a></li>
<li><a href="fqa.html#fqa-15.14">[15.14] How can I write/read objects of my class to/from a data file?</a></li>
<li><a href="fqa.html#fqa-15.15">[15.15] How can I send objects of my class to another computer (e.g., via a socket, TCP/IP, FTP, email, a wireless link, etc.)?</a></li>
<li><a href="fqa.html#fqa-15.16">[15.16] Why can&#39;t I open a file in a different directory such as <code>&quot;..\test.dat&quot;</code>?</a></li>
<li><a href="fqa.html#fqa-15.17">[15.17] How can I tell {if a key, which key} was pressed before the user presses the ENTER key?</a></li>
<li><a href="fqa.html#fqa-15.18">[15.18] How can I make it so keys pressed by users are not echoed on the screen?</a></li>
<li><a href="fqa.html#fqa-15.19">[15.19] How can I move the cursor around on the screen?</a></li>
<li><a href="fqa.html#fqa-15.20">[15.20] How can I clear the screen? Is there something like <code>clrscr()</code>?</a></li>
<li><a href="fqa.html#fqa-15.21">[15.21] How can I change the colors on the screen?</a></li>
</ul>

<a id="fqa-15.1"></a>
<h2>[15.1] Why should I use <code>&lt;iostream&gt;</code> instead of the traditional <code>&lt;cstdio&gt;</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.1">FAQ:</a></b> There are four reasons:
</p>

<ul>
<li> <i>Increase type safety</i>: with <code>iostream</code>, the compiler knows the types of the things you print. <code>stdio</code> only figures them out at
run time from the format string. </li>
<li> <i>Reduce the number of errors</i>: with <code>stdio</code>, the types of objects you pass must be consistent with the format string;
<code>iostream</code> removes this redundancy - there is no format string, so you can&#39;t make these errors. </li>
<li> <i>Printing objects of user-defined types</i>: with <code>iostream</code>, you can overload the operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> to support
new types, and the old code won&#39;t break. <code>stdio</code> won&#39;t let you extend the format string syntax, and there seems to be no way
to support this kind of thing in a way avoiding conflicts between different extensions. </li>
<li> <i>Printing to streams of user-defined types</i>: you can implement your own stream classes by deriving from the
base classes provided by <code>iostream</code>. <code>FILE*</code> can not be extended because &quot;it&#39;s not a real class&quot;. </li>
</ul>

<p>
<b class="FQA">FQA:</b> Why should I do this, why should I do that, you ask. What kind of manners are these? Do what you are told. Assignment Number 1 - convert all your evil
<code>printf(&quot;%08x\n&quot;, x)</code> statements to this:
</p>

<pre>
std::cout &lt;&lt; std::hex &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; std::setw(8) &lt;&lt; x &lt;&lt; std::dec &lt;&lt; std::endl; 
</pre>

<p>
Even if you commit the environmental crime of namespace pollution, adding a <code>using namespace std</code>
and removing those pesky <code>std::</code>, the verbosity is still amazing. This achievement is not accidental.
It follows from one of the basic flaws in the C++ way of thinking:
the &quot;everything is a type&quot; axiom. For example, <code>hex</code> has a special type which hexes streams, and so does every
other strange object sent to <code>cout</code>.
</p>

<p>
The FAQ explains why this thinking is good for you. Here&#39;s why the FAQ is wrong:
</p>

<ul>
<li> Why is <i>type safety</i> a good thing here - because we gain performance? The last time I checked, we didn&#39;t really gain
any - your typical iostream implementation is slower and bulkier than your typical stdio implementation. Anyway, isn&#39;t I/O
the bottleneck here? </li>
<li> Oh, now I get it - type safety is supposed to help the compiler <i>catch errors</i>. This is very important for people
who never actually look at what they print. The needs of this population surely justify the 700K of crud that <code>gcc</code> gets
to parse when compiling a C++ &quot;Hello, world&quot; problem, as well as my time spent waiting for it to compile. What&#39;s easier
to fix: a run-time printf problem or a compile-time iostream problem (with the compiler helpfully listing hundreds of <a href="fqa.html#fqa-13.1">overloaded</a> left shift operators)? </li>
<li> Maybe &quot;everything is a type&quot; is a good thing because it lets you <i>print objects of user-defined types</i>. If you
believe this, concentrate for 10 seconds - this is your chance to achieve enlightenment. <b> What on Earth prevents
you from printing user-defined objects with printf? </b> You write a helper function which gets a pointer to your
object and prints it. While you&#39;re at it, give the function some special name, so that you don&#39;t have to shovel through lists of overloads
anymore. What&#39;s that? It&#39;s verbose, because function calls are separate statements, unlike the funky left shift operators?
Well, look at a simple statement printing an integer above if you care about verbosity. </li>
<li> What about <i>printing to streams of user-defined types</i>? Well, this claim is valid in the sense that there&#39;s no way to define custom
<code>FILE*</code>, but it has nothing to do with the fact that &quot;it&#39;s not a real class&quot;. A &quot;real class&quot; is not a very well-defined
term; to me, C++ classes look <a href="fqa.html#fqa-7.1">pretty surreal</a> compared to classes defined in almost any other language I&#39;ve ever seen. Anyway,
stdio could provide ways to define custom <code>FILE*</code>, for instance by providing <code>read</code>, <code>write</code> and other callbacks.
The authors just didn&#39;t bother. The ability to define custom streams does not justify the problems
of iostream, nor is it a feature unique to iostream. This ability is achieved in (relatively) sane OO ways, (almost) in the way it&#39;s done
in many languages saner than C++ and I/O libraries saner than iostream. </li>
</ul>

<p>
<code>iostream</code>. The only thing you&#39;ll gain from all this extra typing is extra long build cycles and error messages and extra large
program image. This is what you get when you shift a file object by an integer.
</p>


<a id="fqa-15.2"></a>
<h2>[15.2] Why does my program go into an infinite loop when someone enters an invalid input character?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.2">FAQ:</a></b> Probably you did something like <code>int i; std::cin &gt;&gt; i;</code> without checking for an error.
From now on, all attempts to read stuff from <code>std::cin</code> won&#39;t actually read anything, because the stream has entered
an erroneous state. Presumably, you wrote a program that will still keep trying. Use something like <code>while(std::cin &gt;&gt; i)</code>
instead.
</p>

<p>
<b class="FQA">FQA:</b> Yep, that&#39;s iostream&#39;s way to handle input errors. For some reason, it doesn&#39;t throw an <a href="fqa.html#fqa-17.1">exception</a> (it&#39;s not really
bad, because what&#39;s really bad is C++ exceptions). But it doesn&#39;t return an error code, either, because the overloaded operator
<a href="fqa.html#fqa-13.1">has to return its first argument</a> for the &quot;neat&quot; operator call chaining to work. So it has to set an error bit - the
dreaded <a href="fqa.html#fqa-17.2">"zombie object"</a> pattern the FAQ condemns so convincingly.
</p>

<p>
You can then check for errors using <code>if(std::cin)</code> or the like because the object has overloaded <code>operator void*</code>,
and <code>void*</code> is convertible to <code>bool</code>. You
can also check for end-of-file conditions this way. Actually you can check for error-or-end-of-file conditions. The more
operator calls you chain, the less details about the error context are left. Simple, safe, efficient and elegant.
</p>

<p>
Oh, and iostream has other state bits. For example, <code>std::hex</code> transfers it to hex mode. People frequently forget
to undo the effect, which is especially entertaining when they print numbers like <code>10</code>, which is as good a decimal
ten as it is a hexadecimal sixteen. Well, if you found the bug (which for some reason went undetected by the type-safe almighty paranoid C++ compiler),
you can use <code>std::dec</code> to get the stream back to decimal mode. Um, actually, it transfers it to decimal mode, which is not necessarily &quot;back&quot;, because
we don&#39;t know which mode it was in before it was hexed. This gets interesting when people print numbers and user-defined
objects in the same statement, and count on their hexing to maintain its effect after the user-defined object is printed.
</p>


<a id="fqa-15.3"></a>
<h2>[15.3] How can I get <code>std::cin</code> to skip invalid input characters?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.3">FAQ:</a></b> Here&#39;s an example:
</p>

<pre>
   while ((std::cout &lt;&lt; &quot;Give me your credit card number now!!&quot;) &amp;&amp; !(std::cin &gt;&gt; n)) {
     std::cout &lt;&lt; &quot;Don&#39;t mess with me, I&#39;m written in C++!!!&quot;;
     std::cin.clear();
     std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
   }
</pre>

<p>
<b class="FQA">FQA:</b> Oops, you forgot to test for end of file. If a brave user hits <code>Ctrl-D</code> or whatever it takes to close the standard input
with the given terminal, your program will enter an infinite loop. Overloaded operators and error handling are not
very compatible.
</p>

<p>
<code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);</code> speaks for itself. You just can&#39;t invent it if
your &quot;use case&quot; is yourself getting any work done.
</p>


<a id="fqa-15.4"></a>
<h2>[15.4] How does that funky <code>while (std::cin &gt;&gt; foo)</code> syntax work?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.4">FAQ:</a></b> <code>istream</code> has overloaded <code>operator void*</code>. The compiler calls this operator in boolean contexts (when it expects a condition, for example),
because <code>void*</code> can be converted to a boolean. The operator returns <code>NULL</code> when there&#39;s nothing left to read, or
when a format error occurred previously.
</p>

<p>
<b class="FQA">FQA:</b> There&#39;s nothing &quot;funky&quot; about it.
It is ugly and boring. It&#39;s also scary because many people think this is what programming is all about - using complicated
syntax to do simple things without even getting them right (how do you tell end-of-file conditions from format errors?).
</p>

<p>
Why is it <code>operator void*</code>, and not <code>operator bool</code>? Apparently because the compiler implicitly converts booleans to numbers
in &quot;numeric contexts&quot; (such as <code>file1+file2</code>), and we don&#39;t want that to compile, do we?
</p>

<p>
But wait, there&#39;s more! There&#39;s an actual book out there, called &quot;Imperfect C++&quot;, arguing that <code>operator void*</code> is not
 the way to go, either. Because this way, <code>delete file</code> would compile. Surely we don&#39;t want it to, do we? I mean,
 the fact that the statement is completely <i>moronic</i> shouldn&#39;t matter. Morones have a right to get an equal opportunity
 in the exciting world of C++ programming; let&#39;s catch of all their errors at compile time. Evil people spread
 rumors about the problem being undecidable, but we should keep trying.
</p>


<a id="fqa-15.5"></a>
<h2>[15.5] Why does my input seem to process past the end of file?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.5">FAQ:</a></b> Because the stream doesn&#39;t know that you&#39;ve reached the end of file until you actually try to read past the end of file.
For instance, a stream object may read characters which are entered interactively using a keyboard. So it&#39;s impossible
to tell when it&#39;s over.
</p>

<p>
<b class="FQA">FQA:</b> That&#39;s right, and has nothing to do with iostream - except the fact that iostream handles I/O errors in the silly
way discussed <a href="fqa.html#fqa-15.4">above</a>.
</p>


<a id="fqa-15.6"></a>
<h2>[15.6] Why is my program ignoring my input request after the first iteration?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.6">FAQ:</a></b> Because non-digits are left in the input buffer. You can ignore them using calls like <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);</code>
</p>

<p>
<b class="FQA">FQA:</b> Doesn&#39;t the fact that there are <a href="fqa.html#fqa-15.2">so</a> <a href="fqa.html#fqa-15.3">many</a> questions about the handling of input format problems ring a bell?
This silent treatment of errors is wrong. Stuff like parsing is better handled by languages which have good support
for <a href="fqa.html#fqa-17.1">exceptions</a> (<a href="fqa.html#fqa-6.2">built-in strings and containers</a> help, too). If you have to live without exceptions, at least the library
should treat errors reasonably. The iostream interface of operator call chains makes error handling as awkward as it gets.
</p>


<a id="fqa-15.7"></a>
<h2>[15.7] Should I end my output lines with <code>std::endl</code> or <code>&#39;\n&#39;</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.7">FAQ:</a></b> The former has the additional side-effect of flushing the output buffer. Therefore, the latter will probably work
faster.
</p>

<p>
<b class="FQA">FQA:</b> The latter is also shorter, unless you have a <code>using namespace std</code>. Many people probably ask this question because
they think that <code>endl</code> will end the line the way it&#39;s normally done at a given platform (say, emit CRLF on Windows and LF
on Unix). When <code>endl</code> behaves that way, so does <code>&#39;\n&#39;</code>. You can <a href="fqa.html#fqa-15.12">suppress this behavior</a> when you open the file
(pass <code>ios::binary</code> with iostream or the <code>&quot;b&quot;</code> flag with <code>fopen</code>).
</p>


<a id="fqa-15.8"></a>
<h2>[15.8] How can I provide printing for my <code>class Fred</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.8">FAQ:</a></b> By adding a <code>friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Fred&amp; fred);</code>. The operator <a href="fqa.html#fqa-14.2">can't be a member
of the class</a>, because we need the object to be the second argument, not the first one.
</p>

<p>
<b class="FQA">FQA:</b> Yeah, yeah, C++ and its stupid syntax. Let&#39;s forget about it for a moment: the real problem here is semantical, and it
starts at the question &quot;How can I provide printing <i>for my class</i>?&quot;. The formulation encourages to give an answer
in the spirit of <a href="fqa.html#fqa-15.1">"everything is a type"</a>, and indeed this is the kind of answer given by the FAQ. Here&#39;s <i>the</i> way
to print <i>all</i> objects of your class.
</p>

<p>
But was that really your question? What if you want more than a single output format for your class?
For instance, you might want a textual format for people and a binary format for machines. Or there could be
several textual formats - even integers can be printed using different bases. Do you really want to develop
and maintain the layers of syntax needed to make things like <code>hex</code> and <code>dec</code> sort of work? Why not just define
named functions for printing?
</p>

<p>
The <code>friend</code> thing is also questionable. With all due respect, you might want to print to several different
output channels, <i>without</i> creating an adapter class derived from <code>ostream</code>. One simple reason for such
heretical behavior is performance - <code>ostream</code> may be too slow for things like real-time logging. Why not create accessors to the data you want to print, so that all
the different output methods won&#39;t need to be part of your class, which may then have a stable interface? <a href="fqa.html#fqa-7.4">Encapsulation</a>? You&#39;ve already made
your data public - one can read it by printing to a <code>stringstream</code>. Providing accessors violates <a href="fqa.html#fqa-7.7">obfuscation</a>,
not encapsulation.
</p>

<p>
If you abandon the <code>friend</code> part and the <code>operator</code> part, the remaining part of the FAQ&#39;s answer - create
a global function accepting some kind of stream object and an object of your class and do the printing there -
makes a good advice. In particular, it may be better than a method for the same reasons making it better than
a friend (however, unlike a friend, a method may be polymorphic, which might be useful).
</p>


<a id="fqa-15.9"></a>
<h2>[15.9] But shouldn&#39;t I always use a <code>printOn()</code> method rather than a <code>friend</code> function?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.9">FAQ:</a></b> Not &quot;always&quot;. A method may be useful for a class hierarchy, for example, but in that case it would
normally be protected, not public.
</p>

<p>
Some people think <code>friend</code> violates encapsulation, and therefore
prefer to have their <code>operator&lt;&lt;</code> call a public method of the class, even though there&#39;s no class hierarchy. Their basic assumption is wrong,
so they end up writing extra code that doesn&#39;t solve any real problems and confuses people.
</p>

<p>
<b class="FQA">FQA:</b> Just to make things clear: a <code>printOn()</code> method is something like <code>void Fred::printOn(std::ostream&amp; o) const</code>.
</p>

<p>
The FAQ is right about the important thing: creating extra layers of code doing nothing but delegating
work to other layers of code is a pesky habit. Many people feel that &quot;good design&quot; means &quot;lots of code&quot;
or &quot;lots of layers&quot;. Actually, those are some of the meanings of &quot;bad design&quot;.
</p>

<p>
The fact that <code>friend</code> is really needed here to compensate for syntactical limitations of C++,
as well as the problems with the whole <code>friend operator</code> approach, are discussed in <a href="fqa.html#fqa-15.8">the previous FAQ</a>. They are not
the main theme here. The main theme here is the message to the &quot;designers&quot;: listen to the voice
of C++ overlords who originally inspired you to create N layers with 0 functionality, and stop.
</p>


<a id="fqa-15.10"></a>
<h2>[15.10] How can I provide input for my <code>class Fred</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.10">FAQ:</a></b> By adding a <code>friend std::istream&amp; operator&gt;&gt; (std::istream&amp; i, Fred&amp; fred);</code>
</p>

<p>
<b class="FQA">FQA:</b> This defective technique is symmetrical to the <code>operator&lt;&lt;</code> thing, which was discussed above.
We&#39;ll use this opportunity to look at some advanced defects of this approach. For beginner&#39;s defects, go
<a href="fqa.html#fqa-15.8">two FAQs back</a>.
</p>

<p>
The complicated problems come from the same source as the simple problems: the idea that for each type,
we want exactly one output function looking like a bit shift operator. Therefore, to create complicated problems,
we&#39;ll need some complicated types. Luckily, C++ comes with one of the most complicated type systems in the solar system
(itself an example of a simpler system).
</p>

<p>
Consider <code>std::map</code>. It&#39;s standard, and so is iostream. Does this mean that the operators reading and writing
them are also standard? I think you know <a href="fqa.html#fqa-13.6">the answer</a>. But no matter: you can create a template operator
printing all kinds of <code>map</code>. So can I. We&#39;re both happy, unless we have to integrate our code into a single program some
time later. We both used the same intuitive name - <code>operator&lt;&lt;</code> - for our printing functions. Normally we&#39;d rename one of the two,
but in this special case, this is <i>really</i> going to be ugly - for instance, other templates will break because they
think everything can be printed with <code>&lt;&lt;</code>, and even if there aren&#39;t any, <code>printMap(std::cout &lt;&lt; &quot;map: &quot;, myMap) &lt;&lt; std::endl</code>
is too ugly even for seasoned C++ developers, who do have pretty low standards.
</p>

<p>
The real fun starts when two people overload (or specialize or whatever they call it) the operators for <i>special
cases of types</i> in conflicting ways. For instance, I know how to print <code>std::map&lt;std::string,T&gt;</code>, and you know how to print <code>std::map&lt;T,int&gt;</code>.
The question is, who gets to print <code>std::map&lt;std::string,int&gt;</code>? The compiler is in trouble, and when a C++ compiler
is in trouble, it immediately empties its bowel, dumping a nice, large, stinky error message right at our faces.
Happy, happy, joy, joy, dear colleague.
</p>


<a id="fqa-15.11"></a>
<h2>[15.11] How can I provide printing for an entire hierarchy of classes?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.11">FAQ:</a></b> You can create a <code>protected virtual</code> method that each class will override to do the printing, and call it from
a <code>friend operator&lt;&lt;</code>.
</p>

<p>
<b class="FQA">FQA:</b> Fantastic, except for the <code>protected</code> and the <code>friend operator&lt;&lt;</code> part. Of course you can use a plain <code>public virtual</code>
method instead.
</p>


<a id="fqa-15.12"></a>
<h2>[15.12] How can I open a stream in binary mode?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.12">FAQ:</a></b> Open the stream with the <code>std::ios::binary</code> flag. That way, the stream will not translate between <code>&#39;\n&#39;</code> and
the target platform representation of line termination, which may be different (for instance, Windows uses CRLF).
</p>

<p>
<b class="FQA">FQA:</b> With <code>fopen</code>, pass the <code>&quot;b&quot;</code> character in the options string. This whole issue is pretty annoying, especially
if you work with binary files on a system where <code>&#39;\n&#39;</code> is not actually translated, and forget to open them as binary,
and everything works, and then you port the program to
a system where <code>&#39;\n&#39;</code> actually is translated, and then you have to find all those cases and open the files as binary. However, this is
not the fault of C++. It is the fault of the distributed nature of the human race, which fails to standardize the
simplest things.
</p>

<p>
Many programs may screw up your binary files due to this family of issues, for instance, many FTP clients will do so unless
explicitly told otherwise.
</p>


<a id="fqa-15.13"></a>
<h2>[15.13] How can I &quot;reopen&quot; <code>std::cin</code> and <code>std::cout</code> in binary mode?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.13">FAQ:</a></b> There&#39;s no portable way to do it.
</p>

<p>
<b class="FQA">FQA:</b> That&#39;s probably the fault of all those different incompatible systems rather than C++ or any other programming language.
</p>


<a id="fqa-15.14"></a>
<h2>[15.14] How can I write/read objects of my class to/from a data file?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.14">FAQ:</a></b> Read the section about serialization.
</p>

<p>
<b class="FQA">FQA:</b> The FQA doesn&#39;t have a section about a serialization. Short summary: you&#39;re in for a rude awakening. There&#39;s no
standard serialization mechanism in C++. Furthermore, there&#39;s no way to define a reasonable custom one since
there&#39;s no reflection (no way to figure out the structure of an arbitrary object given a pointer to it,
no way to create an object of a class given its name or some other sort of ID, etc.).
</p>

<p>
However, there are many custom
packages for serialization (typically thousands of source code lines, requiring you to use hairy macros/templates for each serialized class member).
Or you can roll your own, or you can dump the whole snapshot of your process to a file in non-portable ways
(may be the cheapest thing to do more frequently than it sounds).
</p>


<a id="fqa-15.15"></a>
<h2>[15.15] How can I send objects of my class to another computer (e.g., via a socket, TCP/IP, FTP, email, a wireless link, etc.)?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.15">FAQ:</a></b> Read the section about serialization.
</p>

<p>
<b class="FQA">FQA:</b> <a href="fqa.html#fqa-15.14">Keep your expectations low</a>.
</p>


<a id="fqa-15.16"></a>
<h2>[15.16] Why can&#39;t I open a file in a different directory such as <code>&quot;..\test.dat&quot;</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.16">FAQ:</a></b> Because <code>\t</code> expands to the tab character. Use <code>\\t</code> to say &quot;backslash followed by t&quot;.
</p>

<p>
<b class="FQA">FQA:</b> You have to escape certain things somehow, so this is perfectly legitimate - unlike the fact that the C++ standard library has no way to <i>open a directory</i>, for example.
</p>


<a id="fqa-15.17"></a>
<h2>[15.17] How can I tell {if a key, which key} was pressed before the user presses the ENTER key?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.17">FAQ:</a></b> The C++ standard doesn&#39;t even assume your system has a keyboard. So there&#39;s no portable way.
</p>

<p>
<b class="FQA">FQA:</b> Good for the C++ standard, but is there a reason not to provide a standard interface for systems which do have a keyboard?
</p>


<a id="fqa-15.18"></a>
<h2>[15.18] How can I make it so keys pressed by users are not echoed on the screen?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.18">FAQ:</a></b> You can&#39;t. See <a href="fqa.html#fqa-15.17">above</a>.
</p>

<p>
<b class="FQA">FQA:</b> Yep, some systems don&#39;t have screens - we sure shouldn&#39;t support the ones that do.
</p>

<p>
Interestingly, the C++ standard assumes that your system has persistent files, and has separate output and error streams. Even more interestingly,
it assumes that you might need Unicode output and locales. You&#39;d be surprised to find out some of the strange places
where devices carrying dead code supporting these features live.
</p>


<a id="fqa-15.19"></a>
<h2>[15.19] How can I move the cursor around on the screen?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.19">FAQ:</a></b> Using whichever way that works on your system. It&#39;s not related to the C++ standard.
</p>

<p>
<b class="FQA">FQA:</b> You should have spotted a <a href="fqa.html#fqa-15.17">trend</a> by now.
</p>


<a id="fqa-15.20"></a>
<h2>[15.20] How can I clear the screen? Is there something like <code>clrscr()</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.20">FAQ:</a></b> There is, but not in the C++ standard. It&#39;s system-specific.
</p>

<p>
<b class="FQA">FQA:</b> So are windows, sockets and regular expressions. You see, the C++ standard <a href="fqa.html#fqa-15.18">doesn't assume you have a screen</a>, a network
controller or hardware for regular expression matching.
</p>

<p>
The lame standard library is another one of those things making using C++ a joy.
</p>


<a id="fqa-15.21"></a>
<h2>[15.21] How can I change the colors on the screen?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/input-output.html#faq-15.21">FAQ:</a></b> Depends on your system. The C++ standard doesn&#39;t refer to this.
</p>

<p>
<b class="FQA">FQA:</b> But there&#39;s <a href="http://en.wikipedia.org/wiki/ANSI_escape_code">an ANSI standard</a> that does. There are some ugly character sequences you can send to
<code>cout</code>/<code>stdout</code>; you don&#39;t need to call any special functions. Many terminals support this.
</p>

<a id="fqa-heap"></a><h1>Freestore management</h1>
<p>
This page is about one of the most hard, boring and dangerous things C++ forces you to do manually - killing your objects at the right time. One dirty job, that.
</p>

<ul>
<li><a href="fqa.html#fqa-16.1">[16.1] Does <code>delete p</code> delete the pointer <code>p</code>, or the pointed-to-data <code>*p</code>?</a></li>
<li><a href="fqa.html#fqa-16.2">[16.2] Is it safe to <code>delete</code> the same pointer twice?</a></li>
<li><a href="fqa.html#fqa-16.3">[16.3] Can I <code>free()</code> pointers allocated with <code>new</code>? Can I <code>delete</code> pointers allocated with <code>malloc()</code>?</a></li>
<li><a href="fqa.html#fqa-16.4">[16.4] Why should I use <code>new</code> instead of trustworthy old <code>malloc()</code>?</a></li>
<li><a href="fqa.html#fqa-16.5">[16.5] Can I use <code>realloc()</code> on pointers allocated via <code>new</code>?</a></li>
<li><a href="fqa.html#fqa-16.6">[16.6] Do I need to check for <code>NULL</code> after <code>p = new Fred()</code>?</a></li>
<li><a href="fqa.html#fqa-16.7">[16.7] How can I convince my (older) compiler to automatically check <code>new</code> to see if it returns <code>NULL</code>?</a></li>
<li><a href="fqa.html#fqa-16.8">[16.8] Do I need to check for <code>NULL</code> before <code>delete p</code>?</a></li>
<li><a href="fqa.html#fqa-16.9">[16.9] What are the two steps that happen when I say <code>delete p</code>?</a></li>
<li><a href="fqa.html#fqa-16.10">[16.10] In <code>p = new Fred()</code>, does the <code>Fred</code> memory &quot;leak&quot; if the <code>Fred</code> constructor throws an exception?</a></li>
<li><a href="fqa.html#fqa-16.11">[16.11] How do I allocate / unallocate an array of things?</a></li>
<li><a href="fqa.html#fqa-16.12">[16.12] What if I forget the <code>[]</code> when deleting array allocated via <code>new T[n]</code>?</a></li>
<li><a href="fqa.html#fqa-16.13">[16.13] Can I drop the <code>[]</code> when deleting array of some built-in type (<code>char</code>, <code>int</code>, etc)?</a></li>
<li><a href="fqa.html#fqa-16.14">[16.14] After <code>p = new Fred[n]</code>, how does the compiler know there are <code>n</code> objects to be destructed during <code>delete[] p</code>?</a></li>
<li><a href="fqa.html#fqa-16.15">[16.15] Is it legal (and moral) for a member function to say <code>delete this</code>?</a></li>
<li><a href="fqa.html#fqa-16.16">[16.16] How do I allocate multidimensional arrays using <code>new</code>?</a></li>
<li><a href="fqa.html#fqa-16.17">[16.17] But the previous FAQ&#39;s code is SOOOO tricky and error prone! Isn&#39;t there a simpler way?</a></li>
<li><a href="fqa.html#fqa-16.18">[16.18] But the above <code>Matrix</code> class is specific to <code>Fred</code>! Isn&#39;t there a way to make it generic?</a></li>
<li><a href="fqa.html#fqa-16.19">[16.19] What&#39;s another way to build a <code>Matrix</code> template?</a></li>
<li><a href="fqa.html#fqa-16.20">[16.20] Does C++ have arrays whose length can be specified at run-time?</a></li>
<li><a href="fqa.html#fqa-16.21">[16.21] How can I force objects of my class to always be created via <code>new</code> rather than as locals or global/<code>static</code> objects?</a></li>
<li><a href="fqa.html#fqa-16.22">[16.22] How do I do simple reference counting?</a></li>
<li><a href="fqa.html#fqa-16.23">[16.23] How do I provide reference counting with copy-on-write semantics?</a></li>
<li><a href="fqa.html#fqa-16.24">[16.24] How do I provide reference counting with copy-on-write semantics for a hierarchy of classes?</a></li>
<li><a href="fqa.html#fqa-16.25">[16.25] Can you absolutely prevent people from subverting the reference counting mechanism, and if so, <i>should</i> you?</a></li>
<li><a href="fqa.html#fqa-16.26">[16.26] Can I use a garbage collector in C++?</a></li>
<li><a href="fqa.html#fqa-16.27">[16.27] What are the two kinds of garbage collectors for C++?</a></li>
<li><a href="fqa.html#fqa-16.28">[16.28] Where can I get more info on garbage collectors for C++?</a></li>
</ul>

<a id="fqa-16.1"></a>
<h2>[16.1] Does <code>delete p</code> delete the pointer <code>p</code>, or the pointed-to-data <code>*p</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.1">FAQ:</a></b> That would be <code>*p</code>. The keyword should have been <code>delete_whatever_is_pointed_by</code>. Similarly, <code>free</code> should have
been called <code>free_whatever_is_pointed_by</code>.
</p>

<p>
<b class="FQA">FQA:</b> It really should have been &quot;&quot;. That&#39;s right, the keyword should have been an empty string. <i>You</i> don&#39;t need it. The object should live
as long as someone can use it, and when it becomes unaccessible and can no longer be used by anyone, it should die. Why is making sure that
this is what actually happens <i>your</i> job?
</p>

<p>
Of course <a href="fqa.html#fqa-16.26">garbage collection</a> may be time consuming in the average and/or worst case.
Are you sure your implementation of <code>new</code> is better in this respect though? At least with garbage collection and
managed pointers you can do heap compaction. With <code>new/delete</code> and bare pointers, pieces of memory between
used blocks too small to satisfy an actual allocation request will accumulate, and you&#39;ll effectively run out of memory.
This nice situation is called external memory fragmentation. Try it with your production code that&#39;s supposed to have long
(not to mention &quot;unlimited&quot;) uptime - it&#39;s fun!
</p>

<p>
And what if you make a mistake, one single mistake with all these deletions? Either you&#39;ll run out of memory, or your
program will crash, or it will corrupt its own data. Which is why many experienced C++ programmers do everything to avoid explicit
calls to <code>new</code>. Instead, they use <a href="fqa.html#fqa-17.4">RAII</a> - have some constructor do the <code>new</code> and the destructor do the <code>delete</code>. Which
eventually leads to lots of <a href="fqa.html#fqa-11.1">unnecessary copying</a> - you can&#39;t point to some data inside a data structure since the
data structure may be about to die, and it will kill all its data whether or not someone points to it. So you have
to make a copy of that data, and keep believing that manual memory management is what makes your C++ programs so fast.
</p>

<p>
If managing the life and death of objects is such a big deal, perhaps the language isn&#39;t very <a href="fqa.html#fqa-6.17">object-oriented</a> after all,
is it?
</p>


<a id="fqa-16.2"></a>
<h2>[16.2] Is it safe to <code>delete</code> the same pointer twice?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.2">FAQ:</a></b> It isn&#39;t. Don&#39;t do that. Your program may crash or corrupt its own data. If it works in a test, it doesn&#39;t mean
it always works. Don&#39;t do that.
</p>

<p>
<b class="FQA">FQA:</b> When you <code>delete</code> the pointer, it still points to the same place - the only difference is that the place was
marked as &quot;free&quot; in some system-specific way. The second call to <code>delete</code> will probably try to mark it as &quot;free&quot; again.
Which may be problematic when it&#39;s no longer free, actually, because someone has already allocated an object there,
and you&#39;ve just wiped it out with your second <code>delete</code> call, so now <i>still other someone</i> can allocate an object there
and overwrite the object you&#39;ve destroyed so immorally.
</p>

<p>
There are other ways for this to fail - say, the code marking
blocks as &quot;free&quot; and assuming they are taken may count on some memory right before the place pointed by the block
start pointer to contain some meta-data it no longer contains, etc.
</p>

<p>
Here&#39;s what happens in <a href="fqa.html#fqa-6.5">managed environments</a>. First, you don&#39;t delete anything: the environment does. Second, it never
deletes anything unless nobody points to it. So you are never stuck with pointers pointing to graves of dead objects,
which may already be inhabited by freshly created objects. Which is good, because whatever your project is, memory
management is not one of its stated goals, is it? It&#39;s nice not to do something you don&#39;t really want to do.
</p>


<a id="fqa-16.3"></a>
<h2>[16.3] Can I <code>free()</code> pointers allocated with <code>new</code>? Can I <code>delete</code> pointers allocated with <code>malloc()</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.3">FAQ:</a></b> You can&#39;t. Don&#39;t do that. Your program may crash or corrupt its own data. If it works in a test, it doesn&#39;t mean
it always works. Don&#39;t do that.
</p>

<p>
<b class="FQA">FQA:</b> The many <a href="fqa.html#fqa-8.6">duplicate C++ facilities</a>, such as <code>new</code> and <code>malloc</code>, are ugly, but using mismatching functions for allocation
and deallocation is not less ugly. Why do you want to do that? It&#39;s like using an opening parenthesis and a closing bracket.
How can you count on something like this to work reliably?
</p>


<a id="fqa-16.4"></a>
<h2>[16.4] Why should I use <code>new</code> instead of trustworthy old <code>malloc()</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.4">FAQ:</a></b> <code>new/delete</code> call the constructor/destructor; <code>new</code> is type safe, <code>malloc</code> is not; <code>new</code> can be overridden by
a class.
</p>

<p>
<b class="FQA">FQA:</b> The virtues of <code>new</code> mentioned by the FAQ are not virtues, because <a href="fqa.html#fqa-10.1">constructors</a>, <a href="fqa.html#fqa-11.1">destructors</a>, and <a href="fqa.html#fqa-13.1">operator overloading</a>
are garbage (see what happens when you have no garbage collection?), and the type safety issue is really tiny here
(normally you have to cast the <code>void*</code> returned by <code>malloc</code> to the right pointer type to assign it to a typed pointer variable, which may be
 annoying, but far from &quot;unsafe&quot;).
</p>

<p>
Oh, and using trustworthy old <code>malloc</code> makes it <a href="fqa.html#fqa-16.5">possible</a> to use the equally trustworthy &amp; old <code>realloc</code>. Too bad
we don&#39;t have a shiny new <code>operator renew</code> or something.
</p>

<p>
Still, <code>new</code> is not bad enough to justify a deviation from the common style used throughout a language, even when the
language is C++. In particular, classes with <a href="fqa.html#fqa-10.17">non-trivial constructors</a> will misbehave in fatal ways if you simply <code>malloc</code>
the objects. So why not use <code>new</code> throughout the code? People rarely overload <code>operator new</code>, so it probably won&#39;t
get in your way too much. And if they do overload <code>new</code>, you can always ask them to stop.
</p>


<a id="fqa-16.5"></a>
<h2>[16.5] Can I use <code>realloc()</code> on pointers allocated via <code>new</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.5">FAQ:</a></b> Guess what - you can&#39;t. <code>realloc</code> may end up copying memory, and C++ objects don&#39;t like to have their memory
copied without getting notified. They like to have their copy constructors and <code>operator=</code> handle the copying.
</p>

<p>
By the way, why do you think <code>malloc/realloc/free</code> use the same heap as <code>new/delete</code>?
</p>

<p>
<b class="FQA">FQA:</b> The fact that there&#39;s no <code>renew</code> or whatever you&#39;d call it is one of the reasons to use custom allocators
instead of <code>new</code>. You can then allocate uninitialized memory with <code>malloc</code> and use placement <code>new</code>
to call constructors. Code doing these things is usually <a href="fqa.html#fqa-10.5">as ugly as sin</a>, hard to get right and gets in the way
of debuggers.
</p>

<p>
Many C++ objects will live happily ever after they&#39;re moved (<code>realloc</code>&#39;d). A different set of objects always get broken - those <i>pointing to the old place</i>.
The intersection of these sets is non-empty since objects can keep pointers into themselves. Which is the <i>special case</i>
that&#39;s sort of solved by copy constructors and <code>operator=</code> (the solution is simply to have <i>you</i> implement the copying
so that pointers are set up correctly).
</p>

<p>
However, the <i>general case</i> can&#39;t be solved - you can&#39;t move a C++ object
and destroy the old one unless you can prove that no pointers are left to the old location. This can&#39;t be proved
automatically in the general case (the halting problem and all that). Which is why you can&#39;t
do <a href="fqa.html#fqa-16.1">automatic heap compaction</a>, which could solve the external fragmentation problem.
</p>

<p>
If your implementation uses two heaps, one for <code>malloc</code> and one for <code>new</code>, then it stinks, because sometimes
you want to somehow replace <code>malloc</code> with something else, and it&#39;s nice to be able to do it once (for <code>malloc</code>), not twice (for <code>malloc</code> and <code>new</code>),
and two heaps probably mean more fragmentation, and what&#39;s the point of two heaps? I&#39;ve never seen this done,
but it actually is legal.
</p>


<a id="fqa-16.6"></a>
<h2>[16.6] Do I need to check for <code>NULL</code> after <code>p = new Fred()</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.6">FAQ:</a></b> No, that would be bad. <code>new</code> throws an exception, so you don&#39;t have to insert tests all over the place.
Unless you&#39;re using an old compiler (you can still work around it and have an exception thrown).
</p>

<p>
<b class="FQA">FQA:</b> C++ exceptions are frequently <a href="fqa.html#fqa-17.1">worse</a> than having your code simply and straight-forwardly crash (at least in the
latter case, you have a good chance to find the call stack where that happened). Disabling exception support
at your latest &amp; greatest compiler is sometimes a good idea.
</p>

<p>
If you really have to write code handling out-of-memory conditions gracefully, that&#39;s not as easy a task as simply
catching a C++ exception. First, you&#39;ll probably have to avoid recursion (C++ doesn&#39;t throw stack overflow exceptions, you know,
so the program can&#39;t behave gracefully when you&#39;re out of <i>that</i> memory).
Second, what are you going to do when you&#39;re out of memory? Take into account that you&#39;ll need <i>memory</i> to do it;
you might need to reserve some in advance.
</p>

<p>
And there aren&#39;t that many choices in most cases. You can exit with an error message instead of &quot;hard&quot; crashing.
You can show a message saying that there&#39;s not enough memory and could the user please close some programs and
then you&#39;d retry, or maybe the user wants your program to quit? All these can be done without exceptions.
</p>

<p>
Exceptions can be sort of handy when your approach is to &quot;abort the current operation&quot;, but exceptions are not a very good way
to develop robust code, and if you actually want to deal gracefully with out-of-memory situations
(you probably noticed that it&#39;s rarely done), that&#39;s
way out of their league. The reason is that with exceptions, there are many ways to make subtle errors
in your error handling code, and when some aspect of your application is important, you&#39;re usually better off
making the handling of that aspect explicit and clear.
</p>


<a id="fqa-16.7"></a>
<h2>[16.7] How can I convince my (older) compiler to automatically check <code>new</code> to see if it returns <code>NULL</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.7">FAQ:</a></b> You can pass a callback function throwing an exception to <code>std::set_new_handler</code>. This will work, except for
 global variables calling <code>new</code> before you set your handler. There is no way to make sure your handler is set first -
 even if you set it in the constructor of a global variable, that variable is not necessarily the first one to be constructed.
</p>

<p>
<b class="FQA">FQA:</b> I wonder why you want <code>new</code> to throw exceptions. This desire may be the indication of a certain kind of mindset.
Hmmm, let&#39;s conduct a test: are you happy with the FAQ&#39;s solution, or are you actually bothered by the fact that <i>a constructor of a global variable</i>
 may run out of memory without throwing an exception?
</p>

<p>
If this option scares you, it probably means that you like to do hairy things before <code>main</code>
 in <a href="fqa.html#fqa-10.12">undefined order</a>, including throwing and catching exceptions, which confirms my worst fears. I hope you get out of these habits by the time we happen to work
 on the same project.
</p>

<p>
If, on the contrary, you think that global constructors shouldn&#39;t get that complicated, your approach is apparently a little bit more practical,
and now I&#39;m really puzzled. Are you absolutely sure you want <code>new</code> to throw exceptions?
</p>


<a id="fqa-16.8"></a>
<h2>[16.8] Do I need to check for <code>NULL</code> before <code>delete p</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.8">FAQ:</a></b> <code>delete</code> already does that, so no, you shouldn&#39;t! <i>You could get the test wrong</i>, and you&#39;ll spend time testing
 both execution paths <i>as required by testing methodologies</i>.
</p>

<p>
<b class="FQA">FQA:</b> Apparently the FAQ is written for imbeciles that can&#39;t test for <code>NULL</code>, <i>and</i> they don&#39;t test the code after writing
 it to see if it worked, <i>but</i> they <i>do</i> mechanically test all branches because of <i>testing methodologies</i>. If you want
 to really create a vivid image of a member of the FAQ&#39;s target audience in your imagination, think about this: just <i>how</i> does the
 idiot cover both execution paths? The poor creature must artifically create cases where <code>p</code> is <code>NULL</code>, without
 having the rest of the program crash. Which can be tricky enough to be inconsistent with the rest of our data
 about the mental capabilities of this programmer. And now we get a clear picture: the FAQ
 is designed for extraterrestrial intelligence struggling with the many difficulties of C++.
</p>

<p>
Actually, there is no reason to be mean this time. Once in a lifetime those people actually made something easy.
 Maybe they were inspired by the example of <code>free</code>, which also accepts null pointers.
Pretty inconsistent with the spirit of the language. Which is why I was very surprised when I first found this out.
</p>


<a id="fqa-16.9"></a>
<h2>[16.9] What are the two steps that happen when I say <code>delete p</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.9">FAQ:</a></b> When <code>p</code> is a <code>T*</code>, the first step is <code>p-&gt;~T();</code>, and the second is <code>operator delete(p);</code>.
</p>

<p>
<b class="FQA">FQA:</b> Ugly syntax, isn&#39;t it? Especially the fact that <code>a+b</code> is the same as <code>operator+(a,b)</code>, but
 <code>delete p</code> is <i>not at all</i> the same as <code>operator delete(p)</code>.
</p>

<p>
The semantics are consistent with the <a href="fqa.html#fqa-10.1">decoupling</a> of <i>allocation</i> (<code>operator new</code>) and <i>construction</i> (<code>T()</code>).
 This decoupling breaks <a href="fqa.html#fqa-7.4">encapsulation</a> without admitting it (the caller must know the size of the objects of the class
at compile time, which means it must know all the <code>private</code> members) in order to increase efficiency in straight-forward implementations
 (which can&#39;t do just-in-time compilation with optimization and have to know the size at compile time to optimize allocation).
Which is why C++ code is recompiled all the time.
</p>


<a id="fqa-16.10"></a>
<h2>[16.10] In <code>p = new Fred()</code>, does the <code>Fred</code> memory &quot;leak&quot; if the <code>Fred</code> constructor throws an exception?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.10">FAQ:</a></b> No, because the compiler effectively generates a <code>try/catch</code> block around the constructor call, and when exceptions
  are thrown, the <code>catch</code> part deallocates the memory and rethrows the exception.
</p>

<p>
<b class="FQA">FQA:</b> If you throw exceptions in constructors, make sure they are caught when custom allocators are used
(the kind that looks like this: <code>new (pool.alloc()) Fred()</code>).
</p>

<p>
If you don&#39;t throw exceptions, the implicit <code>try/catch</code> around <code>new</code> is one illustration of the fact that exceptions
increase the size of your code even when you don&#39;t use them. One good thing is that most compilers have a flag disabling exceptions.
</p>


<a id="fqa-16.11"></a>
<h2>[16.11] How do I allocate / unallocate an array of things?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.11">FAQ:</a></b> You allocate it with <code>p = new T[N]</code> and deallocate with <code>delete[] p</code>. Using <code>delete p</code> is an error.
</p>

<p>
<b class="FQA">FQA:</b> You can only do that if <code>T</code> has a <a href="fqa.html#fqa-10.5">default constructor</a> (one that can work without arguments). Which is one more
  reason to avoid non-trivial constructors. Alternatively, if you&#39;d rather create a problem than solve one,
  you can replace your <a href="fqa.html#fqa-6.15">evil</a> arrays with <code>std::vector</code>.
</p>


<a id="fqa-16.12"></a>
<h2>[16.12] What if I forget the <code>[]</code> when deleting array allocated via <code>new T[n]</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.12">FAQ:</a></b> You&#39;ll infect your program with an incurable disease. It will do something like corrupt its data and die.
</p>

<p>
<b class="FQA">FQA:</b> If you want to realize the idiocy of this rule in its full glory, consider this. <code>new</code> calls <code>malloc</code> or some other
allocator, and it passes it the block size. The allocated pointer is then passed to <code>delete</code>, but the size is <i>not</i>.
How does <code>delete</code> know to free a block of the right size - not too little, not too much? <i>It has to store the size
  somewhere</i>, doesn&#39;t it? But <i>of course</i> it <i>can&#39;t be bothered</i> to figure out the number of objects pointed by the
  pointer (like, divide the stored size by <code>sizeof(*p)</code>, making an actual <i>use</i> of &quot;type safety&quot;) so it can call the destructors properly.
</p>

<p>
But wait, there&#39;s more! What&#39;s the deal with <i>data corruption</i>? Shouldn&#39;t the worst possible effect be a resource leak
  due to the fact that some destructors are not called?
</p>

<p>
Here&#39;s the best part. <code>operator new[]</code> allocates <i>a little bit more memory</i> than it&#39;s asked for in order to <i>store
  the number of the frigging objects</i> in that place (it can also be done in other ways, but the effect is equivalent). <code>delete[]</code> uses it to call the destructors for all the allocated
  objects. Since <code>new</code> doesn&#39;t store any number and only allocates the amount of memory it was told to, it becomes
  clear why mismatching the <code>new</code> and <code>delete</code> operators will lead to data corruption.
</p>

<p>
The bottom line is this: C++ stores the number of objects in a block <i>once</i> when <code>new</code> is called and <i>twice</i> when <code>new[]</code>
  is called, <i>and it will rather have you introduce lethal bugs in your program than use the information to help you
  get it right</i>. Now that is what I call &quot;hospitality&quot;.
</p>


<a id="fqa-16.13"></a>
<h2>[16.13] Can I drop the <code>[]</code> when deleting array of some built-in type (<code>char</code>, <code>int</code>, etc)?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.13">FAQ:</a></b> No you can&#39;t. You may think that you can, because <code>int</code> has a trivial destructor. But it&#39;s not just about
  destructors. For example, what if someone replaces <code>operator new[]</code> and <code>operator delete[]</code> in a way
  incompatible with mismatching <code>new/delete[]</code> calls?
</p>

<p>
<b class="FQA">FQA:</b> Yeah, did you think about that? And what if you use an array of <code>Int</code>, which is a <code>typedef</code>, and someone changes the <code>typedef</code> to
<code>SmartIntClass</code> instead of plain old <code>int</code>? Think about it. That&#39;s what your brain is for: thinking about
exciting, useful things like this.
</p>

<p>
The serious answer is that if a language has two sets of similar matching operators, than a programmer is better off
  <a href="fqa.html#fqa-16.3">avoiding mismatches</a> between those operators. The fact that there really should have been <a href="fqa.html#fqa-16.12">one</a> <code>delete</code> operator, no, wait,
make it <a href="fqa.html#fqa-16.1">zero</a>, may be a reason to switch to a different language, but not to <a href="fqa.html#fqa-10.3">violate the rules</a> of a language.
</p>


<a id="fqa-16.14"></a>
<h2>[16.14] After <code>p = new Fred[n]</code>, how does the compiler know there are <code>n</code> objects to be destructed during <code>delete[] p</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.14">FAQ:</a></b> Sing along: &quot;It&#39;s a kind of magic...&quot;
</p>

<p>
There are two common ways used by our friends the compiler-implementing magicians. One is to allocate extra memory
  and store the number of objects there. The other one is to use an associative array mapping from pointers to sizes.
</p>

<p>
<b class="FQA">FQA:</b> You may wonder why these clever magicians don&#39;t rely on <code>malloc</code> to do the magic, and have you end up with
  the block size stored <i>twice</i>: you ask <code>new</code> for 8 bytes, then <code>new</code> asks malloc for 12 bytes, then <code>malloc</code>
  asks <code>sbrk</code> or whatever&#39;s down its guts for 16 bytes.
</p>

<p>
The answer is of course <i>modularity</i>. Translation:
  why should the implementor of the C++ language bother to figure out the details of <code>malloc</code> when there&#39;s the easier
  option - leave it to the implementor of the C language and simply and portably implement <code>new[]</code> on top of the
  C runtime? 4 bytes of your memory are surely not a good enough reason.
</p>

<p>
&quot;Magic&quot;. The next thing you know, they&#39;ll call exploiting security holes in your OS to utilize some of those unused processor &amp; memory resources &quot;magic&quot;.
</p>


<a id="fqa-16.15"></a>
<h2>[16.15] Is it legal (and moral) for a member function to say <code>delete this</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.15">FAQ:</a></b> You can do this, as long as you are sure the object is allocated with <code>new</code>, and the pointer is not used for anything
  at all after <code>delete this</code>.
</p>

<p>
<b class="FQA">FQA:</b> This is a bit weird, and it probably causes many people to get alarmed and start anxiously looking for places that
  <i>might</i> touch the deleted object (as if it were more likely than a less exotic access to a dangling reference).
  And it forces the user of a class to allocate the objects with <code>new</code>, which is against the (misguided) <a href="fqa.html#fqa-10.1">spirit of C++</a>
  and therefore another source of <a href="fqa.html#fqa-8.6">confusion</a>. At least provide a <code>static</code> method that allocates objects with <code>new</code> and declare
  the destructors <code>private</code> to document your intent to control the allocation.
</p>

<p>
Why do you want to do it anyway? If you want to impress people, why not do some real magic - actual functionality, not just
  yet another syntactic exercise?
</p>


<a id="fqa-16.16"></a>
<h2>[16.16] How do I allocate multidimensional arrays using <code>new</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.16">FAQ:</a></b> The answer is very long with 3 large code listings.
</p>

<p>
<b class="FQA">FQA:</b> There is no <code>operator new[][]</code> in C++ - it decided that <code>new</code> and <code>new[]</code> are sufficient; it had many stupid reasons
  to decide that way. Anyway, you have two options: allocate a flat array and manage the N-dimensional indexing manually
  (generating one-dimensional indexes using expressions like <code>x+y*width</code>), or you can allocate an array of arrays <i><a class="corr" href="fqa.html#correction-4">(correction)</a></i>.
  For 2 dimensions, you need to allocate a <code>new T*[M]</code> and then in a loop with <code>M</code> iterations allocate a <code>new T[N]</code>.
</p>

<p>
With the second way you get more natural-looking indexing, but worse performance (less speed, more space). It may
  be convenient if you need each one-dimensional array in the two-or-more-dimensional array to have a different length,
  but even then it&#39;s probably better to fake it with a flatter kind of array in ugly ways if you care about
  performance
(by the way, if you don&#39;t, make the best of it - try a safe language).
</p>


<a id="fqa-16.17"></a>
<h2>[16.17] But the previous FAQ&#39;s code is SOOOO tricky and error prone! Isn&#39;t there a simpler way?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.17">FAQ:</a></b> Sure it is! You can define a <code>Matrix</code> class and have it do all the dirty work. Which is good, as should be obvious
to anyone familiar with <i>Star Trek 2</i> (a reference follows).
</p>

<p>
<b class="FQA">FQA:</b> I didn&#39;t see <i>Star Trek</i>, but moving the dirty work to a single place doesn&#39;t make that work &quot;simple&quot;.
Of course it&#39;s better than doing that work over and over again, but how many multi-dimensional array classes have you seen,
 and what happens when someone tries to convert between them? I mean it can&#39;t be a &quot;single place&quot; unless that place is the compiler.
</p>

<p>
By the way, if you need performance, you can&#39;t really encapsulate the layout of the multi-dimensional array,
because you&#39;ll need to do things like get one column to the right (with <code>flat_index+1</code>) or one row up (with <code>flat_index+row_width</code>),
 instead of computing things like <code>x+(y+1)*row_width</code> every time through the innermost loop.
</p>

<p>
You can try to define all kinds of functions like
 <code>increment_by_row</code>. If you really believe that it will make it possible to &quot;transparently&quot; change the representation later
 (thus turning all the optimizations carefully developed for this representation into pessimizations), go ahead and define
and optimize hordes of such tiny functions and keep lying to yourself about how this makes your code more readable.
</p>

<p>
Data representation is very important. Too bad so many people believe that the only important thing about <i>data</i>
 is to hide it behind <i>code</i> (<a href="fqa.html#fqa-22.1">interfaces</a>) so that you can &quot;always change the data representation later&quot;. While this
 may be right in the majority of cases, it is likely to be wrong in <i>the most important</i> cases.
</p>


<a id="fqa-16.18"></a>
<h2>[16.18] But the above <code>Matrix</code> class is specific to <code>Fred</code>! Isn&#39;t there a way to make it generic?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.18">FAQ:</a></b> Of course! You can use templates!
</p>

<p>
<b class="FQA">FQA:</b> This way, not only will your code run slowly - it will also compile slowly.
</p>


<a id="fqa-16.19"></a>
<h2>[16.19] What&#39;s another way to build a <code>Matrix</code> template?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.19">FAQ:</a></b> You can use <code>std::vector</code> instead of bare pointers!
</p>

<p>
<b class="FQA">FQA:</b> You can also use any of the numerous array classes implemented before <code>std::vector</code> was introduced into the
 C++ standard library (which was long after C++ became widely used).
</p>

<p>
Alternatively, you can also use any of the numerous <i>matrix</i> classes implemented before <code>std::matrix</code> was introduced
 into the C++ standard library... Actually, make that &quot;before <code>std::matrix</code> <i>will be</i> introduced into the C++
 standard library&quot;. Can you explain why the C++ standard includes <code>std::vector</code> - a class quite similar to built-in
 arrays, but different - but does not include <code>std::matrix</code>, a class that would be quite similar to built-in 2D arrays,
 but different? Here&#39;s a more difficult question: is it good or bad that we don&#39;t have <code>std::matrix</code>, provided that
 we <i>do have</i> less than optimal built-in 2D arrays? Before you answer, consider type conversions, dynamic resizing, literal values,
 telling the size of an array at run time...
</p>

<p>
That&#39;s what C++ is all about: the development of your ethical judgment. Everybody can tell
 good from bad; <a href="fqa.html#fqa-8.6">choosing</a> between the ugly and the disgusting takes real wisdom.
</p>


<a id="fqa-16.20"></a>
<h2>[16.20] Does C++ have arrays whose length can be specified at run-time?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.20">FAQ:</a></b> That would be yes - there&#39;s <code>std::vector</code>.
</p>

<p>
Actually, it&#39;s a no - you can&#39;t do it with built-in arrays.
</p>

<p>
Wait a minute - you <i>can</i> do it with <i>the first index</i> of a built-in array, for example: <code>new T[run_time_val][compile_time_val]</code>.
</p>

<p>
You know what? Arrays are <a href="fqa.html#fqa-6.15">evil</a>.
</p>

<p>
<b class="FQA">FQA:</b> <code>std::vector</code> is not an array, it&#39;s a class that looks like an array until you try to initialize it with <code>{1,2,3}</code>
 or pass an array to a function expecting a <code>vector</code> or get a huge compiler error message.
 Built-in arrays don&#39;t behave like this.
</p>

<p>
C++ inherits the following rule about types from C: the size of a type is always known at compile time, and you can
 get it with <code>sizeof</code>. This rule is useful in C because, <i>together with other rules</i> which are violated in C++, it makes it quite easy to
 mentally map source code to assembly code (sort of) and estimate run time performance. In C++ it&#39;s no longer useful,
 because telling the <i>meaning</i> of C++ code is nearly impossible, not to mention reasoning about its performance.
</p>

<p>
Anyway, the length of a built-in array is part of its type, so if it could be dynamic, it would violate the ex-useful
 rule. So it can&#39;t. However, built-in <i>pointers</i> can point to an array of length defined at run time. So you can have
 a <code>T* p</code> pointing to <code>run_time_val</code> objects, but you can&#39;t have an array of type <code>T[run_time_val]</code>. Which means that
 you can&#39;t allocate such arrays on the stack (unless the compiler decides to <i>almost</i> violate the ex-useful rule
 and support it, the way GNU C/C++ does, for example).
</p>

<p>
The built-in C++ arrays are inherited from C without changes
  (well, except for constructor/destructor calls and <code>new</code> in addition to <code>malloc</code> and other stuff of this kind), so if you
  care about details, the best place to look is material about C. This is one of the many examples illustrating that you
  have to know C in order to really understand C++.
</p>


<a id="fqa-16.21"></a>
<h2>[16.21] How can I force objects of my class to always be created via <code>new</code> rather than as locals or global/<code>static</code> objects?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.21">FAQ:</a></b> You can define the constructors <code>private</code> and provide <code>public</code> functions which return pointers to objects allocated
  with <code>new</code>. Which goes by the fancy name of &quot;The Named Constructor Idiom&quot;.
</p>

<p>
<b class="FQA">FQA:</b> Why do you want to force this? Allocating locals is more efficient than <code>new</code>, and you wouldn&#39;t have to worry
  about <code>delete</code>, either. The cost is that when you change the <code>private</code> members of the class, all code using it
  gets recompiled.
</p>

<p>
Wait, is that what you want - to avoid recompilation? In that case, the &quot;Named Constructor Idiom&quot; <a href="fqa.html#fqa-10.8">defeats the purpose</a> - change
  a <code>private</code> member and you still trigger a rebuild.
  You can either drop C++ classes and store the state in a C <code>struct</code>
  (place a forward declaration in the header file and the full definition in the implementation file), or you can
  wrap this exact solution with the code of an extra C++ class just because C is evil. The latter
  way is known as &quot;The Pimpl Idiom&quot; (&quot;pimpl&quot; apparently stands for &quot;pointer to implementation&quot;).
</p>

<p>
Idioms make the world move. Especially the Design Pattern Idiom. Or the Idiom Design Pattern. Or something.
</p>


<a id="fqa-16.22"></a>
<h2>[16.22] How do I do simple reference counting?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.22">FAQ:</a></b> Two large code listings are given (a quote from these listings: <code>// DO NOT CHANGE THE ORDER OF THESE STATEMENTS!</code>), followed by a bold
  claim that now you have a way to do simple reference counting.
</p>

<p>
<b class="FQA">FQA:</b> You do <b>simple</b> reference counting by using a language which does reference counting
  (or garbage collection - you probably don&#39;t care if you want it &quot;simple&quot;).
</p>

<p>
You do <b>complicated</b> and <b>broken</b> reference counting by using C++, creating smart pointer classes
   (and smart array classes, and smart multi-dimensional array classes), wrapping your private constructors with
   public functions returning smart pointers to objects (or smart arrays of objects) to make sure all objects
   are actually pointed by smart pointers so the reference counting is not entirely worthless.
</p>

<p>
Congratulations! You&#39;ve just wasted lots and lots of time to emulate garbage collection on top of C++.
Well, the code doesn&#39;t compile as fast as it would with built-in garbage collection (all those smart pointer templates),
   and the error messages are a bit cryptic (all those smart pointer templates), and there are those tricky cases
   like cyclic references you still fail to deal with (despite all those smart pointer templates), and for every class
   you write extra code wrapping constructors, and the whole thing doesn&#39;t play well with existing libraries
   (which use <i>different</i> smart pointer templates), and...
</p>

<p>
<i>Why</i> do you want to do reference counting in C++?
</p>


<a id="fqa-16.23"></a>
<h2>[16.23] How do I provide reference counting with copy-on-write semantics?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.23">FAQ:</a></b> You can have your class keep all the data in a structure pointed by a member pointer <code>_data</code>, and then each method
   that wants to modify the object has to check the reference count, and if the data is shared by several objects,
   the data must be cloned before the modification.
</p>

<p>
<b class="FQA">FQA:</b> Ultimately, what are you trying to achieve? If you care a lot about efficiency <i>and</i> you care a lot about high
   level of abstraction <i>in the same piece of code</i>, there&#39;s probably no easy solution for you. Are you sure
   it&#39;s <i>the same</i> code? Or maybe you want efficiency in some places, and high level of abstraction in other places?
Then you can use two different languages.
</p>

<p>
If it&#39;s really the same code, the best solution is probably to write your own little language.
   It&#39;s not as hard as it sounds, and not so strange - think about it: apparently you must write a lot of code
   (if there wasn&#39;t a lot of it, it wouldn&#39;t be a problem) in some pretty
    specific domain, because there&#39;s no high level language which supports the right built-in facilities. Or is there?
   Are you looking for copy-on-write strings or something? <i>String processing in C++?</i> Do yourself a favor and stop right there.
   Use a language with decent built-in strings.
</p>

<p>
If there really is no good existing high-level language for your job,
   basically what you have to do is meta-programming: you want something which is not directly related to the specific meaning
   of your program - you want objects of pretty much arbitrary classes to behave in a certain way. Which means you want a new language. You can do it with
   your own compiler or you can do it in a system which supports meta-programming well (the two approaches are really pretty close).
   C++ meta-programming is a nightmare - the facilities for it are very poor, and there&#39;s lots of strange features
   already in the language that you must interoperate with. You have been warned: this path leads to the gates of madness.
</p>

<p>
Clarification: I&#39;m not saying that meta-programming is likely to be the solution when you want copy-on-write.
   On average, that would probably be over-engineering. However, in the cases where it indeed is over-engineering,
   so is the FAQ&#39;s solution; the way to go is probably to have the user code explicitly copy objects upon modifications.
   And when there&#39;s enough code involved to make that tedious, then the C++ solution also gets tedious,
   and that&#39;s when meta-programming could be appropriate.
</p>


<a id="fqa-16.24"></a>
<h2>[16.24] How do I provide reference counting with copy-on-write semantics for a hierarchy of classes?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.24">FAQ:</a></b> You do it by writing a lot of code! Like this:
</p>

<pre>
  code;
  code;
  code;
  lots of code;
  more code;
  two screens of code;
  //boy is this FUN!
  code;
</pre>

<p>
<b class="FQA">FQA:</b> Here&#39;s a solution for another hierarchy of classes (you might have more than one in your project - it happens, and the FAQs
   &quot;solution&quot; is done on a per-method basis, and <i>there isn&#39;t even a way to iterate over the methods of a class</i> in C++,
   not to mention &quot;transparently instrument the methods of a class with custom logic like copy-on-write&quot;):
</p>

<pre>
  code;
  code;
  //why am I doing this?
  code;
  code;
  //help
  code;
  //I think I&#39;d rather become a farmer
</pre>

<p>
Seriously, I&#39;m not going to discuss the nightmare that is the FAQ&#39;s proposed solution. Follow the link to the FAQ&#39;s
  answer if you want to check it out. What I would like to point out is that it&#39;s possible to do all this
  transparently if your environment has good support for meta-programming. For example, some languages
  let you write your own code to implement object attribute modification (the simpler option), and/or automatically
  generate wrapper classes to intercept methods changing objects (the more complicated option). Either way, you end
  up with O(1) code to solve the problem instead of O(N), where N is the number of classes involved.
</p>


<a id="fqa-16.25"></a>
<h2>[16.25] Can you absolutely prevent people from subverting the reference counting mechanism, and if so, <i>should</i> you?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.25">FAQ:</a></b> You can&#39;t, and you <i>usually</i> shouldn&#39;t.
  (Yes, that&#39;s pretty much what the FAQ says: sometimes you <i>should</i> do what you <i>can&#39;t</i>. Just what does &quot;should&quot; mean in its warped universe?)
</p>

<p>
There are two holes in the armor. First, your <code>SmartPtr</code> probably has an <code>operator*</code> that returns a bare reference to an object. So you can end up with <code>Dumb* p = &amp;*smart_p;</code>.
  This can be sort of closed using several approaches, each worse than the others in its own unique way. And then
  there are ways to get the bare pointer with syntax like <code>smart_p.operator-&gt;()</code>, returning a <code>Dumb*</code>.
</p>

<p>
The second hole is that someone can have dangling references to <code>SmartPtr</code>. This can&#39;t be prevented even by
  returning a <code>SmartPtrPtr</code> in an overloaded <code>operator&amp;</code>, because C++ has <i>references</i> (remember - the new feature you <a href="fqa.html#fqa-8.6">should</a> use instead of the <a href="fqa.html#fqa-6.15">evil</a> pointers),
  and there&#39;s nothing you can overload to prevent someone from taking a reference to your <code>SmartPtr</code>.
</p>

<p>
Use code reviews to figure out what&#39;s actually going on with all those smart pointers.
</p>

<p>
<b class="FQA">FQA:</b> You can&#39;t fake what you don&#39;t have (I think the quote is attributed to S. Cray). C++ doesn&#39;t have safe memory management. <a href="fqa.html#fqa-16.22">Faking</a>
  safe memory management leads to still unsafe memory management, with the important bonus of obfuscation.
</p>

<p>
You can absolutely prevent people from subverting the reference counting mechanism by using a programming language
  that absolutely prevents people from subverting its built-in memory management mechanisms.
</p>


<a id="fqa-16.26"></a>
<h2>[16.26] Can I use a garbage collector in C++?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.26">FAQ:</a></b> Sure you can. Let&#39;s compare it to smart pointer techniques. Garbage collection is not as portable, but typically
  more efficient, and it can handle cyclic references, and it works better with others&#39; libraries because
  you don&#39;t need to explicitly change the pointers from dumb to smart or anything like it. However, sometimes objects
  can leak - a C++ garbage collector <a href="fqa.html#fqa-7.2">can't</a> tell a pointer from a random bit sequence that just happens to look like
  a pointer.
</p>

<p>
<b class="FQA">FQA:</b> Assuming you live in a free country, what&#39;s there to stop you from using a garbage collector in C++? Sure, there
  are minor obstacles, for example, it doesn&#39;t really work, but it&#39;s still a free country, isn&#39;t it?
</p>

<p>
Suppose you can use garbage collection, which means that you are not worried about interference with real time
  requirements. <i>Why are you using C++?</i> Why not use a safe language instead? Look - the C++ FAQ admits that
  garbage collection is <i>more efficient</i> than C++ &quot;smart pointers&quot; all over the place, and more correct (cyclic references),
  and the single correctness problem it mentions (random bit patterns) vanishes in a managed environment.
  So what&#39;s the problem?
</p>

<p>
If you think you need to use C++, deal with the fact that it doesn&#39;t have garbage collection, and you must manage
  memory manually. Or you can deal with the other facts. For example, what happens if two libraries relying on
  <i>different</i> garbage collectors are supposed to work <i>in the same program</i>? What happens if code incompatible
  with garbage collection (because it does <a href="fqa.html#fqa-16.27">"clever"</a> things with pointers, like <code>one_based_array = (int*)malloc(arr_size)-1</code>)?
  What about destructors? C++ garbage collectors don&#39;t know what they&#39;re freeing, so you can&#39;t have finalization
  functions. What about all those happy custom allocators C++ programmers <a href="fqa.html#fqa-11.14">adore</a> so much? What if a <code>malloc</code>ed object
  points to an object allocated from such a custom pool? The destructor of the outer object with the pointer is not going to be called - so who is going
  to deallocate the pointed object from the pool?
</p>

<p>
C++ does not feel pain. It can&#39;t be reasoned with. Starting a fight is a big mistake. If you want to use C++,
  you must learn to love it the way it is, in particular, manage your memory manually.
</p>


<a id="fqa-16.27"></a>
<h2>[16.27] What are the two kinds of garbage collectors for C++?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.27">FAQ:</a></b> There are <i>conservative</i> and <i>hybrid</i> garbage collectors. The conservative ones just look for bit sequences
  looking like pointers. The hybrid ones require the programmer to specify some layout information explicitly
  in the code (but they still traverse the call stack conservatively when they look for pointers).
</p>

<p>
Garbage collectors may cause memory leaks when a bit pattern looking like a pointer is misinterpreted as a proof
  that the block pointed by this &quot;pointer&quot; is still in use. And some illegal programs may &quot;confuse&quot; garbage collectors
  (that&#39;s the word used by the FAQ) by keeping pointers outside of allocated blocks. Why <a href="fqa.html#fqa-12.2">can't</a> these programmers
behave <a href="fqa.html#fqa-17.10">reasonably</a>?
</p>

<p>
<b class="FQA">FQA:</b> Let&#39;s start with a different question: what&#39;s the problem with garbage collection in C++? Answer: there is <a href="fqa.html#fqa-7.2">no way</a>
   to inspect the state of a C++ program and tell which blocks are in use. In environments designed to support garbage
   collection, you can do that by checking if the program can reach the block using one of the pointers it currently
   keeps in its memory. But in C++, you can&#39;t. First, you don&#39;t know where the program keeps pointers
   (no real run time type information), and second, pointers that don&#39;t point into a block can be used to compute
   pointers that do point into that block (unsafe pointer arithmetics).
</p>

<p>
So along come the memory leaks, and the &quot;confusion&quot;. And what <i>happens</i> when a garbage collection is &quot;confused&quot;? I&#39;ll tell you what happens - it frees an object
  which is still in use. The result is a crash or a data corruption. Do you think &quot;confused&quot; is a legitimate euphemism
  in this context? &quot;Oh, I&#39;m so confused! I think I&#39;ll kill your program now.&quot;
</p>

<p>
As to the &quot;unreasonable&quot; programmers - well, adjusting a pointer to point before an allocated block is one efficient way
   to implement one-based (instead of zero-based) arrays, among other things. Of course you can allocate an extra
   element and avoid violating the rules. But most people don&#39;t know these rules, because although they are a part
   of the language definition, they are not enforced in the widespread implementations, and don&#39;t become a part
   of the mental model developed by programmers as they gain familiarity with the language.
</p>

<p>
That is, not only does
   it <i>work</i> when one implements one-based arrays this way - one <i>doesn&#39;t see a reason for it not to work</i>: experience
   consistently tells people that C++ pointers are just a kind of integer. Formally,
   there are reasons for this to be illegal (like, duh, what happens if you want garbage collection?) - but most people are not language
   lawyers. In practice, what matters is the de facto standard (that&#39;s why it&#39;s called &quot;de facto&quot;).
</p>


<a id="fqa-16.28"></a>
<h2>[16.28] Where can I get more info on garbage collectors for C++?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/freestore-mgmt.html#faq-16.28">FAQ:</a></b> <a href="http://www.iecc.com/gclist/GC-faq.html">Here</a>.
</p>

<p>
<b class="FQA">FQA:</b> Don&#39;t bother. If garbage collection worked in C++, you would hear about it. C++ has been around for decades, there are hundreds of thousands
   of C++ programmers, and megatons of C++ code with zillions of memory management bugs. If someone implemented
   a working solution for this problem, they&#39;d become rich, famous, or both, and the garbage collector(s)
   would be everywhere.
</p>

<p>
<a href="fqa.html#fqa-16.26">Why</a> do you think you don&#39;t see too many around?
</p>

<a id="fqa-exceptions"></a><h1>Exceptions and error handling</h1>
<p>
This page is about C++ exceptions - an error handling facility which may be worse than dereferencing a null pointer upon error.
</p>

<ul>
<li><a href="fqa.html#fqa-17.1">[17.1] What are some ways <code>try / catch / throw</code> can improve software quality?</a></li>
<li><a href="fqa.html#fqa-17.2">[17.2] How can I handle a constructor that fails?</a></li>
<li><a href="fqa.html#fqa-17.3">[17.3] How can I handle a destructor that fails?</a></li>
<li><a href="fqa.html#fqa-17.4">[17.4] How should I handle resources if my constructors may throw exceptions?</a></li>
<li><a href="fqa.html#fqa-17.5">[17.5] How do I change the string-length of an array of <code>char</code> to prevent memory leaks even if/when someone throws an exception?</a></li>
<li><a href="fqa.html#fqa-17.6">[17.6] What should I throw?</a></li>
<li><a href="fqa.html#fqa-17.7">[17.7] What does <code>throw;</code> (without an exception object after the <code>throw</code> keyword) mean? Where would I use it?</a></li>
<li><a href="fqa.html#fqa-17.8">[17.8] How do I throw polymorphically?</a></li>
<li><a href="fqa.html#fqa-17.9">[17.9] When I throw this object, how many times will it be copied?</a></li>
<li><a href="fqa.html#fqa-17.10">[17.10] Exception handling seems to make my life more difficult; clearly <i>I&#39;m</i> not the problem, am I??</a></li>
<li><a href="fqa.html#fqa-17.11">[17.11] I have too many try blocks; what can I do about it?</a></li>
</ul>

<a id="fqa-17.1"></a>
<h2>[17.1] What are some ways <code>try / catch / throw</code> can improve software quality?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.1">FAQ:</a></b> You&#39;ll have less <code>if</code> statements in your code: you won&#39;t have to check for errors
each time you call a function. Conditional statements are known to contain
more bugs than other statements. With less <code>if</code> tests, you&#39;ll ship a better product, faster.
</p>

<p>
<b class="FQA">FQA:</b> This is <a href="http://en.wikipedia.org/wiki/Cargo_cult">cargo cult</a> programming. Conditional
statements are error-prone because they are used to handle complicated scenarios, where an action
can result in many different outcomes, which affect the next actions. In order to make errors less probable, one has to simplify
the model of the desired behavior of the software. The problem is the complexity that leads to <code>if</code>
statements, not the <code>if</code> keyword, and using different keywords is not going to solve the problem by itself.
</p>

<p>
Exceptions are supposed to simplify the error handling model based on the assumption that in most cases,
a function that detected an error can&#39;t handle it, and has to propagate it to the caller. Finally,
a &quot;high-level&quot; enough caller is reached and actually makes a decision (pops up an error message, tries a different
action, etc.).
</p>

<p>
Despite its promises, this approach has inherent problems. There&#39;s a &quot;social&quot; problem -
with exceptions, people are not aware of the different errors that may happen in the code because most
of the code doesn&#39;t deal with errors. And when people rarely think about a particular aspect of an application,
ultimately this aspect is unlikely to be handled well. There&#39;s a more &quot;technical&quot; problem - functions essentially
doing nothing upon error except for propagating errors to the caller still can&#39;t be completely unaware of errors.
That&#39;s because they may need to release the resources they acquired before returning to the caller, which
may lead to <i>more</i> errors, which must also be handled. Finally, in practice exception support has run-time overhead, and very
significant code size overhead, even if exceptions are never raised at run time, and even if they are <i>not mentioned</i> in your code.
C++ devotees may claim otherwise; you can check by compiling your code with and without exception support (if your compiler
doesn&#39;t have such a flag, compile code as C and as C++ instead). This is unacceptable in resource-constrained systems.
</p>

<p>
Still, in many cases, the benefits of exceptions are more important than their problems. For example, if your
language manages memory automatically, the problem of releasing acquired resources becomes a small one (you only
have to care about files, etc., which are a tiny part of the &quot;resources&quot; used by a program - most of the
&quot;resources&quot; are memory). If your language throws exceptions when you violate its rules (for example, upon
out-of-bounds array access), these exceptions will help you find lots of bugs, especially if you can get the call stack
from an exception. If the purpose of an application is automated testing, and/or it&#39;s used as a quick-and-dirty
internal tool as opposed to a product for an end user, this kind of exceptions is all you need to handle errors of
almost all kinds. In some languages, you can even resume the execution from the point where the exception was
raised after fixing the problem at the point where it was caught.
</p>

<p>
C++ exceptions offer none of these features. &quot;Exception-safe&quot; C++ code <a href="fqa.html#fqa-17.3">can't handle errors</a> which happen
when it tries to release resources; &quot;exception-unsafe&quot; C++ code will <a href="fqa.html#fqa-16.1">leak</a> resources, most frequently memory; and once you throw
an exception, the call stack is <a href="fqa.html#fqa-17.7">lost</a>. This means that even separating your code to several processes and executing
code like <code>*(int*)0 = 0;</code> upon error is a better way to handle errors than C++ exceptions: at least the memory
is going to be reclaimed by the operating system, and you can typically have it save a snapshot of the process,
so that you can open it in a debugger and see where the error happened. A recommendation to &quot;ban&quot; exceptions
is probably over the edge, but think <i>a lot</i> before using C++ exceptions, <i>or</i> a feature that implicitly depends
on them, such as <a href="fqa.html#fqa-17.2">constructors</a> and <a href="fqa.html#fqa-13.1">overloaded operators</a>, which have no other way to report an error. What C++ calls
&quot;exceptions&quot; is as unlikely to give you the benefits people get from exceptions in other languages as what
C++ calls &quot;classes&quot; is <a href="fqa.html#fqa-7.1">unlikely</a> to give you the benefits of OO.
</p>


<a id="fqa-17.2"></a>
<h2>[17.2] How can I handle a constructor that fails?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.2">FAQ:</a></b> As you&#39;d guess from the location of this question in the FAQ, the answer is &quot;by throwing an exception&quot;. Alternatively,
you can mark the object as a &quot;zombie&quot; by using some kind of validity flag. You can then check that flag in the
calling code and maybe in the member functions of the object. The latter solution tends to &quot;get ugly&quot;.
</p>

<p>
<b class="FQA">FQA:</b> The inability to gracefully handle errors in C++ constructors is one good reason to <a href="fqa.html#fqa-10.17">avoid</a> constructors
that do more than nothing, and use initialization functions instead. And C++ exceptions are not a graceful way to
handle errors, <i>especially</i> in constructors. If your member object constructor throws an exception,
and you want to catch it in your constructor, the normally <a href="fqa.html#fqa-10.6">ugly</a> colon syntax gets much uglier.
</p>

<p>
By the way, the C++ standard library doesn&#39;t throw exceptions in constructors (except for the ones thrown by
<code>operator new</code>). For example, you are supposed to test whether <code>ofstream</code> objects are zombies when you pass
them a filename in the constructor.
</p>


<a id="fqa-17.3"></a>
<h2>[17.3] How can I handle a destructor that fails?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.3">FAQ:</a></b> Actually you can&#39;t - not beyond logging the problem to a file or the like. In particular, <i>do not</i> throw an exception.
The problem is that destructors are called when exceptions are thrown so that functions propagating errors to their
callers can clean up resources. Your destructor can also be called in such a situation. And when an exception is already
thrown, throwing another one will result in a call to <code>terminate()</code>, killing your process. Because you see, what else could C++ do?
There&#39;s an ambiguity: which exception out of the two do you want caught now?
</p>

<p>
Strictly speaking, you can make that &quot;do not throw exceptions in a destructor unless you are sure that it won&#39;t be called
as a result of an exception already thrown&quot;, but you can rarely be sure of that.
</p>

<p>
<b class="FQA">FQA:</b> That&#39;s right, <code>terminate()</code>. Solomon-style conflict resolution carried to the end.
See? Exceptions are not a graceful way to handle errors.
</p>

<p>
And &quot;don&#39;t throw exceptions in destructors&quot; actually means &quot;don&#39;t call functions in destructors unless you
are sure they don&#39;t throw an exception&quot;. The C++ compiler won&#39;t check for you, because it can&#39;t: the language
doesn&#39;t force a function to declare whether it throws exceptions.
</p>

<p>
This is one good reason to avoid destructors
doing more than nothing: like constructors and operators, they can&#39;t handle errors.
</p>


<a id="fqa-17.4"></a>
<h2>[17.4] How should I handle resources if my constructors may throw exceptions?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.4">FAQ:</a></b> Well, the destructor of your class will not get called, but the destructors of the successfully constructed
sub-objects will get called. Conclusion: you should have all the resources allocated by your constructors
assigned to sub-objects. For example, if you call <code>new</code> in a constructor, don&#39;t use a bare member pointer to hold
the result - use a smart pointer, like <code>std::auto_ptr</code>. You can also define your own smart pointer classes to
point to things like <a href="fqa.html#fqa-13.3">disk records</a>! Groovy!
</p>

<p>
And you can use <code>typedef</code> to make the syntax of using smart pointers easier.
</p>

<p>
<b class="FQA">FQA:</b> <b>WARNING</b> - cyclic dependency between C++ features detected! You see, exceptions are a must in this language
so that you can handle errors in all the functions which fail to look like functions, such as constructors &amp; operators.
Then it turns out that you need <i>constructors</i> to work with <i>exceptions</i> - unless each and every piece of memory
you acquire is not immediately assigned to some smart pointer, your code is not exception safe. This is known
as &quot;Resource Allocation Is Initialization&quot; (RAII) in the C++ community; it&#39;s supposed to be a <i>good</i> thing.
</p>

<p>
And smart pointers are no picnic, as are virtually all automatic devices with something like &quot;smart&quot;, &quot;simple&quot; or
&quot;fast&quot; in their name. Sure, you can use <code>typedef</code> to simplify the syntax. So can someone else; you&#39;ll end up with
many different type names for the same thing. This may annoy people, but it&#39;s perfectly OK with the compiler -
when it spits an <a href="fqa.html#fqa-35.17">error message</a>, it simply substitutes the full type names for all <code>typedef</code> names. But you can write a program to filter
the error messages...
</p>

<p>
Seriously, the syntax of smart pointers is the small problem. The big problem is their semantics. When you see
a bare pointer, you know how it works. But a smart pointer can work in <i>a lot</i> of ways. The <a href="http://boost.org">boost</a> libraries allow
you to instantiate hundreds of different smart pointer classes from a single template (which made it to TR1, so we&#39;re going to see it in the next version of the C++ standard). How are you going to
figure out whether your program manages resources correctly or not when it&#39;s littered with smart pointers of different kinds,
especially in case there&#39;s any non-trivial scenario there, like the cases when &quot;ownership&quot; (the right &amp; duty to dispose a resource)
is passed from object to object, or there are cyclic references in your code, or whatever?
</p>

<p>
When every single piece of software is &quot;smart&quot;, and you can&#39;t trust things like <code>*p</code> and <code>p-&gt;x</code>, the software
becomes unmanageable.
</p>


<a id="fqa-17.5"></a>
<h2>[17.5] How do I change the string-length of an array of <code>char</code> to prevent memory leaks even if/when someone throws an exception?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.5">FAQ:</a></b> If you want to work with strings, use something like <code>std::string</code> instead of <code>char*</code>. Otherwise, there&#39;s lots
of exceptions to catch, and lots of code to manage memory.
</p>

<p>
<b class="FQA">FQA:</b> The FAQ is right about one thing - <code>char*</code> is a nasty kind of string, and using it for text processing is very
tedious. If you&#39;re doing anything not entirely trivial with strings, <code>std::string</code> is better than <code>char*</code>; using
a different language than C++ for text processing, one with a good built-in string type, is still better.
</p>

<p>
However, the part with exceptions really comes from <code>operator new</code>, not from <code>char*</code>. You can use <code>malloc</code> instead, or
configure your compiler to disable exceptions.
</p>


<a id="fqa-17.6"></a>
<h2>[17.6] What should I throw?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.6">FAQ:</a></b> C++ allows you to throw objects of arbitrary types; however, you probably shouldn&#39;t throw objects of built-in
types. For example, you can derive all your exception classes from <code>std::exception</code>, and throw temporary objects
of your classes.
</p>

<p>
<b class="FQA">FQA:</b> Yep, C++ allows to throw anything. Too bad you can&#39;t really <i>catch</i> it later. The only way to catch an arbitrary exception
is to use <code>catch(...)</code>, which doesn&#39;t let you find out what was thrown from where, and will even catch
<i>illegal memory access</i> on some systems. This makes finding code like <code>throw &quot;C++ is so grand - you can throw anything!!&quot;;</code>
a lot of fun (you have to find it on occasions when the uncaught exception crashes your program).
</p>

<p>
The FAQ&#39;s advice is thus a good one, as opposed to the language decision to allow to throw anything - a typical example
of the twisted notion of &quot;generality&quot; used throughout the language design. This decision is completely incomprehensible
unless you realize that there&#39;s a basic axiom in C++: the language must not force the compiler writer to treat any class
specially. For example, having a common base class for all user-defined classes which have at least one <code>virtual</code> function could
be quite handy, but it&#39;s incompatible with this implicit axiom. What did the C++ designers gain from following this
bizarre rule? Apparently nothing, except for an illusion of &quot;generality&quot;, whatever that means.
</p>


<a id="fqa-17.7"></a>
<h2>[17.7] What does <code>throw;</code> (without an exception object after the <code>throw</code> keyword) mean? Where would I use it?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.7">FAQ:</a></b> It means &quot;throw the last caught exception&quot;. It may be handy to catch an exception object, add some context information
and rethrow it; this way you get something like a stack trace. This feature also allows you to factor out several exception
handlers into a function called from a <code>catch(...)</code> block. Inside the function, you list the handlers for various special
cases and prefix them with <code>try { throw; }</code>.
</p>

<p>
<b class="FQA">FQA:</b> Rethrowing the last exception is a useful feature, and many languages have it. It would be equally useful in C++ if C++
exceptions were any good. In particular, having to use this kind of feature throughout the code to get a <i>call stack</i>
is an insult to the language user. Unless it&#39;s some kind of &quot;logical&quot; call stack (context information not equivalent to
the list of C++ functions you&#39;d see in a debugger at the point where the exception was thrown), call stacks should be
provided by the language.
</p>

<p>
If you are using C++ and want to figure out the current call stack, it may be better to
rely on platform-specific tricks (reading the frame pointer using inline assembly and traversing the linked list pointed
by it, then translating the instruction pointers using a symbol table) than to litter your code with statements
duplicating the information that&#39;s already there.
</p>


<a id="fqa-17.8"></a>
<h2>[17.8] How do I throw polymorphically?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.8">FAQ:</a></b> Suppose you have a <code>BaseEx</code> exception class and a <code>DerivedEx</code> exception class, which is inherited from <code>BaseEx</code>.
Than the following code might not work as you expect:
</p>

<pre>
void f(BaseEx&amp; e)
{
  throw e;
}
void g()
{
  DerivedEx e;
  try {
    f(e);
  }
  catch(DerivedEx&amp;) {
    std::cout &lt;&lt; &quot;derived exception caught&quot; &lt;&lt; std::endl;
  }
}
</pre>

<p>
The program will <i>not</i> enter the <code>catch</code> block because you didn&#39;t throw polymorphically. That is, the statement <code>throw e;</code>
throws the object <code>e</code> as a <code>BaseEx</code>, because that&#39;s the type of <code>e</code> in that context; once an object is thrown as a
<code>BaseEx</code>, it will not get caught as a <code>DerivedEx</code>. If you prefer the other behavior, you can &quot;easily get it&quot; by having a
<code>virtual void raise() { throw *this; }</code> in your base class <i>and</i> your derived class, and calling <code>e.raise();</code> instead of
<code>throw e;</code>. This way <code>DerivedEx::raise()</code> is called, and in the context of that function <code>e</code> is of type <code>DerivedEx</code>.
</p>

<p>
<b class="FQA">FQA:</b> Let&#39;s see. You use C++ exceptions. Moreover, you have a hierarchy of exception classes. Moreover, you <i>pass exception
objects to functions</i>, in a way relying on an <i>implicit upcast</i>. Looks like you have lots of confidence in your knowledge of
C++ features. But along comes C++ and beats your common sense once again. The startling inconsistency of the language is
almost a virtue: maybe this time you will learn the value of simplicity and write something readable.
</p>

<p>
The behavior of <code>throw</code>, which looks at the static type of its argument expression, is somewhat surprising considering the
behavior of <code>catch</code>, which does &quot;respect&quot; inheritance (to the extent made possible by <code>throw</code>). In practice, it is probably
better to remove some of the complexity in the example rather than add more complexity by mixing the dynamic binding
of <code>virtual</code> with the static binding of <code>throw</code>. A human might need to understand the code, you know.
</p>

<p>
If you do want
to memorize the quirks of C++, try to warp your mind to think in terms used by the compiler construction peanut gallery.
From this perspective, the behavior of <code>throw</code> and <code>catch</code> <i>is</i> consistent: both only look at things known at compile time
(the relationships between classes), and ignore things only known at run time (the actual type of an object). Basically
all of C++ behaves this way except for <code>virtual</code>, <code>dynamic_cast</code> and <code>typeid</code>. I think.
</p>


<a id="fqa-17.9"></a>
<h2>[17.9] When I throw this object, how many times will it be copied?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.9">FAQ:</a></b> Zero or more. There&#39;s no universal answer. The compiler has to make sure a thrown object provides a copy constructor,
even if it doesn&#39;t actually copy anything.
</p>

<p>
<b class="FQA">FQA:</b> If you care about performance, C++ exceptions are probably no good for you. Exception support translates to a huge
mountain of code in your executable, and slows down function calls throughout your program. If you didn&#39;t care about
performance, you wouldn&#39;t ask this question. If you <i>think</i> that you <a href="fqa.html#fqa-10.9">care</a> about performance, but never actually measure
it or look at the performance implications of the techniques you use in your code, feel free to entertain yourself with
any fake answer that suits your emotional needs.
</p>


<a id="fqa-17.10"></a>
<h2>[17.10] Exception handling seems to make my life more difficult; clearly <i>I&#39;m</i> not the problem, am I??</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.10">FAQ:</a></b> <i>Of course</i> you can be the problem!
</p>

<p>
Here are some habits that may prevent you from utilizing the power of C++ exception handling:
</p>

<ul>
<li> <i>Return codes style</i>: people may put try blocks around every function call as if exceptions were error codes. </li>
<li> <i>The Java style</i>: using try/finally instead of RAII, cluttering the code with clean-up statements. </li>
<li> <i>Organizing exceptions around the location of the error rather than its reason</i>: this way you need to handle
the same error many times and convert between types of exceptions. </li>
<li> <i>Categorizing errors using data members of exception classes rather than types</i>: this way you catch more errors
than you can handle in the given <code>catch</code> blocks, and rethrow exceptions after a test. </li>
<li> <i>Using different exception classes in different subsystems</i>: the FAQ decides to repeat the point before
previous, probably to create an impression that there are so many wrong mindsets out there. </li>
<li> <i>Using bare pointers instead of smart pointer classes</i>: a special case of avoiding RAII, admits the FAQ, but
it can&#39;t fight the temptation to list yet another &quot;wrong mindset&quot;. </li>
<li> <i>Confusing bugs with run time errors</i>: if someone passes a null pointer to a function when that&#39;s illegal,
the code must be fixed. Throwing an exception without fixing the calling code doesn&#39;t solve the problem. </li>
</ul>

<p>
There are other wrong mindsets as well.
</p>

<p>
<b class="FQA">FQA:</b> Yeah, you know how it is with those humans. They always <a href="fqa.html#fqa-12.2">fail to realize</a> <i>they</i> are the problem, and keep asking the
wrong questions. You give them a helpful and powerful language, and all they do is shooting themselves in the feet. Clearly
it&#39;s their flawed minds that must be fixed.
</p>

<p>
Let&#39;s look a little closer at the impressive list of &quot;wrong mindsets&quot; compiled by the FAQ:
</p>

<ul>
<li> <i>Return codes style</i> is surely a wrong way to use exceptions, but it&#39;s one of the best ways to use <i>C++ exceptions</i>,
because otherwise the chance to manage resources correctly is not very high. Of course using real return codes is somewhat
cleaner, but what if exceptions are thrown by third-party libraries? </li>
<li> <i>The Java style</i> is suited quite well to a managed environment like Java, because most of the so-called resources
are in fact <i>memory</i>, and you only need try/finally blocks for stuff like files, of which there are few. This style
is problematic in C++ which <a href="fqa.html#fqa-16.1">lacks garbage collection</a>, but so is <a href="fqa.html#fqa-17.4">RAII</a> which forces you to wrap everything with
&quot;smart pointers&quot; in a language which
only has built-in dumb pointers. The truth is that with C++ exceptions, you can&#39;t win. </li>
<li> <i>Organizing exceptions around the location of the error rather than its reason</i>: suppose you have 2 parsers in
your system. Would you prefer a single <code>ParseError</code> exception, or 2 separate classes, <code>HtmlParseError</code> and
<code>ConfigFileParseError</code>? Two different modules may raise exceptions for <i>similar</i> reasons, but rarely <i>the same</i> reason -
or else why are they different modules? An obvious exception to this rule are errors detected at the language level,
things like <code>ArrayIndexOutOfBoundsException</code>. Luckily, the C++ language run time environment does not detect errors,
so we don&#39;t need to discuss this kind of thing. </li>
<li> <i>Categorizing errors using data members of exception classes rather than types</i> is not necessarily bad. C++ is
centered around the <a href="fqa.html#fqa-15.1">assumption</a> that you can represent almost anything using types (class hierarchies or template &quot;pattern matching&quot;)
more than any other popular statically typed language. However, this assumption is frequently refuted by reality,
and sticking to it is counter-productive in many cases. For instance, if a subsystem throws exceptions of a single class,
and you figure out the kind of error from looking at the object members or even inspecting error strings, you may end
up with less problems compared to the case where you have several dozens of classes in your exception inheritance tree.
This is a special case where modeling an aspect of your program using the language static type system may or may not be
optimal. </li>
<li> <i>Using different exception classes in different subsystems</i>: WOW, this is so <i>nasty</i>! Of course all subsystems
should share exception classes and other important common types. All subsystems of all systems in the world should be written
in close coordination between the implementers. This way, we&#39;ll finish the Tower of Babel in no time! That&#39;s why a
language should have no good way to pass an object of arbitrary type through a &quot;subsystem&quot;.
Trust us: we are the people advocating a language without a <i>common string type</i>.
We sure know a thing or two about the issue. </li>
<li> <i>Using bare pointers instead of smart pointer classes</i>: how about starting with the language and the standard
library? When <code>operator new</code> returns a smart pointer, and <code>&quot;abc&quot;</code> has the type <code>std::string</code>, we&#39;ll have something
to discuss. Until then, why should anyone manually emulate a high-level language on top of a low-level one throughout
one&#39;s code? </li>
<li> <i>Confusing bugs with run time errors</i>: this has absolutely nothing to do with exceptions. It&#39;s equally applicable
to any run time error handling strategy. Unless, of course, your environment throws exceptions upon events like null pointer dereferencing,
which C++ doesn&#39;t. </li>
</ul>


<a id="fqa-17.11"></a>
<h2>[17.11] I have too many try blocks; what can I do about it?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/exceptions.html#faq-17.11">FAQ:</a></b> Maybe you have a &quot;return codes mindset&quot; even though syntactically you use exceptions. There are many special cases
of this problem in which you can organize the code differently to reduce the amount of try blocks (the FAQ lists several cases).
If you can&#39;t solve the problem yourself, get a mentor.
</p>

<p>
<b class="FQA">FQA:</b> Alternatively, you can stop throwing C++ exceptions so you won&#39;t have to catch them.
</p>

<a id="fqa-const"></a><h1>Const correctness</h1>
<p>
This is about the <code>const</code> keyword, which makes you write your program twice (or more, depending on your luck).
</p>

<ul>
<li><a href="fqa.html#fqa-18.1">[18.1] What is &quot;<code>const</code> correctness&quot;?</a></li>
<li><a href="fqa.html#fqa-18.2">[18.2] How is &quot;<code>const</code> correctness&quot; related to ordinary type safety?</a></li>
<li><a href="fqa.html#fqa-18.3">[18.3] Should I try to get things <code>const</code> correct &quot;sooner&quot; or &quot;later&quot;?</a></li>
<li><a href="fqa.html#fqa-18.4">[18.4] What does &quot;<code>const Fred* p</code>&quot; mean?</a></li>
<li><a href="fqa.html#fqa-18.5">[18.5] What&#39;s the difference between &quot;<code>const Fred* p</code>&quot;, &quot;<code>Fred* const p</code>&quot; and &quot;<code>const Fred* const p</code>&quot;?</a></li>
<li><a href="fqa.html#fqa-18.6">[18.6] What does &quot;<code>const Fred&amp; x</code>&quot; mean?</a></li>
<li><a href="fqa.html#fqa-18.7">[18.7] Does &quot;<code>Fred&amp; const x</code>&quot; make any sense?</a></li>
<li><a href="fqa.html#fqa-18.8">[18.8] What does &quot;<code>Fred const&amp; x</code>&quot; mean?</a></li>
<li><a href="fqa.html#fqa-18.9">[18.9] What does &quot;<code>Fred const* x</code>&quot; mean?</a></li>
<li><a href="fqa.html#fqa-18.10">[18.10] What is a &quot;<code>const</code> member function&quot;?</a></li>
<li><a href="fqa.html#fqa-18.11">[18.11] What&#39;s the relationship between a return-by-reference and a <code>const</code> member function?</a></li>
<li><a href="fqa.html#fqa-18.12">[18.12] What&#39;s the deal with &quot;<code>const</code>-overloading&quot;?</a></li>
<li><a href="fqa.html#fqa-18.13">[18.13] What do I do if I want a <code>const</code> member function to make an &quot;invisible&quot; change to a data member?</a></li>
<li><a href="fqa.html#fqa-18.14">[18.14] Does <code>const_cast</code> mean lost optimization opportunities?</a></li>
<li><a href="fqa.html#fqa-18.15">[18.15] Why does the compiler allow me to change an <code>int</code> after I&#39;ve pointed at it with a <code>const int*</code>?</a></li>
<li><a href="fqa.html#fqa-18.16">[18.16] Does &quot;<code>const Fred* p</code>&quot; mean that <code>*p</code> can&#39;t change?</a></li>
<li><a href="fqa.html#fqa-18.17">[18.17] Why am I getting an error converting a <code>Foo**</code> to <code>const Foo**</code>?</a></li>
</ul>

<a id="fqa-18.1"></a>
<h2>[18.1] What is &quot;<code>const</code> correctness&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.1">FAQ:</a></b> Oh, that&#39;s a great thing. You declare an object as <code>const</code> and prevent it from being modified.
</p>

<p>
For example, if you pass a <code>std::string</code> object to a function by <code>const</code> pointer or reference, the function
won&#39;t modify it and it won&#39;t be copied the way it happens when the object is passed by value.
</p>

<p>
<b class="FQA">FQA:</b> Interesting. What about vector of pointers to objects? Let&#39;s see. If the vector itself is declared
<code>const</code> (as in <code>const std::vector&lt;T*&gt;</code>), then you can&#39;t modify the vector, but you can modify the objects.
If the pointers are declared <code>const</code> (as in <code>std::vector&lt;const T*&gt;</code>), then you can modify the vector,
but not the objects. Now suppose you have a vector of non-<code>const</code> objects, and you want to pass them to a function
that accepts a <code>const</code> vector of <code>const</code> objects. Oops, can&#39;t do that - the vectors are two different unrelated types
as far as the compiler is concerned (no, C++ weenies, it actually <a href="fqa.html#fqa-18.17">doesn't</a> make sense, think again). You&#39;ll have to create a temporary vector of the right type and copy
the pointers (which will compile just fine since <code>T*</code> is silently convertible to <code>const T*</code>).
</p>

<p>
That&#39;s what <code>const</code> correctness is all about: increasing the readability of your program and protecting
you from errors without any performance penalties.
</p>

<p>
By the way, not using <code>const</code> in C++ is quite likely <i>not</i> a very good idea. Of all questionable C++ features, <code>const</code> probably
does the most visible damage when avoided. Any piece of code using <code>const</code> forces every other piece touching it to use
<code>const</code>, or else you won&#39;t be able to work with the objects it gives you. And here&#39;s the funny part: every
piece of code <i>not</i> using <code>const</code> forces every other piece touching it <i>to not use it, either</i> - or else you
won&#39;t be able to pass objects to it. So if you have one <code>const</code> particle and one anti-<code>const</code> particle,
there&#39;s a big shiny explosion of <code>const_cast</code> in your code. Since <code>const</code> is hard-wired into the
language (no way to pass a temporary to a function that gets a non-const reference, for example) and the standard library
(<code>iterator</code> and <code>const_iterator</code>), using <code>const</code> is usually a safer bet than avoiding it.
</p>


<a id="fqa-18.2"></a>
<h2>[18.2] How is &quot;<code>const</code> correctness&quot; related to ordinary type safety?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.2">FAQ:</a></b> It&#39;s one form of type safety. You can think about <code>const std::string</code> as an <i>almost</i> separate type that lacks
certain operations of a string, like assignment. If you find type safety useful, you&#39;ll also like <code>const</code> correctness.
</p>

<p>
<b class="FQA">FQA:</b> It&#39;s related to ordinary type safety in a pretty complicated way. <code>const</code> and <code>volatile</code> are special cases
in the type system - they are &quot;type qualifiers&quot;. The relation between a qualified type and a non-qualified type
is different from any other relation between types in the language. This is one of the very many complications
in the implicit conversion and overload resolution rules.
</p>

<p>
It works smoothly for the simple cases, especially if there are no other complications. It breaks pretty hard
whenever you have a pointer-like object. Pointers can get <i>two</i> const qualifiers, one for the pointer and one for the pointed values.
This is awkward and unreadable and when you have pointers to pointers and three const qualifiers, you may need
cryptic explicit casts, but at least there&#39;s syntax for all the levels of constness. With &quot;smart pointers&quot; (the
things you should stuff into <a href="fqa.html#fqa-17.4">every possible hole</a> because pointers are <a href="fqa.html#fqa-6.15">evil</a>), there&#39;s no such syntax. That&#39;s why
we have <code>iterator</code> and <code>const_iterator</code> - saying <code>const iterator</code> says that the iterator is immutable, but not
what it points to. Exercise: implement a vector-like class that can get the storage pointer from the user,
in a const-correct way that supports attaching both to constant and mutable storage areas.
</p>

<p>
And of course a vector of <code>const</code> pointers is compiled to a different bulk of (identical) assembly code
than a vector of mutable pointers. At least here the compiler is writing the same program twice, which is
better than having to do this yourself. Which also happens - <code>const_iterator</code> is one family of examples.
</p>


<a id="fqa-18.3"></a>
<h2>[18.3] Should I try to get things <code>const</code> correct &quot;sooner&quot; or &quot;later&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.3">FAQ:</a></b> As soon as possible, because when you add <code>const</code> to a piece of code, it triggers changes in every place
related to it.
</p>

<p>
<b class="FQA">FQA:</b> That&#39;s right. Since you can&#39;t get out of the tar pit, the best strategy is to climb right into the middle
and make yourself comfortable from the beginning. No kidding, I actually agree with the FAQ.
See also the advice <a href="fqa.html#fqa-18.1">above</a> about <i>not</i> avoiding <code>const</code>.
</p>


<a id="fqa-18.4"></a>
<h2>[18.4] What does &quot;<code>const Fred* p</code>&quot; mean?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.4">FAQ:</a></b> A pointer to a <code>const Fred</code> object. The object can&#39;t be changed, for example, you can&#39;t call methods not qualified
as <code>const</code>.
</p>

<p>
<b class="FQA">FQA:</b> Right. But don&#39;t count on it when you debug code. <code>const</code> can be cast away in a snap (pretty much like everything
else in C++), and there&#39;s the <code>mutable</code> keyword for creating members that can be modified by methods qualified as <code>const</code>.
And of course someone can have <i>another</i>, non-const pointer to the same <code>Fred</code> object. <i>And</i> the <code>const</code>-qualified methods may modify
data pointed by its member pointers and references or by pointers kept in things pointed by its member pointers, etc.
</p>

<p>
The pointer aliasing issue is one reason that the compiler <i>can&#39;t</i> really optimize code because it sees a pointer declared
as <code>const</code>. And when it <i>can</i> figure out there are no aliases, it <i>doesn&#39;t need</i> your const declarations to help it. You
can explain the difference between data flow analysis and type qualification to the next <a href="fqa.html#fqa-10.9">pseudo-performance-aware</a>
person who advocates declaring every local integer as <code>const</code>. See also a <a href="fqa.html#fqa-18.14">correct FAQ answer</a> to this question below.
</p>


<a id="fqa-18.5"></a>
<h2>[18.5] What&#39;s the difference between &quot;<code>const Fred* p</code>&quot;, &quot;<code>Fred* const p</code>&quot; and &quot;<code>const Fred* const p</code>&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.5">FAQ:</a></b> In the first example, the object is immutable. In the second example, the pointer is immutable. In the third example,
both are immutable.
</p>

<p>
<b class="FQA">FQA:</b> Um, right. Remember: <code>const</code> makes your programs readable.
</p>


<a id="fqa-18.6"></a>
<h2>[18.6] What does &quot;<code>const Fred&amp; x</code>&quot; mean?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.6">FAQ:</a></b> It&#39;s a reference to an immutable Fred object.
</p>

<p>
<b class="FQA">FQA:</b> Which is similar to a pointer to an immutable Fred object. However, the FAQ holds the <a href="fqa.html#fqa-8.6">"references are NOT pointers"</a>
religion (specifically, it belongs to the &quot;pointers are <a href="fqa.html#fqa-6.15">evil</a>&quot; faction), so it dutifully replicates the explanation given
in the <a href="fqa.html#fqa-18.4">answer</a> about the pointer case, replacing &quot;pointer&quot; with &quot;reference&quot;.
</p>


<a id="fqa-18.7"></a>
<h2>[18.7] Does &quot;<code>Fred&amp; const x</code>&quot; make any sense?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.7">FAQ:</a></b> No. It says that you can change the object, but not the reference. But you can never change a reference anyway, it will
always refer to a single object.
</p>

<p>
Don&#39;t write such declarations, it confuses people.
</p>

<p>
<b class="FQA">FQA:</b> So <a href="fqa.html#fqa-25.13">why does this compile</a>? Wait, I don&#39;t really want to know. Whether it&#39;s because they didn&#39;t bother to disallow it,
or because some special case of template instantiation (like when you add a <code>const</code> to a parameter type which is in fact a reference)
would fail or anything like that - that&#39;s just another lame excuse as far as a language user is concerned.
</p>


<a id="fqa-18.8"></a>
<h2>[18.8] What does &quot;<code>Fred const&amp; x</code>&quot; mean?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.8">FAQ:</a></b> It&#39;s equivalent to &quot;<code>const Fred&amp; x</code>&quot;. The question is - which form should you use? Nobody can answer this for <i>your</i>
organization without understanding <i>your</i> needs. The are lots of business scenarios, some producing the need for one
form, others for the other. The discussion takes a full screen of text.
</p>

<p>
<b class="FQA">FQA:</b> Yawn. Another <a href="fqa.html#fqa-7.8">stupid duplication</a> in C++.
</p>

<p>
Come <i>on</i>. What &quot;business scenarios&quot; can &quot;produce needs&quot; for a form of a <code>const</code> declaration? If your organization employs
people who can&#39;t memorize both forms or check what a declaration means, you have to admit they will drown in
C++ even if you somehow know for sure that in general they can program. C++ has <i>megatons</i> of syntax.
</p>


<a id="fqa-18.9"></a>
<h2>[18.9] What does &quot;<code>Fred const* x</code>&quot; mean?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.9">FAQ:</a></b> The FAQ replicates the previous answer, replacing &quot;reference&quot; with &quot;pointer&quot;. Probably the same <a href="fqa.html#fqa-8.6">religion</a> thing again.
</p>

<p>
<b class="FQA">FQA:</b> Yawn. Another <a href="fqa.html#fqa-18.6">stupid duplication</a> in the C++ FAQ.
</p>


<a id="fqa-18.10"></a>
<h2>[18.10] What is a &quot;<code>const</code> member function&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.10">FAQ:</a></b> It&#39;s declared by appending <code>const</code> to the prototype of a class member function. Only this kind of methods may be
called when you have a <code>const</code> object. Errors are caught at compile time, without any speed or space penalty.
</p>

<p>
<b class="FQA">FQA:</b> As discussed above, this <a href="fqa.html#fqa-18.2">breaks into little pieces</a> when your class is similar to a pointer in the sense that
a user can change both the state of your object and use your object to change some other state. As to the speed
and space penalty, you may check the symbol table of your program if you want to know how many functions were
<a href="fqa.html#fqa-35.10">generated twice from a single template</a> because of <code>const</code> and non-<code>const</code> template parameters. Then you can count
the functions having identical code except for extra <code>const</code> qualifiers in some versions, but not others.
</p>


<a id="fqa-18.11"></a>
<h2>[18.11] What&#39;s the relationship between a return-by-reference and a <code>const</code> member function?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.11">FAQ:</a></b> <code>const</code> member functions returning references to class members should use a <code>const</code> reference. Many times the compiler
will catch you when you violate this rule. Sometimes it won&#39;t. You have to think.
</p>

<p>
<b class="FQA">FQA:</b> <i>Of course</i> you have to think about this complete and utter nonsense! Somebody has to, and the C++ designers didn&#39;t.
</p>

<p>
As usual with <code>const</code>, the compiler becomes <a href="fqa.html#fqa-18.2">dumb</a> when levels of indirection appear. For instance, if you keep a member
reference, the thing it points to is not considered part of the object. It&#39;s up to you to decide whether you want
to return this reference as <code>const</code> or non-<code>const</code> from your <code>const</code> member accessor. Both choices may eventually
lead to <code>const_cast</code>.
</p>


<a id="fqa-18.12"></a>
<h2>[18.12] What&#39;s the deal with &quot;<code>const</code>-overloading&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.12">FAQ:</a></b> You can have two member functions with a single difference in the prototype - the trailing <code>const</code>. The compiler
will select the function based on whether the <code>this</code> argument is <code>const</code> or not. For instance, a class with a subscript
operator may have two versions: one returning mutable objects and one returning <code>const</code> objects - in the latter version,
<code>this</code> is also qualified as <code>const</code>.
</p>

<p>
<b class="FQA">FQA:</b> <i>Please try to avoid this feature</i>. In particular, get and set functions having the same name (<code>const</code>-overloaded)
are not a very good idea.
</p>

<p>
Having to replicate the code of a subscript operator just to add two <code>const</code> qualifiers - for the return value and
the <code>this</code> argument - is yet another example of <code>const</code> forcing you to write your program twice. Well, most likely
there are more problems where this one came from. A class with a subscript operator is a &quot;smart array&quot;,
probably not unlike <code>std::vector</code>, so you&#39;ll end up with much more replicated code - an <code>iterator</code> and a
<code>const_iterator</code> or some such.
</p>


<a id="fqa-18.13"></a>
<h2>[18.13] What do I do if I want a <code>const</code> member function to make an &quot;invisible&quot; change to a data member?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.13">FAQ:</a></b> There are legitimate use cases for this - that would be when a user doesn&#39;t see the change using the interface
of the class. For example, a set class may cache the last look-up to possibly speed up the next look-up.
</p>

<p>
Use the <code>mutable</code> keyword when you declare the members you want to change this way. If your compiler doesn&#39;t have
<code>mutable</code>, use <code>const_cast&lt;Set*&gt;(this)</code> or the like. However, try to avoid this because it can lead to undefined behavior
if the object was originally declared as <code>const</code>.
</p>

<p>
<b class="FQA">FQA:</b> Most compilers probably support <code>mutable</code> today, but you may still need <code>const_cast</code> because the tweaks to the
type system supporting <code>const</code> <a href="fqa.html#fqa-18.2">break in many cases</a>. Which may be a problem combined with the fact that
<code>const_cast</code> is not designed to work with objects declared as <code>const</code> (as opposed to those declared non-constant but passed to a function by <code>const</code> reference or pointer).
</p>

<p>
There are numerous reasons making <code>const_cast</code> safer in practice than in theory. People rarely declare objects as <code>const</code>.
Compiler writers are unlikely to add special cases to their compiler to support <code>const</code> objects of C++ classes because it&#39;s hard work
that is unlikely to pay off. For example, allocating a global <code>const</code> C-style structure with an aggregate initializer in read-only
memory is easy. Doing the same for a C++ class with a constructor is hard because the constructor must be able to
write to the object upon initialization. So you&#39;d have to use writable memory you later make read-only, which is not
typically supported by object file formats and operating systems. Or you could translate C++ code to a C-style aggregate
initializer, spending lots of effort to only handle the cases when the compiler can <a href="fqa.html#fqa-9.1">inline</a> the code of the constructors.
</p>

<p>
However, there is no simple rule making it &quot;very close to impossible&quot; for a compiler writer to use the opportunity
provided by the standard and implement <code>const</code> objects differently from other objects. In the case of <a href="fqa.html#fqa-18.4">optimizing</a>
the dereferencing of <code>const</code> pointers, such a rule does exist (there might be other, non-<code>const</code> pointers to the same location).
But in the case of objects declared <code>const</code>, there <i>should</i> be no such pointers.
</p>

<p>
The fact that the compiler is allowed
to work under this assumption could be great if it were more likely to actually yield performance benefits, and
if <code>const</code> worked to an extent making the use of <code>const_cast</code> unnecessary. The current state of affairs just
creates another source of uncertainty for the programmer.
</p>


<a id="fqa-18.14"></a>
<h2>[18.14] Does <code>const_cast</code> mean lost optimization opportunities?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.14">FAQ:</a></b> Theoretically, yes. In practice, no. If a compiler knows that a value used in a piece of code
is not modified, it can optimize the access to that value, for example, fetch it to a machine register.
However, the compiler can&#39;t be sure that a value pointed by a <code>const</code> pointer is not modified because
of the aliasing problem: there can be other pointers to the same object, not necessarily constant.
Proving the opposite is almost always impossible.
</p>

<p>
And when the compiler can&#39;t prove it, it can&#39;t speed up the access to the value. For example, if it
uses the value it fetched to a register after someone modified it in the original memory location,
the compiler changes the meaning of the program because it uses an outdated value.
</p>

<p>
<b class="FQA">FQA:</b> Three cheers to the FAQ! No, really, this time the answer describes the actual state of affairs.
You understand why I&#39;m so deeply touched if you met some of <a href="fqa.html#fqa-18.4">the many C++ users</a> who
give a different answer to this question, and know their <a href="fqa.html#fqa-10.9">ways</a> to reason about performance.
</p>

<p>
I think the answer is &quot;no&quot; in theory, too, because basically the compiler has to figure out which parts of
the code modify the data, and if it knows the data won&#39;t get modified while this piece of code is running, it can use
this fact, and otherwise it can&#39;t, so what difference do your <code>const</code>-qualifications make? But let&#39;s
say I&#39;m not really sure, and anyway, it&#39;s not the time to argue about the exact phrasing when once in
a lifetime a realistic statement appears about the performance of C++ code.
</p>

<p>
The thing that is worth noting is that aliasing problems impede the performance of &quot;generic&quot; libraries, not just compilers.
For example, consider <code>vector&lt;T&gt;::push_back()</code>. The vector will try to append the object to its storage.
If there&#39;s no free space left, it will allocate a larger chunk, copy the old objects, and then append the
new one. The new object is thus copied once (from wherever it was into the vector storage), right?
</p>

<p>
But what if the object <a href="fqa.html#fqa-12.2">is itself located in the old chunk</a>, and <code>vector</code> tries to be efficient and use <code>realloc</code>, which
may or may not free the old memory? The object may be wiped out by <code>realloc</code>. Very good, then, <code>vector</code>
creates <i>another</i> copy. Hop 1 - from the parameter to a temporary, hop 2 - from a temporary to the vector storage
and everyone is happy - after a certain amount of clock cycles.
</p>

<p>
&quot;Theoretically, yes. In practice, no.&quot; Quite a nice summary of C++.
</p>


<a id="fqa-18.15"></a>
<h2>[18.15] Why does the compiler allow me to change an <code>int</code> after I&#39;ve pointed at it with a <code>const int*</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.15">FAQ:</a></b> Because when you point to something with a <code>const</code> pointer, this only means that you can&#39;t
use that pointer to change the object. It doesn&#39;t mean the object can&#39;t be changed at
all, because it can be accessible in other ways, not only through this pointer.
</p>

<p>
<b class="FQA">FQA:</b> Exactly; it&#39;s related to the previous FAQ. Surprisingly for C++, it even makes sense.
After all, when the object is <i>declared</i>, it seems like the right place to say what can be done with it.
But if anyone can take an existing object
and point to it and thus redefine what can be done with it, it&#39;s just weird, and can&#39;t really
work, because it could be done from many places in incompatible ways.
</p>


<a id="fqa-18.16"></a>
<h2>[18.16] Does &quot;<code>const Fred* p</code>&quot; mean that <code>*p</code> can&#39;t change?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.16">FAQ:</a></b> No, for example, it could change through a non-constant <code>Fred* q</code> pointing to the same object.
</p>

<p>
<b class="FQA">FQA:</b> This question is just like the previous one.
</p>


<a id="fqa-18.17"></a>
<h2>[18.17] Why am I getting an error converting a <code>Foo**</code> to <code>const Foo**</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/const-correctness.html#faq-18.17">FAQ:</a></b> It would be &quot;invalid and dangerous&quot;! Suppose <code>Foo**</code> points to an array of pointers, which
can be used to modify the pointed objects. Suppose C++ would allow to pass this array to a function
which expects <code>const Foo**</code> - an array of pointers which <i>can&#39;t</i> be used to modify the pointed objects.
</p>

<p>
Now suppose that this function fills the array with a bunch of pointers to <i>constant</i> objects.
This looks perfectly good in that context, because that&#39;s what the function was passed - an
array of pointers to constant objects. But what we&#39;ve got now is an array of pointers which can be used to modify those <code>const</code> objects,
because the declaration of the array does allow such modifications!
</p>

<p>
It&#39;s a good thing we get a compile time error instead. Don&#39;t use casts to work around this!
</p>

<p>
<b class="FQA">FQA:</b> Wonderful. But why are we discussing evil built-in pointers anyway? Let&#39;s talk about the smart
C++ array classes. Why can&#39;t I pass <code>std::vector&lt;T*&gt;&amp;</code> to a function expecting
<code>const std::vector&lt;const T*&gt;&amp;</code>? The function clearly says that it&#39;s not going to modify <i>anything</i>:
neither the vector nor the pointed objects. Why can&#39;t I pass my mutable vector of mutable objects
to a function that promises not to modify either of those?
</p>

<a id="fqa-inheritance-basics"></a><h1>Inheritance -- basics</h1>
<p>
This section outlines the C++ &quot;support&quot; for the OO concept of inheritance. Do not confuse C++ and OO.
</p>

<ul>
<li><a href="fqa.html#fqa-19.1">[19.1] Is inheritance important to C++?</a></li>
<li><a href="fqa.html#fqa-19.2">[19.2] When would I use inheritance?</a></li>
<li><a href="fqa.html#fqa-19.3">[19.3] How do you express inheritance in C++?</a></li>
<li><a href="fqa.html#fqa-19.4">[19.4] Is it OK to convert a pointer from a derived class to its base class?</a></li>
<li><a href="fqa.html#fqa-19.5">[19.5] What&#39;s the difference between <code>public</code>, <code>private</code>, and <code>protected</code>?</a></li>
<li><a href="fqa.html#fqa-19.6">[19.6] Why can&#39;t my derived class access <code>private</code> things from my base class?</a></li>
<li><a href="fqa.html#fqa-19.7">[19.7] How can I protect derived classes from breaking when I change the internal parts of the base class?</a></li>
<li><a href="fqa.html#fqa-19.8">[19.8] I&#39;ve been told to never use protected data, and instead to always use private data with protected access functions. Is that a good rule?</a></li>
<li><a href="fqa.html#fqa-19.9">[19.9] Okay, so exactly how should I decide whether to build a &quot;protected interface&quot;?</a></li>
</ul>

<a id="fqa-19.1"></a>
<h2>[19.1] Is inheritance important to C++?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/basics-of-inheritance.html#faq-19.1">FAQ:</a></b> Sure. That&#39;s the new thing OO adds on top of the more basic notion of abstract data types.
</p>

<p>
<b class="FQA">FQA:</b> It is, but for a slightly different reason. C++ uses inheritance to implement run-time polymorphism -
allow to use two objects of different classes in the same way. In order for this to work, the classes
(very roughly) must be inherited from a common base class.
</p>

<p>
It is also possible to implement polymorphism without inheritance. The system may simply allow you to
call the methods of an object without knowing its type, and the code will work if and only if the
object actually has the methods with the right name and arguments. Such systems may still support
inheritance, but it&#39;s less central for them.
</p>

<p>
OO systems encouraging polymorphism of the former kind are said to be &quot;statically typed&quot; in the sense
that you use objects through explicitly defined interfaces which are visible at compile time. This
approach is well-established and has many pros and cons (so does the other approach).
The C++ choice to use this approach is &quot;legitimate&quot; in the sense that it can yield a relatively usable &amp; consistent result.
</p>

<p>
However, C++ inheritance is designed to support many other things, leading to a less usable and less
consistent result. In particular, inheritance complicates the already complicated name look-up
in many ways unique to C++, and <a href="fqa.html#fqa-25.2">multiple inheritance</a> is quite a mess. On the other hand, many handy
features are left out, for example, there are no multimethods or dynamic type information allowing
to list the interfaces supported by a class (the latter is a special case of lacking reflection).
</p>


<a id="fqa-19.2"></a>
<h2>[19.2] When would I use inheritance?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/basics-of-inheritance.html#faq-19.2">FAQ:</a></b> As a tool for specifying the behavior of a system. People think in two dimensions: &quot;is a&quot;
and &quot;has a&quot;. For instance, a cat &quot;is a&quot; mammal and &quot;has a&quot; tail. Aggregation of data into
abstract data types supports the &quot;has a&quot; dimension. Inheritance adds support for the &quot;is a&quot; dimension.
</p>

<p>
<b class="FQA">FQA:</b> <i>When appropriate</i>. The FAQ itself does <a href="fqa.html#fqa-21.8">a pretty good
job</a> listing situations when something &quot;is a&quot; something else on an intuitive level, but using inheritance
is still wrong. Inheritance is a formal concept, and formal concepts don&#39;t map directly to English words.
</p>

<p>
Nobody knows the number of dimensions people use to think yet. For example, imagine a black cat. Does it
&quot;have a&quot; black color or &quot;is a&quot; black object? What if it&#39;s under a table - does it &quot;have a&quot; table above it
or &quot;is a&quot; thing under a table? Nobody knows what &quot;thinking&quot; is, and natural language can not be reduced
to a couple of dimensions. It &quot;has&quot; an unknown number of dimensions. It &quot;is a&quot; thing with an unknown number
of dimensions. Whatever &quot;dimension&quot; means.
</p>

<p>
A programming language is a tool people use to <i>program</i> machines. Even if we knew how thinking works, and
we could build a &quot;thinking machine&quot;, we&#39;d still need programming languages for <i>the other</i> machines. The
ones that are supposed to do what they are told, quickly, reliably and cheaply, as opposed to those
supposed to be creative thinkers. And a programming language, which must be precise, can not map directly
to a natural language, which is not.
</p>

<p>
To use inheritance or any other formal device, you have to understand exactly how it works. Luckily,
in most programming languages it&#39;s reasonably easy. And with C++, you can at least try to restrict
yourself to the subset you do understand.
</p>


<a id="fqa-19.3"></a>
<h2>[19.3] How do you express inheritance in C++?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/basics-of-inheritance.html#faq-19.3">FAQ:</a></b> By using the <code>: public</code> syntax, as in <code>class Car : public Vehicle { ... };</code>. <code>private</code> and <code>protected</code>
inheritance are different.
</p>

<p>
<b class="FQA">FQA:</b> Yeah, very different: replace the <code>public</code> keyword with the <code>private</code> or <code>protected</code> keyword.
The FAQ probably means that they are different because they are less related to OO semantically.
</p>

<p>
You may wonder what the colon syntax has to do with the concept of inheritance. Well, the
connection is obvious: there&#39;s no inheritance in C, and adding keywords to C++ reduces the
<a href="fqa.html#fqa-6.11">"compatibility"</a> with C, because the grammars of these languages prevent you from using keywords
as identifiers. Once again, punctuation comes to the rescue.
The other technique for retro-fitting features into the grammar is overloading keywords
(consider <code>static</code>).
</p>

<p>
To be fair, many languages have this problem with their grammar, and it&#39;s not a very big deal.
</p>


<a id="fqa-19.4"></a>
<h2>[19.4] Is it OK to convert a pointer from a derived class to its base class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/basics-of-inheritance.html#faq-19.4">FAQ:</a></b> For public inheritance - yes. By definition, an object of a derived class is an object of the base class.
</p>

<p>
<b class="FQA">FQA:</b> Moreover, if you don&#39;t think someone is going to do this, or you know it&#39;s not going to work
as expected, <a href="fqa.html#fqa-21.6">don't use inheritance</a>. The whole point of inheritance is to allow exactly that:
to have code that works with objects of a base class and in fact can be passed objects of
arbitrary derived classes. If making this possible is not what you want, inheritance doesn&#39;t
really help you and will confuse the users of your classes.
</p>

<p>
Of course public inheritance is also used for mind numbing template metaprogramming tricks, like having
a template derive from its own instantiation recursively, or from a template argument. The judgment
of whether this is a reasonable usage of a language feature is left to the reader.
</p>


<a id="fqa-19.5"></a>
<h2>[19.5] What&#39;s the difference between <code>public</code>, <code>private</code>, and <code>protected</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/basics-of-inheritance.html#faq-19.5">FAQ:</a></b> <code>private</code> is for class members and friends. <code>protected</code> is also for derived classes and their friends. <code>public</code> is
for everybody.
</p>

<p>
<b class="FQA">FQA:</b> Exactly. The only part having to do with inheritance is <code>protected</code>, and it&#39;s useful relatively rarely.
</p>


<a id="fqa-19.6"></a>
<h2>[19.6] Why can&#39;t my derived class access <code>private</code> things from my base class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/basics-of-inheritance.html#faq-19.6">FAQ:</a></b> It protects you from changes to the base class by not letting you rely on its implementation details.
</p>

<p>
<b class="FQA">FQA:</b> However, it doesn&#39;t protect you from recompilation of your derived classes when changes are made to
the base class (access control keywords are <a href="fqa.html#fqa-7.4">little more than comments</a> in C++). Keep that in mind when
you design interfaces, especially those which are supposed to be used outside of your team. If you want
to supply C++ interfaces, which is <a href="fqa.html#fqa-6.3">pretty daring</a> by itself, not exposing any base classes except pure
abstract ones (those having no data members) may be a good idea.
</p>


<a id="fqa-19.7"></a>
<h2>[19.7] How can I protect derived classes from breaking when I change the internal parts of the base class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/basics-of-inheritance.html#faq-19.7">FAQ:</a></b> Your class has two interfaces: <code>public</code> and <code>protected</code>. To protect your users, don&#39;t expose
data members. Similarly, you can protect the derived classes by not having <code>protected</code> data members;
provide <code>protected inline</code> accessors instead.
</p>

<p>
<b class="FQA">FQA:</b> Dear Design Guru! Listen carefully, and try to understand.
</p>

<p>
One. Writing get and set function for every member takes
time, and so does reading them. This time can instead be used to get something done.
</p>

<p>
Two. If you can get and set a member, it&#39;s pretty close to being public.
Any non-trivial representation change becomes impossible since the ability to set this particular member
is now a part of the contract.
</p>

<p>
Three. Having properties in the language - things that look like members
but are in fact accessors - doesn&#39;t hurt. Many languages have it, allowing to use plain members and
in the 0.1% of the cases when your class becomes very popular <i>and</i> you want to change it <i>and</i> you
can do it without breaking the contract, you can make the member a property. There&#39;s no reason for not
having this in C++ that&#39;s even remotely interesting to a language user.
</p>

<p>
If you know C++ programmers who are obsessed with useless wrapper code <i>and</i> performance they never measure,
the <code>protected inline</code> part is kinda funny.
</p>


<a id="fqa-19.8"></a>
<h2>[19.8] I&#39;ve been told to never use protected data, and instead to always use private data with protected access functions. Is that a good rule?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/basics-of-inheritance.html#faq-19.8">FAQ:</a></b> No, no, no - &quot;always&quot; rules don&#39;t work in the real world! You don&#39;t have time to make life
easy for everyone. Spend your time making it easy for the important people. People are not equal.
The important people are called &quot;customers&quot;.
</p>

<p>
<b class="FQA">FQA:</b> Thanks, that&#39;s just what I needed! You know, I was going to make life easier for <i>everyone</i>
by writing hordes of get and set functions. But now I can <i>prioritize</i> and only make life easier
for the important people.
</p>

<p>
Please your customers by writing 56% more get and set functions than your competitor using the newest
Visual Refactoring Tool today!
</p>

<p>
Actually, the FAQ does mention that you&#39;ll probably need more than get and set functions to really
&quot;protect the derived classes from changes&quot;. But the basic assumption that lots of layers
make life easy when you have time to create all those layers is still ridiculous. There are teams
out there that actually <i>have</i> lots of time to do a real world job, and turn a 500-line simple, working, fast
prototype program into 30K-line incomprehensible, broken, slow &quot;product&quot; because they think that
they are dealing with an <i>important</i> task, so now is the time to write piles of wrapper code.
</p>


<a id="fqa-19.9"></a>
<h2>[19.9] Okay, so exactly how should I decide whether to build a &quot;protected interface&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/basics-of-inheritance.html#faq-19.9">FAQ:</a></b> There are many useful guidelines, for example: grow up, don&#39;t do things that can jeopardize your
schedules, and only invest time in the things which will ultimately pay off.
</p>

<p>
<b class="FQA">FQA:</b> If you find this advice useful, here&#39;s more: don&#39;t be an idiot, be lucky, and avoid pushing sharp
objects into your body.
</p>

<p>
It&#39;s rather annoying that the C++ FAQ <i>dares</i> to tell people to be <a href="fqa.html#fqa-6.1">"practical"</a>. Why don&#39;t you add a third
useful built-in type to your language (we already have integers and floats), say, a string or
a dictionary, and then talk about the difference between theory and the real world?
</p>

<a id="fqa-inheritance-virtual"></a><h1>Inheritance -- virtual functions</h1>
<p>
This page is about <code>virtual</code> functions - a rare example of a C++ feature which is neither a part of C nor completely self-defeating.
</p>

<ul>
<li><a href="fqa.html#fqa-20.1">[20.1] What is a &quot;<code>virtual</code> member function&quot;?</a></li>
<li><a href="fqa.html#fqa-20.2">[20.2] How can C++ achieve dynamic binding yet also static typing?</a></li>
<li><a href="fqa.html#fqa-20.3">[20.3] What&#39;s the difference between how <code>virtual</code> and non-<code>virtual</code> member functions are called?</a></li>
<li><a href="fqa.html#fqa-20.4">[20.4] What happens in the hardware when I call a <code>virtual</code> function? How many layers of indirection are there? How much overhead is there?</a></li>
<li><a href="fqa.html#fqa-20.5">[20.5] How can a member function in my derived class call the same function from its base class?</a></li>
<li><a href="fqa.html#fqa-20.6">[20.6] I have a heterogeneous list of objects, and my code needs to do class-specific things to the objects. Seems like this ought to use dynamic binding but I can&#39;t figure it out. What should I do?</a></li>
<li><a href="fqa.html#fqa-20.7">[20.7] When should my destructor be <code>virtual</code>?</a></li>
<li><a href="fqa.html#fqa-20.8">[20.8] What is a &quot;<code>virtual</code> constructor&quot;?</a></li>
</ul>

<a id="fqa-20.1"></a>
<h2>[20.1] What is a &quot;<code>virtual</code> member function&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/virtual-functions.html#faq-20.1">FAQ:</a></b> The most important thing about C++ if you look from an OO perspective.
</p>

<p>
With <code>virtual</code> functions, derived classes can provide new implementations of functions from their base classes.
When someone calls a <code>virtual</code> function of an object of the derived class, this new implementation is called,
even if the caller uses a pointer to the base class, and doesn&#39;t even know about the particular derived class.
</p>

<p>
The derived class can completely &quot;override&quot; the implementation or &quot;augment&quot; it (by explicitly calling the base class implementation in addition to the new things it does).
</p>

<p>
<b class="FQA">FQA:</b> If you are new to OO, using C++ as your first example is not a very good idea. If you
still want to start learning about OO here, and you feel you didn&#39;t really understand the
very generic statements above, here&#39;s an example attempting to show why all this is
actually <i>useful</i>. Note: this FQA is unlikely to be the best OO tutorial on the web.
</p>

<p>
Suppose you have a program which plays movies in different formats. No matter what the format
is, you want to have the same interface (a window with a menu), options (resize the window, control the color balance...), etc.
Now, you can define a class <code>Movie</code> with <code>virtual</code> functions like <code>nextFrame(&amp;pixels,&amp;width,&amp;height)</code>.
Each format is implemented in a derived class like <code>MPEGMovie</code>, <code>DivXMovie</code>... The code implementing the interface, the options,
etc. can then work with <code>Movie</code> objects, calling the right <code>nextFrame</code> function without having stuff like <code>if(format==MPEG) { MPEG_nextFrame(...); } else if ...</code>
all over the place. The format-independent code is easier to read, and much easier to change when you want to add a new format, in fact
as easy as it gets: you don&#39;t have to change anything.
</p>

<p>
If this last sentence made you laugh, you&#39;ve probably seen how representation-specific a supposedly &quot;generic&quot; interface
turned out to be once someone actually tried to create a second or a third implementation. You can laugh silently, or you
can do it out loud, to soon find yourself surrounded by newbies cluttering their code with idiotic conditions (&quot;the wizard said that nothing is really generic anyway&quot;).
So let&#39;s forget the whole &quot;pseudo-generic&quot; issue for the moment and focus on the C++ flavor of polymorphism instead (to those who didn&#39;t know: hordes of languages have something like <code>virtual</code>, and normally it&#39;s something better).
</p>

<p>
<code>virtual</code> functions have their problems. The keyword itself is obscure, the <code>=0;</code> notation is even more so, you can&#39;t
look at a derived class and say which functions are <code>virtual</code> (the keyword is optional), and overloading makes it even
harder to see when a function actually overrides a base class implementation (forget a <code>const</code> in the prototype and it becomes an unrelated <code>virtual</code> function with the same name).
Seasoned OO pros might point out the lack of multimethods and invariants/contracts checking, and have other complaints that I no longer remember, but which
seemed valid when I did. Oh, and there&#39;s the poor RTTI and the non-existing reflection. It goes on and on.
</p>

<p>
However, compared to other C++ features, <code>virtual</code> functions are excellent. They make a very useful thing easy. You get
to type less compared to C, where you would have to create a &quot;vtable&quot; struct and then do things like <code>pThis-&gt;vptr-&gt;f((Base*)pThis, args)</code>
instead of the C++ <code>p-&gt;f(args)</code>. And this brevity does <i>not</i> come at the price C++ makes you to pay so promptly - there&#39;s
no compile time overhead.
</p>

<p>
Therefore, if you are a practitioner using C++, ignoring the <a href="fqa.html#fqa-10.9">"performance-oriented"</a> brain-washing (&quot;arrays of pointers to objects with virtual methods are soooo slow, arrays of structs with inline functions are soooo fast&quot;)
and using the single C++ feature that has a potential of doing less harm than good is very frequently the right thing to do.
Of course not using C++ for code characterized by complicated structure and dynamic behavior is an even better idea.
</p>


<a id="fqa-20.2"></a>
<h2>[20.2] How can C++ achieve dynamic binding yet also static typing?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/virtual-functions.html#faq-20.2">FAQ:</a></b> <i>Static typing</i> means that when a function (<code>virtual</code> or other) is called, the compiler checks that the function
call is valid according to the statically defined interfaces.
</p>

<p>
<i>Dynamic binding</i> means that the code generated from the statically checked function calls may actually call many different
implementations, and figures out the one to call at run time.
</p>

<p>
Basically C++ allows many things to be done upon a <code>virtual</code> function call, as long as these things follow a specified
protocol - the base class definition.
</p>

<p>
<b class="FQA">FQA:</b> It&#39;s important to keep in mind that the compiler can only check whether an implementation follows a protocol to a certain
extent. It is pretty easy to create a derived class which looks legitimate (it has an <code>insert</code> and a <code>find</code> method as specified in the base class),
but in fact it is not (because <code>insert</code> doesn&#39;t really insert anything to anywhere, and <code>find</code> doesn&#39;t find anything).
This will break the code using the derived class via pointers to base class objects
(this code will <code>insert</code> something and then won&#39;t <code>find</code> it and will crash). That&#39;s why the FAQ has a whole section on <a href="fqa.html#fqa-21.12">proper inheritance</a>.
</p>

<p>
The (natural) fact that you can&#39;t find all errors with static typing wouldn&#39;t be that bad if C++ didn&#39;t crash as hard as it does
(for instance, by doing run time boundary checking), and/or would support dynamic contract checking, and/or
had a clear type system that would make specifying interfaces less of a pain (currently you have a zillion troubles ranging from no built-in string type to the endless kinds of type relationships and conversion rules).
</p>

<p>
Dynamic binding is a critical feature to build extensible software, and all general-purpose programming languages have some form of it
(in particular, C has function pointers). Unlike dynamic binding, static typing is not strictly necessary, but it has
many benefits (the code may be easier for people to read and for compilers to validate and optimize due to the information specified in the types)
as well as many drawbacks (some things may be hard to model in a static type system, frequently there&#39;s more code to read and write, etc.).
At the language level, C++ doesn&#39;t support dynamic <i>typing</i> (as opposed to &quot;binding&quot;) at all, and its static type system is <a href="fqa.html#fqa-18.2">one of the worst</a>.
</p>

<p>
Some C++ programmers think (or feel) that their compiler does an incredible service of finding virtually all of their bugs.
Their hidden motives include the need to rationalize the <a href="fqa.html#fqa-9.3">amazingly long build cycles</a>, and to avoid writing test programs
(more verbose, ugly, boring C++ code - who wants to do that?!). You&#39;ll do yourself a favor by not catching their thinking habits.
</p>


<a id="fqa-20.3"></a>
<h2>[20.3] What&#39;s the difference between how <code>virtual</code> and non-<code>virtual</code> member functions are called?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/virtual-functions.html#faq-20.3">FAQ:</a></b> non-<code>virtual</code> functions are resolved at compile time. <code>virtual</code> functions are resolved at run time.
</p>

<p>
The compiler must generate some code to do the run-time resolution. This code must be able to look at an object
and find the version of the function defined by the class of the object. This is usually done by creating a table
of virtual functions for each class having them (the &quot;vtable&quot;). All objects of the class have an implicitly generated
member pointer (the &quot;vptr&quot;), initialized to point to the class vtable by all constructors.
</p>

<p>
To implement a virtual function call, the compiler generates code similar to that it would produce from the C expression
<code>(*p-&gt;vptr-&gt;func_ptr)</code>. That is, it dereferences the object pointer to fetch the vptr, then fetches the function pointer
from a fixed offset, then calls the function through the pointer.
</p>

<p>
The exact cost depends on complicated stuff like page faults, multiple inheritance, etc.
</p>

<p>
<b class="FQA">FQA:</b> In practice, the cost is almost never a big deal unless you call <code>virtual</code> functions in your &quot;innermost loops&quot;
(the code processing the most data). I&#39;m not saying the cost should be ignored - a good-looking generic design centered around virtual calls
in innermost loops is invalid for most practical purposes. I&#39;m just saying that you don&#39;t have to think about things like
page faults to figure out if you can afford <code>virtual</code> in this piece of code. The C++ implementation of polymorphism is pretty efficient.
</p>

<p>
One kind of price you pay for this efficiency is the <a href="fqa.html#fqa-7.4">instability</a> of your interfaces at the binary level. You <i>can</i>
add new derived classes to your system without recompiling old derived classes. But you <i>can&#39;t</i> add a virtual function
to a base class without such recompilation. This rules out straight-forward usage of virtual functions in many situations
(if you think recompilation has &quot;zero cost&quot;, try to get the vendors of your desktop software to recompile it so it runs
 on a different processor architecture).
</p>

<p>
Many OO languages avoid these problems. One way to do it is just-in-time compilation - instead of generating code fetching
the function pointer from a fixed vtable offset, wait until you see all the updated base class definitions at program load time
and then generate the offsets. Another option is to use less efficient, but more flexible look-up mechanisms, such as
hash tables - this is typically coupled with the lack of static typing, which has many benefits and drawbacks. Both
techniques avoid a huge amount of real-life problems with binary interface stability.
</p>

<p>
If you can&#39;t switch to a different OO language with better OO support (think about it - the interface stability is just
one aspect, you&#39;ll probably also get <a href="fqa.html#fqa-16.1">garbage collection</a>, <a href="fqa.html#fqa-35.12">faster build cycles</a>, and a ton of other useful things), you
can work around these problems in many ugly ways. For example, you can have a single <code>virtual</code> function getting
a string or a <code>void*</code> telling it what to do (a famous example of achieving binary-level stability this way is the <code>ioctl</code> system call of Unix-like systems).
Another approach is to add new classes for the new functions, and have the derived classes implement many different
abstract base classes (the COM <code>QueryInterface</code> function works this way). These things are not pretty, but they are
better than nothing, which is what <code>virtual</code> functions deliver when you need stable interfaces.
</p>

<p>
Don&#39;t be ashamed of yourself if you reach the conclusion that you have to do this. If &quot;performance-aware&quot; people
squeak something about it, try to get them busy with something else, like implementing <code>std::valarray</code> to actually compile
to fast code using SIMD instructions of the host processor, without creating <a href="fqa.html#fqa-13.10">temporary memory objects</a>. This should give you a couple of centuries long break.
</p>


<a id="fqa-20.4"></a>
<h2>[20.4] What happens in the hardware when I call a <code>virtual</code> function? How many layers of indirection are there? How much overhead is there?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/virtual-functions.html#faq-20.4">FAQ:</a></b> There&#39;s a lot of code listings explaining the previous answer in detail.
</p>

<p>
<b class="FQA">FQA:</b> By &quot;hardware&quot;, you probably meant &quot;binary-level software&quot; - for each popular binary instruction encoding there are
lots of variants of processors implementing it, and the processors are integrated into many different systems with all kinds
of memory architectures. Even when you write <i>assembly code</i>, you can&#39;t tell exactly how it&#39;s going to be executed,
so of course you can&#39;t with a higher-level language which can be compiled to assembly in many different ways.
</p>

<p>
As to levels of indirections - typically there are two, one to fetch the vptr from the object and another one to fetch
the function from the vtable. One other approach could be to save a level of indirection by keeping the vtable
inside the object &quot;by value&quot; instead of &quot;by pointer&quot; - but that makes the objects larger.
</p>

<p>
As the proponents of <code>virtual</code> methods correctly point out, some overhead is inevitable in the situations where you use
a <code>virtual</code> function, because you don&#39;t know what function to call at compile time. Of course different ways to implement
the decision making can have slightly different performance characteristics on a given platform. If you care about such
tiny differences though, you probably have to fix it at a higher level (such as moving the decision outside of the innermost loop at the cost of possibly replicating some of the common code).
Fiddling with the low level - implementing the decision - is lots of boring work (rewrite, measure, rewrite, measure...) with
little gain.
</p>


<a id="fqa-20.5"></a>
<h2>[20.5] How can a member function in my derived class call the same function from its base class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/virtual-functions.html#faq-20.5">FAQ:</a></b> For some a reason, a pretty low-level discussion follows. Name mangling, &quot;call-by-name&quot; vs &quot;call-by-slot-number&quot;, code listings
                                          with double underscores...
</p>

<p>
<b class="FQA">FQA:</b> In a <code>class Derived</code>, in a function <code>Derived::f()</code>, you can type <code>Base::f();</code> to call the <code>f</code> implementation from
your base class <code>Base</code>. The compiler will ignore the actual type of your object (at the low level - vtable and all that),
and call <code>Base::f</code> just the way non-<code>virtual</code> functions are normally called.
</p>

<p>
I think you can do that in every OO language. It&#39;s pretty natural.
</p>


<a id="fqa-20.6"></a>
<h2>[20.6] I have a heterogeneous list of objects, and my code needs to do class-specific things to the objects. Seems like this ought to use dynamic binding but I can&#39;t figure it out. What should I do?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/virtual-functions.html#faq-20.6">FAQ:</a></b> &quot;It&#39;s surprisingly easy&quot;, says the FAQ. This statement is followed by a surprisingly long answer.
</p>

<p>
<b class="FQA">FQA:</b> I don&#39;t know how &quot;surprising&quot; this is - that&#39;s the whole (the one and the only) point of polymorphism: to do
class-specific things to objects, without thinking how heterogeneous they are.
</p>

<p>
For this to work, have the classes
of those objects derive from a common base class (not extremely &quot;easy&quot; unless you planned ahead...). Then you can
run over the elements of <code>std::list&lt;Base*&gt;</code>, and call the virtual methods which do the class-specific things without
thinking about how many different classes the objects actually belong to, etc. For example:
</p>

<pre>
for(std::list&lt;Shape*&gt;::const_iterator p=shapes.begin(), e=shapes.end(); p!=e; ++p) {
  (*p)-&gt;draw(window);
}
</pre>

<p>
Off-topic: the STL way of saying <code>foreach p in shapes</code> is pretty ugly, isn&#39;t it?
</p>


<a id="fqa-20.7"></a>
<h2>[20.7] When should my destructor be <code>virtual</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/virtual-functions.html#faq-20.7">FAQ:</a></b> The rule of thumb is - when you have a <code>virtual</code> function. Strictly speaking, you need it when you want someone to be
able to derive classes from your class, create objects with <code>new</code>, and <code>delete</code> them via pointers to a base class.
</p>

<p>
<b class="FQA">FQA:</b> The situations when the rule of thumb is not good enough were not reported on our planet. Use this rule of thumb,
if only to suppress compiler warnings. Too bad the C++ compiler doesn&#39;t use the rule silently itself - it could
                           simply make the destructor <code>virtual</code> in these cases.
</p>


<a id="fqa-20.8"></a>
<h2>[20.8] What is a &quot;<code>virtual</code> constructor&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/virtual-functions.html#faq-20.8">FAQ:</a></b> It&#39;s an idiom allowing you to have a pointer to a base class and use it to create objects of the right derived class.
You can implement it by providing <code>virtual</code> functions like these:
</p>

<pre>
virtual Base* create() const;
virtual Base* copy() const;
</pre>

<p>
You implement them like this:
</p>

<pre>
Derived* Derived::create() const { return new Derived; }
Derived* Derived::copy() const { return new Derived(*this); }
</pre>

<p>
Note that we return <code>Derived*</code>, not <code>Base*</code> - it&#39;s called &quot;Covariant Return Types&quot;. Some compilers have it, some don&#39;t.
</p>

<p>
<b class="FQA">FQA:</b> Other languages have built-in support for these things. This is interesting
because of the <i>other</i> things they make possible, like serialization (without writing special code for each class). Roughly, this is called &quot;reflection&quot;: you can find all
methods of a class at run-time, including those that are not normally called as <code>virtual</code>, such as constructors
(which can&#39;t be <code>virtual</code> - you have to create an object <i>before</i> you can dispatch function calls based on its type).
Another option is to (recursively) get the list of members of a class and create/copy them. It&#39;s hard to imagine
how useful this is if most of your programming experience comes from working with C++.
</p>

<p>
Covariant return types are a nice joke (for an admittedly narrow audience though). C++ lets you tighten the specification of return values - which is perfectly
legitimate: our base class said we should return a <code>Base*</code>, and we surely implement the contract if we always return
a <code>Derived*</code>, which is in particular a <code>Base*</code>. <i>But</i> C++ doesn&#39;t let you <i>loosen</i> the specification of arguments,
which can be shown to be legitimate for symmetrical reasons.
</p>

<p>
Why? Because C++ has overloading, so when you declare a <code>virtual</code> function which looks just like a function
from your base class, but has any kind of changes to argument types, C++ thinks you create a new unrelated <code>virtual</code> function
rather than override the one from the base class. Since C++ has no overloading based on the function return type,
there&#39;s no symmetrical problem.
</p>

<p>
C++ has lots of kinds of static typing, but little consistency between them.
To be fair, other languages have similar interactions between overloading and dynamic binding, and some probably
copied them from C++. However, other languages rarely encourage design which depends on the availability of overloading
to work (like STL), and/or is based on the microscopic details of overload resolution mechanisms (like some of the boost libraries).
</p>

<a id="fqa-inheritance-proper"></a><h1>Inheritance -- proper inheritance and substitutability</h1>
<p>
This section is about using inheritance such that the code really works, not just compiles. Unlike most &quot;OO&quot;-related sections in the FAQ, much of the material is applicable to decent OO systems and not only to C++.
</p>

<ul>
<li><a href="fqa.html#fqa-21.1">[21.1] Should I hide member functions that were public in my base class?</a></li>
<li><a href="fqa.html#fqa-21.2">[21.2] Converting <code>Derived* -&gt; Base*</code> works OK; why doesn&#39;t <code>Derived** -&gt; Base**</code> work?</a></li>
<li><a href="fqa.html#fqa-21.3">[21.3] Is a parking-lot-of-<code>Car</code> a kind-of parking-lot-of-<code>Vehicle</code>?</a></li>
<li><a href="fqa.html#fqa-21.4">[21.4] Is an array of <code>Derived</code> a kind-of array of <code>Base</code>?</a></li>
<li><a href="fqa.html#fqa-21.5">[21.5] Does array-of-Derived is-not-a-kind-of array-of-Base mean arrays are bad?</a></li>
<li><a href="fqa.html#fqa-21.6">[21.6] Is a <code>Circle</code> a kind-of an <code>Ellipse</code>?</a></li>
<li><a href="fqa.html#fqa-21.7">[21.7] Are there other options to the &quot;<code>Circle</code> is/isnot kind-of <code>Ellipse</code>&quot; dilemma?</a></li>
<li><a href="fqa.html#fqa-21.8">[21.8] But I have a Ph.D. in Mathematics, and I&#39;m sure a Circle is a kind of an Ellipse! Does this mean Marshall Cline is stupid? Or that C++ is stupid? Or that OO is stupid?</a></li>
<li><a href="fqa.html#fqa-21.9">[21.9] Perhaps <code>Ellipse</code> should inherit from <code>Circle</code> then?</a></li>
<li><a href="fqa.html#fqa-21.10">[21.10] But my problem doesn&#39;t have anything to do with circles and ellipses, so what good is that silly example to me?</a></li>
<li><a href="fqa.html#fqa-21.11">[21.11] How could &quot;it depend&quot;??!? Aren&#39;t terms like &quot;Circle&quot; and &quot;Ellipse&quot; defined mathematically?</a></li>
<li><a href="fqa.html#fqa-21.12">[21.12] If <code>SortedList</code> has <i>exactly</i> the same public interface as <code>List</code>, is <code>SortedList</code> a kind-of <code>List</code>?</a></li>
</ul>

<a id="fqa-21.1"></a>
<h2>[21.1] Should I hide member functions that were public in my base class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.1">FAQ:</a></b> No, no, don&#39;t even think about it, <i>don&#39;t do that</i>, no. Your desire is probably the result of &quot;muddy thinking&quot;.
</p>

<p>
<b class="FQA">FQA:</b> With all due respect, it is your precious programming language that probably is the result of &quot;muddy thinking&quot;. The question talks
about overriding base class functions in the <code>private</code> section of your derived class. This is trivially and reliably
detectable at compile time. If you get so excited about how wrong it is, <i>why does it compile</i>?
</p>

<p>
Answer: in C++, <a href="fqa.html#fqa-25.13">random
things</a> compile and <a href="fqa.html#fqa-35.18">other random things</a> don&#39;t. The language definition is sloppy. What&#39;s that? You think the compiler writers
made their own job easy by making yours hard? No, C++ is probably the hardest language to compile among those popular today.
C++ is <i>pointlessly</i> sloppy.
</p>

<p>
The reason the FAQ gets so excited will become clear in <a href="fqa.html#fqa-21.6">the next answers</a>. Basically, when your derived class overrides
a function as <code>private</code>, you violate the substitutability principle: it is no longer true that an object of a derived
class fully supports the interface of the base class. However, technically the functions from the base class are still
accessible, because you can cast a pointer to a derived class object to the base class and call the function through the
vtable (pretty <i>muddy</i>, isn&#39;t it?).
</p>

<p>
People define overridden <code>virtual</code> functions as <code>private</code> to convey the message that objects of the derived class should never be used directly, and
the purpose of the class is to interact with a framework which works with objects through base class pointers. While the FAQ gets
overly hysterical about this practice, the polarity of its answer (&quot;no&quot;) is probably right.
</p>


<a id="fqa-21.2"></a>
<h2>[21.2] Converting <code>Derived* -&gt; Base*</code> works OK; why doesn&#39;t <code>Derived** -&gt; Base**</code> work?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.2">FAQ:</a></b> Because it shouldn&#39;t. Let&#39;s pretend it does work and see what happens.
</p>

<p>
Suppose you have a <code>Dog* d</code>. You pass it to a function <code>void f(Pet** p)</code> with <code>f(&amp;d)</code> - which should be OK,
        since <code>Dog</code> is derived from <code>Pet</code>. The function does this: <code>*p = new Cat;</code>
- perfectly legitimate, since <code>Cat</code> is derived from <code>Pet</code>, too. But now we have a <code>Dog*</code> pointing to a <code>Cat</code> object. So <code>d-&gt;bark()</code>
will crash the program, or misbehave more severely, since a <code>Cat</code> may have a virtual function <code>scratchFurniture</code> at that slot
of the vtable.
</p>

<p>
Actually, the FAQ uses a scarier example, which launches nuclear missiles as the result of the mistake. IMHO, nothing can beat
the following classic in this department:
</p>

<pre>
if(status = UNDER_ATTACK) {
  launch_nuclear_missiles();
}
</pre>

<p>
Best Industry Practice: use peer reviews to increase the quality of your nuclear missiles launching code.
</p>

<p>
<b class="FQA">FQA:</b> Yep, levels of indirection and static typing interact in non-obvious ways. This is another incarnation of <a href="fqa.html#fqa-18.2">the problem</a>
making it impossible to cast <code>T**</code> to <code>const T**</code>. Basically, <i>a T* is always a S*</i> doesn&#39;t mean <i>a T** is always a S**</i>.
</p>

<p>
The problem is that there are many cases where you <i>know</i> that you are doing something legitimate, but the compiler doesn&#39;t. For example, you know
that it was <i>you</i> who filled this vector of Pets with a bunch of Dogs. You <i>couldn&#39;t</i> use a vector of Dogs because
you wanted to pass it to a function working with a vector of Pets. And as we&#39;ve just seen, the compiler wouldn&#39;t let
you pass a vector of Dogs to a function expecting a vector of Pets, and for a good reason. So you ended up
        with a vector of Pets filled with Dogs.
        And now you want to fetch a Dog from the vector - but the elements are typed as Pets,
so you have to use a cast. It wouldn&#39;t be that bad if these cases wouldn&#39;t cause many people to develop a habit of
aggressive casting to have the compiler shut up, and/or C++ would catch illegal cast operations at run time.
</p>

<p>
Moral: static typing (having the compiler validate the code according to a set of rules specifying properties of types and their relationships)
is hard. A static type system will get in your way. And it only partially compensates you by &quot;validating the interfaces&quot;,
because only some of interface specification can be modeled statically, as we&#39;ll see <a href="fqa.html#fqa-21.6">below</a>.
In particular, consider our example where you had to stuff your Dog objects into a vector of Pet pointers,
all because the compiler <i>insisted</i> on the looser typing.
        Now the compiler won&#39;t prevent someone else from adding a Cat pointer to that vector, and
        then your code fetching a Pet* from the vector and casting it to a Dog* will misbehave.
</p>

<p>
I&#39;m not saying that static typing is &quot;bad&quot;, but if you think that <i>dynamic</i> typing is bad, you are very lucky -
you&#39;re just one step away from a quite noticeable increase in your productivity. Pick a dynamically typed language and give it a try.
</p>


<a id="fqa-21.3"></a>
<h2>[21.3] Is a parking-lot-of-<code>Car</code> a kind-of parking-lot-of-<code>Vehicle</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.3">FAQ:</a></b> No, because a <code>Plane</code> is one kind of <code>Vehicle</code>, and you don&#39;t want someone to park it at a cars&#39; parking lot.
</p>

<p>
<b class="FQA">FQA:</b> In English, apparently the answer is yes. In OO, the answer is no. In natural language, there&#39;s no strict definition of &quot;kind-of&quot; (or anything
else, for that matter). OO systems are formal, and they have a precise definition for &quot;kind-of&quot;: <i>B is a kind of A if
you can do to a B object whatever you can do to A, and it will work correctly</i> (not just compile).
</p>

<p>
Programming languages are not natural languages. In particular, the good programming languages don&#39;t try to look
<a href="fqa.html#fqa-13.2">"natural"</a> when such attempts make it hard to understand the formal, precise and dumb stuff the machine actually does.
If you ever wondered what on Earth the C++ expression <code>a-&gt;b</code> does (when <code>a</code> is an object of a smart pointer template class with 7 parameters),
you know what I mean.
</p>


<a id="fqa-21.4"></a>
<h2>[21.4] Is an array of <code>Derived</code> a kind-of array of <code>Base</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.4">FAQ:</a></b> No. Think of the array as an implementation of a parking lot, and you&#39;ll see that the answer follows from <a href="fqa.html#fqa-21.3">the previous
FAQ</a>.
</p>

<p>
<b class="FQA">FQA:</b> Note that the ability of the compiler to figure out whether something is a kind-of something else is limited.
In particular, it seems to work better with types
related by inheritance (base and derived classes) than with types related by qualifiers (<code>const</code> and non-<code>const</code>)
or by the way they are instantiated from the same templates.
For example, a <code>vector&lt;T*&gt;</code> is apparently a kind-of <code>const vector&lt;const T*&gt;</code>, because there&#39;s nothing you can do
with an all-<code>const</code> vector you couldn&#39;t do with an all-non-<code>const</code> vector. But the compiler <a href="fqa.html#fqa-18.17">doesn't know that</a>.
</p>

<p>
One way around this is &quot;duck typing&quot; - don&#39;t bother to specify the relationships between the types, just
pass objects to functions, which will work if the object can do whatever they ask it to do, and raise
a run time error otherwise.
&quot;If it walks like a duck then it is a duck&quot; and all that - you don&#39;t have to define a <code>Duck</code> interface all
ducks should follow, just get an object and call methods such as <code>walkLikeADuck</code>.
C++ doesn&#39;t have duck typing because it would require the compiler to rely on non-trivial and not-so-lightweight run time mechanisms,
which kind of goes against the &quot;spirit&quot; of C++ (not that the run time mechanisms used to implement exceptions are trivial, mind you).
</p>

<p>
One could claim that duck typing is incompatible with the &quot;spirit of C++&quot; because it involves run-time dispatching,
but so do <code>virtual</code> functions, which are more efficient but less flexible and much more likely to trigger recompilations - a <a href="fqa.html#fqa-6.3">big deal</a> in many situations.
Or one could claim that duck typing is not &quot;the C++ way&quot; because it leaves out the specification of interfaces,
but so do templates, which provide &quot;static duck typing&quot; - too bad they are such a pile of toxic waste that the scope of
this discussion is too narrow to even briefly describe <a href="fqa.html#fqa-35.1">why</a>. Or one could claim that with duck typing, you can fail
at run time because someone provided an object of the wrong type - but nothing prevents someone from simply passing
a null pointer to a C++ function that can&#39;t handle that and have it crash much harder than any code in a safe dynamic language ever will.
</p>

<p>
The true reason making duck typing incompatible with The C++ Way is the 95% Is Nothing Axiom. It goes like this:
&quot;if something is only useful for 95% of the cases, <i>and</i> it doesn&#39;t map almost directly to C,
it&#39;s not worth adding to C++&quot;. Other examples of the application of this axiom to the design of C++
is <a href="fqa.html#fqa-16.1">the lack of garbage collection</a>, which &quot;only&quot; handles memory (&gt;95% of all &quot;resources&quot;), and &quot;only&quot; in non-real-time
applications (&gt;95% of all application code).
</p>

<p>
The consequences of this axiom wouldn&#39;t be that bad if the features C++ <i>did</i> add to C were any good.
</p>


<a id="fqa-21.5"></a>
<h2>[21.5] Does array-of-Derived is-not-a-kind-of array-of-Base mean arrays are bad?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.5">FAQ:</a></b> Yes, arrays are <a href="fqa.html#fqa-6.15">evil</a>. Normally you should use <code>std::vector</code> instead of arrays. But if you are an enlightened OO
specialist and so is everyone likely to maintain your code, and you fully understand the interaction of &quot;kind-of&quot;
and arrays, you may use them.
</p>

<p>
<b class="FQA">FQA:</b> Huh? Arrays and vectors are synonyms in the context of the &quot;kind-of&quot; issue. What does the cult <a href="fqa.html#fqa-8.6">advocating</a>
the replacement of C features, which have their problems, with new shiny C++ features having much worse problems
have to do with proper inheritance?
</p>

<p>
What&#39;s that? Casting arrays is easier than casting vectors? Try this: <code>(vector&lt;T&gt;*)&amp;vec_of_something_else_than_T</code>.
Seriously, this is one weird question with a strange answer we have here.
</p>


<a id="fqa-21.6"></a>
<h2>[21.6] Is a <code>Circle</code> a kind-of an <code>Ellipse</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.6">FAQ:</a></b> Sometimes it is, most frequently it isn&#39;t. For example, if an <code>Ellipse</code> lets you change the size in a way
making it asymmetrical, it&#39;s not a <code>Circle</code>.
</p>

<p>
The point is that if you derive a <code>Circle</code> from an <code>Ellipse</code> and then someone tries to use an <code>Ellipse*</code> which
really points to a <code>Circle</code> object, there&#39;s no way to make it work gracefully. Either the calling code will
get an error in some form, even though it does something which should be possible to do with an <code>Ellipse</code>,
or the <code>Circle</code> object will obey to the caller and become an invalid circle, breaking some other legitimate piece of code which
does expect it to be a valid circle.
</p>

<p>
<b class="FQA">FQA:</b> This is just like <a href="fqa.html#fqa-21.3">the parking lot example</a> in the sense that &quot;kind-of&quot; in English means many different things,
some of which are incompatible with the precise definition of &quot;kind-of&quot; used in OO. The important point is that
the interfaces are protocols and implementations must follow them.
</p>

<p>
Some people think about inheritance merely
as another form of &quot;binding&quot; - having the compiler call a function using new syntax. From this point of view,
everything is legitimate as long as the program compiles and does whatever the end user expects. But this way
inheritance only makes programming harder (another kind of syntax to decipher). The more restrictive &quot;interfaces
as a protocol&quot; approach can make programming easier because when you implement a bunch of protocols correctly,
you can extend a program without tweaking its code (for example, <a href="fqa.html#fqa-20.1">add a movie format to a media player</a>). But this
only works if you <i>really</i> follow the protocol. If you <i>sort of</i> do it (&quot;a Circle is a kind-of Ellipse, well, almost - just don&#39;t call this function&quot;),                                                                        
the media player will crash.
</p>

<p>
There are numerous families of examples where natural languages and OO terms <a href="fqa.html#fqa-19.2">are not aligned</a>
(which doesn&#39;t mean OO is bad - it means it&#39;s formal, which is good for computer programming).
The &quot;parking lot&quot; represents one family (collections); Circle/Ellipse represent another one (parametric representations).
One family of &quot;positive&quot; examples (where inheritance is likely to be proper) is record types
(a <code>CPlusPlusProgrammer</code> has all the fields of a <code>Programmer</code>, plus a couple of new, orthogonal members, such
 as <code>headAgainstTheWallBangingFrequency</code>).
</p>


<a id="fqa-21.7"></a>
<h2>[21.7] Are there other options to the &quot;<code>Circle</code> is/isnot kind-of <code>Ellipse</code>&quot; dilemma?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.7">FAQ:</a></b> Well, you need to get rid of <i>some</i> of your original claims to get back to consistency. Either <code>Ellipse</code> has no
<code>setSize</code> function which can make a circular <code>Ellipse</code> object non-circular, or there&#39;s no inheritance which makes
it possible to call such a function on a <code>Circle</code> object, or you can even choose to live with the fact that some
of your <code>Circle</code> objects will become non-circular (and have the code working with <code>Circle</code> objects deal with it).
</p>

<p>
Trying to keep all claims and cover up the problem by doing &quot;something reasonable&quot;
(like calling <code>abort</code> when <code>setSize</code> is called with a <code>Circle</code> object, or &quot;fixing&quot; its arguments)
is not going to solve the problem, because ultimately it breaks the assumptions behind the calling code.
</p>

<p>
<b class="FQA">FQA:</b> The FAQ answer is apparently correct and complete. Incidentally, this isn&#39;t exclusively about C++, it&#39;s about OO in general.
</p>

<p>
One solution is to have <code>setSize</code> return a new <code>Ellipse</code> object. This way, <code>Circle::setSize</code> will return
a <code>Circle</code> unless the new size is asymmetrical, in which case it will return an <code>Ellipse</code>. One possible
 benefit is efficiency - circles have less parameters than ellipses, so if you have lots of operations to do
 with a bunch of objects, you&#39;d rather have all of the objects that can be represented as <code>Circle</code> objects
 actually <i>be</i> represented that way, not as redundant <code>Ellipse</code> objects.
</p>

<p>
If you &quot;roll your own OO&quot; (that is, implement inheritance yourself instead of directly relying on language features),
 you can avoid the creation of a new object and instead dynamically change its type. For example,
 <code>setSize</code> may change the vptr to point to an <code>Ellipse</code> vtable when the new size is asymmetrical.
 This kind of thing is implemented in the <a href="http://www.povray.org/">POV-Ray</a> ray tracer, written in C.
</p>

<p>
The fact that you can&#39;t do it in a portable way with C++ inheritance probably <i>doesn&#39;t</i> mean that C++ inheritance
 is underpowered (surprise!) - you need this kind of thing once in a lifetime, and you must have it very well
 thought-out to make it really work, and in these rare cases you can go ahead and use function pointers instead
 of inheritance and implement it. There probably are people that would classify this limitation as a symptom of
 a deeper problem - having too much logic built into the compiler and too little ways to implement compile time
 logic in user code - but it&#39;s debatable.
</p>


<a id="fqa-21.8"></a>
<h2>[21.8] But I have a Ph.D. in Mathematics, and I&#39;m sure a Circle is a kind of an Ellipse! Does this mean Marshall Cline is stupid? Or that C++ is stupid? Or that OO is stupid?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.8">FAQ:</a></b> It means a different thing: your intuition is wrong in the sense that it leads you to make wrong decisions about
 inheritance. The right way to think about &quot;kind-of&quot; is this: B is a kind of A if you can always substitute a B for an A.
</p>

<p>
<b class="FQA">FQA:</b> I like how this question is formulated. Shows spirit. In general, the FAQ can be quite entertaining
 if you&#39;re into that sort of thing. If I could legitimately quote the answers instead of summarizing them,
 I&#39;d sure would.
</p>

<p>
Which is all nice and dandy, but did you notice the disturbing claim &quot;your intuition is wrong&quot;? Instead of admitting
 that OO is <i>not</i> <a href="fqa.html#fqa-19.2">a natural language</a>, and it <i>doesn&#39;t</i> have to <a href="fqa.html#fqa-13.2">map directly to a natural language</a>, the FAQ actively tries
 to persuade you to <i>change</i> the way you use natural language words to make your thinking OO-compatible. Next, they&#39;ll
 ship patches you should apply to your DNA, and a sticker saying &quot;Designed for C++ Programming&quot; for your skull.
</p>

<p>
I think this point is worth discussion because it&#39;s representative of the whole notion of &quot;good&quot; in the C++ world.
 C++ tries to make the program <i>look</i> natural. See - we add things with the plus sign, and errors are handled <a href="fqa.html#fqa-17.1">transparently</a>,
 and resources are managed <a href="fqa.html#fqa-17.4">automatically</a> - that&#39;s one very high-level language, and it&#39;s efficient, too! But make a single
 error in your program - and finding it becomes an nightmare. What is <i>really</i> being called by this <code>a+b</code> expression?
 What <i>really</i> happens upon error? And this object we deallocate here - how do we know nobody is keeping a pointer to it?
 Because all our pointers are &quot;smart&quot;? But look - here we use a library using bare pointers, and here&#39;s one using
 different smart pointer classes. What is <i>really</i> going on here?
</p>

<p>
The basic rule C++ breaks is this: don&#39;t make promises you can&#39;t keep. Don&#39;t say that inheritance is equivalent to
 the way people think about &quot;kind-of&quot; - introduce it from the beginning in terms of substitutability. Don&#39;t
 pretend you manage resources &quot;automatically&quot; when in fact it&#39;s the responsibility of everyone to follow non-trivial
 protocols for this to work, and a single error is fatal - make it visible where resources are acquired and released.
Or you can <i>really</i> manage them automatically - with garbage collection or reference counting or otherwise. But if you
 refuse to do it, which may be perfectly legitimate at times, <i>admit it</i>. Changing your terms is more productive than
 waiting for everyone to change theirs.
</p>

<p>
Of course the Circle/Ellipse problem is <i>not</i> an example of &quot;making promises that can&#39;t be kept&quot;. It&#39;s
 the FAQ&#39;s <a href="fqa.html#fqa-19.2">claims</a> about OO &quot;capturing the way we think&quot; that are such an example.
</p>


<a id="fqa-21.9"></a>
<h2>[21.9] Perhaps <code>Ellipse</code> should inherit from <code>Circle</code> then?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.9">FAQ:</a></b> Probably not. For example, what would the <code>radius()</code> accessor do, and how would it be compatible with an assumption
 that is most likely a part of the <code>Circle</code> protocol that you can use <code>radius()</code> to compute the <code>area()</code>?
</p>

<p>
<b class="FQA">FQA:</b> I think it&#39;s very easy to see with a slightly different, but a related example. What is more stupid: to claim
 that a triangle is a rectangle with two identical vertices, or that a rectangle is a triangle with 4 vertices? It
 probably sounds equally stupid to most people.
</p>

<p>
The major reason making people who themselves would think these claims are stupid to go ahead and derive <code>Triangle</code> from <code>Rectangle</code>
 or vice versa is that <i>they don&#39;t think they are in fact making such claims by implementing such inheritance</i>.
</p>

<p>
The idea is this: inheritance is not just yet another kind of syntax. Its purpose is <i>not</i> to save a couple of lines
 of code in the derived class (which you may accomplish by deriving <code>Triangle</code> from <code>Rectangle</code>). And the compiler <i>can&#39;t</i> check that
your inheritance is correct
 (this is really hard for C++ aficionados to accept: <i>the compiler can&#39;t check something!</i>).
Inheritance is about writing code that follows a protocol, making it possible to call this code from any function
written to work with objects that follow that protocol, and thus <i>reusing the calling code</i> (possibly <i>a lot</i> of such code - much more than the couple of lines you saved in the derived class).
</p>

<p>
And if your inheritance does not guarantee substitutability, then the compiler won&#39;t be able to catch your error
(it&#39;s type checking <i>assumes</i> that you provide substitutability - that&#39;s why it lets you use pointers
 to derived class objects in contexts expecting base class object pointers). And you&#39;ll confuse most people
  (frequently including yourself), who also expect substitutability, especially since the compiler agrees by
  letting them pass an <code>Ellipse</code> where a <code>Circle</code> is required. And if you really don&#39;t need substitutability,
  you don&#39;t really need (public) inheritance, either.
</p>


<a id="fqa-21.10"></a>
<h2>[21.10] But my problem doesn&#39;t have anything to do with circles and ellipses, so what good is that silly example to me?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.10">FAQ:</a></b> But you see, <i>all</i> examples of improper inheritance are basically equivalent to the <code>Circle</code>/<code>Ellipse</code>
  case. Inheritance is bad when a base class provides functionality which a derived class can&#39;t provide
  (in the <code>Ellipse</code> case, that&#39;s asymmetrical resizing). The problem with inheritance in such cases is that
it comes without substitutability, breaking a basic assumption shared by programmers using the classes
and the compiler (which automatically allows to use objects of derived classes where base class objects are expected).
</p>

<p>
<b class="FQA">FQA:</b> Exactly. People <a href="fqa.html#fqa-33.4">obsessed</a> with compile-time error checking, repeat: the compiler does the static type
checking (as in &quot;this object is of class <code>Derived</code> - OK, it&#39;s a legitimate parameter to function <code>f(Base&amp;)</code>&quot;)
based on assumptions it can not check (&quot;whoever wrote <code>Derived</code> made it substitutable for <code>Base</code>&quot;).
Say it again: <i>the compiler does the static type checking based on assumptions it can not check.</i>
<b> The compiler does the static type checking based on assumptions it can not check. </b>
</p>

<p>
Translation: the correctness of an interesting program can not be checked at compile time. All programmers are supposed to <a href="http://en.wikipedia.org/wiki/Halting_problem">know</a> it,
but some keep forgetting. So is it ultimately better to spend your time on type safety (things like <a href="fqa.html#fqa-35.11">making sure</a> that nobody can cast <code>vector&lt;T&gt;::iterator</code> to the underlying <code>T*</code>)
or writing tests checking that your code behaves correctly at run time? You be the judge.
</p>


<a id="fqa-21.11"></a>
<h2>[21.11] How could &quot;it depend&quot;??!? Aren&#39;t terms like &quot;Circle&quot; and &quot;Ellipse&quot; defined mathematically?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.11">FAQ:</a></b> They are, but the <i>classes</i> <code>Circle</code> and <code>Ellipse</code> have a <i>different</i> definition - the C++ code
defining the classes. In your program, that&#39;s the definition of <code>Circle</code> and <code>Ellipse</code>, and that&#39;s
what you have to look at to validate your inheritance. If you keep thinking about the mathematical connotations,
let&#39;s replace the class names with <code>Foo</code> and <code>Bar</code> for the moment; that&#39;s all the same for the compiler.
</p>

<p>
Now that we&#39;ve defined the meaning of <code>Circle</code> and <code>Ellipse</code>, recall that &quot;inherits&quot; means &quot;is substitutable for&quot;
   (not &quot;is a&quot; or &quot;is a kind of&quot;, which are not precise definitions). With these definitions, you can get
   the right answer using the previous FAQs.
</p>

<p>
<b class="FQA">FQA:</b> Exactly - you can&#39;t implement the mathematical notion of &quot;circle&quot; in a programming language,
   you can only implement a definition (possibly called <code>Circle</code>) or a bunch of definitions
   which model some of the aspects of mathematical circles to a certain extent. And when you reason
   about the correctness of your program, you have to talk about these definitions, not the original
   mathematical notion.
</p>

<p>
Lots of suffering inflicted by the more talented programmers upon themselves originates at the hope
   to implement &quot;the ultimate something&quot; (for example, &quot;the ultimate circle class&quot; that captures <i>all</i>
                                          aspects of mathematical circles, so you&#39;d never
have to define a circle class again).
   The <i>ultimate</i> search for &quot;the ultimate something&quot; in programming is probably the search for
   <i>the ultimate programming language</i>. Arguably, the C++ language is one result of this search -
   it tries to meet a huge amount of conflicting requirements, the key ones being <a href="http://www.research.att.com/~bs/bs_faq.html#why">"readability, efficiency and generality"</a>
   of C++ code, as well as <a href="fqa.html#fqa-6.11">pseudo-compatibility</a> with C. The result is a large-scale nightmare, and the moral of the story is simple: design
   the best tool for everything, and you&#39;ll get a tool good for nothing.
</p>

<p>
On the bright side, it is probably possible to define a good <code>Circle</code> class for your program -
   if you try to make it good <i>for your program</i> rather than implement the mathematical notion.
   And this is why the meaning of <code>Circle</code> <i>depends</i> on your program.
</p>


<a id="fqa-21.12"></a>
<h2>[21.12] If <code>SortedList</code> has <i>exactly</i> the same public interface as <code>List</code>, is <code>SortedList</code> a kind-of <code>List</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/proper-inheritance.html#faq-21.12">FAQ:</a></b> It&#39;s quite unlikely. For instance, consider <code>List::insert</code>. Is it defined to insert the element
   to the end of the list? If it is, there&#39;s no good way to implement it in <code>SortedList</code>, because
   the insertion to the end will usually make the list unsorted.
</p>

<p>
The substitutability principle is about the specified behavior, not just function names and parameter types.
So &quot;exactly the same public interface&quot; in the syntactic sense is not enough - for proper inheritance,
   the specified run time behavior must be the same.
</p>

<p>
<b class="FQA">FQA:</b> Yep, compile time type checking can not guarantee proper inheritance, it can only operate under
   the <a href="fqa.html#fqa-21.10">assumption</a> that <i>you</i> guaranteed it. That&#39;s why some languages come with contract checking:
   the base class specifies the behavior using input and output constraints computed at run time,
   and you can have your run time environment automatically evaluate these constraints when methods of derived
   classes are called.
</p>

<p>
You can simulate this behavior in C++ by writing lots of code. Namely, the base class can have a public
   non-virtual <code>insert</code> method calling a protected virtual <code>onInsert</code> method. The <code>insert</code> wrapper
   can then check whether <code>onInsert</code> follows the protocol using a bunch of <code>assert</code>s before
   and after the call to <code>onInsert</code>. Since &quot;a lot of code&quot; is most frequently bad by itself (because you waste time writing it and then waste much more time reading it together with other people),
   the benefits are not necessarily worth the trouble. But run time tests (stand-alone or integrated into a larger system)
   greatly increase the quality of code, and making run time testing simple and painless pays off, especially compared
   to work spent on compile time error detection.
</p>

<a id="fqa-inheritance-abstract"></a><h1>Inheritance -- abstract base classes</h1>
<p>
C++ abstract base classes are not bad at all by C++ standards. However, they are quite poor by OO standards.
</p>

<ul>
<li><a href="fqa.html#fqa-22.1">[22.1] What&#39;s the big deal of separating interface from implementation?</a></li>
<li><a href="fqa.html#fqa-22.2">[22.2] How do I separate interface from implementation in C++ (like Modula-2)?</a></li>
<li><a href="fqa.html#fqa-22.3">[22.3] What is an ABC?</a></li>
<li><a href="fqa.html#fqa-22.4">[22.4] What is a &quot;pure virtual&quot; member function?</a></li>
<li><a href="fqa.html#fqa-22.5">[22.5] How do you define a copy constructor or assignment <code>operator</code> for a class that contains a pointer to a (abstract) base class?</a></li>
</ul>

<a id="fqa-22.1"></a>
<h2>[22.1] What&#39;s the big deal of separating interface from implementation?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/abcs.html#faq-22.1">FAQ:</a></b> Interfaces are the most important thing possessed by a company. Defining interfaces is hard, throwing together an implementation
is easy. Designing interfaces takes lots of time and is done by people who are paid lots of money.
</p>

<p>
You wouldn&#39;t want these valuable artifacts clobbered by implementation details, would you?
</p>

<p>
<b class="FQA">FQA:</b> If interface is decoupled from implementation, you can have more than one implementation of the same
interface. This way, code <i>using</i> the interface can work with all those implementations. For example, the same
code may be used to render a document to a screen, a printer and a file. Which is <i>excellent</i>, and is a <i>very
widely acknowledged and basic fact</i>.
</p>

<p>
It&#39;s amazing that the FAQ&#39;s answer fails to mention this. The FAQ&#39;s claim about the relative importance
of interfaces and implementations is unbelievable, too. Here&#39;s an interface for you:
</p>

<pre>
class SearchEngine
{
public:
  // search the documents pointed by URLs in the inputURLs stream, search the query string
  // in them and emit the URLs sorted by relevance to the outputURLs stream (at most maxResults URLs).
  virtual void find(const string&amp; query, istream&amp; inputURLs, ostream&amp; outputURLs, int maxResults) = 0;
};
</pre>

<p>
Now, that took about 1 minute. It&#39;s your turn to &quot;throw together an implementation&quot;, which shouldn&#39;t take more
than 30 seconds according the FAQ&#39;s argument, should it? Go.
</p>

<p>
If you don&#39;t like this example (&quot;there are more complicated interfaces in a real search engine&quot;), think about
<code>matchScore = faceRecognition(suspectImage, testImage)</code>, <code>fft(outputArray, inputArray, size)</code>,
<code>text = ocr(imageWithHandWriting)</code>, <code>render(screen,htmlPage)</code>, <code>write(file,buffer,size)</code>... The idea that
&quot;implementations are trivial&quot; can only come from working on extremely stupid applications or example
programs for text books.
</p>

<p>
Of course many interfaces should be decoupled from implementations - but that&#39;s because they <i>hide</i>
a <i>much more complicated</i> implementation, and/or because they have more than one implementation,
and/or because you want to change the implementation without affecting the client code. Surprisingly
enough, C++ abstract classes actually allow you to achieve all these things.
</p>

<p>
Of course they don&#39;t
fix many hard problems with C++ - there&#39;s no real run time type information, for example. And adding a function
to an abstract class changes the binary interface, which is frequently unacceptable.
But abstract classes are better than nothing, as opposed to the many C++ features which are in fact
<i>worse</i> than nothing.
</p>


<a id="fqa-22.2"></a>
<h2>[22.2] How do I separate interface from implementation in C++ (like Modula-2)?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/abcs.html#faq-22.2">FAQ:</a></b> Use an abstract base class.
</p>

<p>
<b class="FQA">FQA:</b> What do you mean &quot;like Modula-2&quot;?
</p>

<p>
If you want to be able to work with many different implementations selected
at run time, abstract base class is the way to go. Alternatively, you can roll your own &quot;abstract base classes&quot;
by using structures containing function pointers, emulating &quot;vtables&quot;. This results in extra code, but it&#39;s <a href="fqa.html#fqa-6.3">more
portable</a> (C binary calling conventions on a given processor architecture tend to be shared by more tools than C++ ones).
</p>

<p>
If you don&#39;t need dynamic implementation selection, you can use a header file with forward declarations of types,
and have the types defined in the implementation file(s). <a href="fqa.html#fqa-7.5">This way</a> you can change the implementation details
without recompiling the calling code
(which you can&#39;t do with C++ <code>private</code> members). In particular,
you can build several versions of your program with different implementations of this interface without recompiling
the entire program.
</p>


<a id="fqa-22.3"></a>
<h2>[22.3] What is an ABC?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/abcs.html#faq-22.3">FAQ:</a></b> An abstract base class.
</p>

<p>
Logically, it corresponds to an abstract concept, such as <code>Animal</code>. Specific animals, like <code>Rat</code>, <code>Skunk</code> and <code>Weasel</code>,
correspond to implementation classes derived from <code>Animal</code>.
</p>

<p>
Technically, a class with at least one pure <a href="fqa.html#fqa-20.1">virtual</a> function is abstract. You can&#39;t have objects of abstract classes,
 you can only create objects of classes derived from them that implement all the pure virtual functions.
</p>

<p>
<b class="FQA">FQA:</b> ABC is also an especially annoying abbreviation.
</p>

<p>
Here are a couple of things you can&#39;t do with a C++ abstract base class, and which are supported in other OO languages. You can&#39;t iterate over the methods of
 an abstract base class (neither at compile time nor at run time). So you can&#39;t easily utilize the decoupling
 between the interface and the implementation by automatically generating wrapper classes that log function calls
 or pack the arguments and send them to an object in another process and/or on another machine. You also
 can&#39;t ask a random object whether it implements the given interface (in language terms,
 whether its class is derived from a given abstract base class).
</p>

<p>
If the only language you use heavily is C++, it&#39;s possible that you don&#39;t realize that you might <i>want</i> to do these
 things at all, or even memorized elaborate arguments &quot;proving&quot; that these things <i>should not</i> be done.
 But hey - at least abstract classes don&#39;t make anything <i>worse</i> than it already was in C. Quite an achievement
 for a C++ feature.
</p>


<a id="fqa-22.4"></a>
<h2>[22.4] What is a &quot;pure virtual&quot; member function?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/abcs.html#faq-22.4">FAQ:</a></b> It&#39;s a virtual function which (normally) has no implementation in the base class, and (always) must be implemented
 in a derived class to make it non-abstract. The syntax is: <code>virtual result funcname(args) = 0;</code>.
</p>

<p>
This declaration makes the class abstract - it is illegal to create objects of this class. A derived class that doesn&#39;t
 implement at least one pure virtual function is still abstract. Only derived classes without any unimplemented pure
 virtual functions can be instantiated (you can create objects of these classes).
</p>

<p>
<b class="FQA">FQA:</b> The syntax is ridiculous. You may wonder what <code>virtual result funcname(args) = 1999;</code> means. Well, it means nothing;
 it doesn&#39;t compile.
</p>

<p>
One possible motivation for this syntax is to save a keyword (such as <code>pure</code> or <code>abstract</code>). The more new keywords there are,
 the &quot;less&quot; C++ is compatible with C, or with C++ code written before the new keyword was introduced (well, <a href="fqa.html#fqa-6.11">strictly
speaking</a>, either two things are compatible, or they are not, but we&#39;ll ignore that for the moment). That&#39;s because
 C and C++ have grammars which disallow to use keywords as identifiers. This problem is shared by the majority of
 programming languages.
</p>

<p>
However, C++ does have a huge amount of new keywords. This makes one wonder why the very rarely used <code>explicit</code>
 (not to mention <code>export</code>) is a keyword, while the many different uses of the keyword <code>static</code> are in fact collapsed
 into a single keyword instead of using new keywords for the new uses. And why not use the silly, but standard
 &quot;reserved namespace&quot; (names prefixed with two underscores or a single underscore followed by a capital letter
are reserved for the compiler), the way it&#39;s (mostly) done in C99? Then we&#39;d have <code>__explicit</code> built-in and <code>explicit</code>
 would be a <code>#define</code> you&#39;d <code>#include</code> from <code>&lt;shiny_new_useless_cxx_features&gt;</code> (no trailing <code>.h</code>, of course).
This way, you give a normally looking keyword to people who need it, and don&#39;t break the code of those who don&#39;t.
</p>

<p>
Here&#39;s a proposal for the next C++ standard: let&#39;s define two keywords, <code>__0</code> and <code>__1</code>. With a token sequence composed of these
 two keywords, we can express anything
 (actually, one keyword is enough, but that&#39;s just too verbose). Then we won&#39;t
ever need any new keywords. As the pure virtual syntax example shows, the readability loss is a small price to pay
 for the forward, backward and downward compatibility achieved using this approach.
</p>


<a id="fqa-22.5"></a>
<h2>[22.5] How do you define a copy constructor or assignment <code>operator</code> for a class that contains a pointer to a (abstract) base class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/abcs.html#faq-22.5">FAQ:</a></b> If you don&#39;t want to make a &quot;deep copy&quot; of that pointer, there&#39;s nothing special about this case.
</p>

<p>
If you do want to make a deep copy of the pointer (which you normally should do when the class &quot;owns&quot; it),
  the abstract base class should have virtual <code>copy</code> and <code>assign</code> methods you can call from your copy constructor and
  assignment operator.
</p>

<p>
<b class="FQA">FQA:</b> This is a small example of how C++ forces you to write code which <a href="fqa.html#fqa-20.8">could be generated automatically</a>.
  You can avoid the problem by avoiding the ownership approach to lifetime management (<a href="fqa.html#fqa-17.4">RAII</a>), but
  figuring out that you need these virtual functions and implementing them is easy for people
  who understand C++ well.
</p>

<p>
The trouble is that <a href="fqa.html#fqa-6.6">most</a> people using C++ <i>don&#39;t</i> understand it very well. C++ has the lethal combination
  of looking all nice and simple on the surface and having lots of traps installed under the surface, waiting
  for a victim. The only chance of the victim is to have a very good understanding of the underlying problems
  of C++. With that understanding, it&#39;s easy to see that, um, you have to make a deep copy since you&#39;re
  the &quot;owner&quot;, and an object pointed by two owners is going to be wiped out twice by the <a href="fqa.html#fqa-11.1">destructor</a>, and we
  don&#39;t want that, so let&#39;s copy the object - costly, but safe, and, um, we can&#39;t just copy the object, because we don&#39;t know its type, but wait,
  the object <i>itself</i> does know its type, so we need it to help us with the copying, so we need to add these
  virtual <code>copy</code> functions to this hierarchy of classes. It&#39;s a good thing we did it now before the interfaces
  became stable and adding functions became a royal pain, causing recompilation of calling code. Or did we?
</p>

<p>
The problem with all this reasoning is that it has little to do with whatever you&#39;re ultimately trying to achieve
  in your program. So many people who think more about what their program does than about the way their programming
  language works won&#39;t see this coming, and do something wrong. No, it <i>doesn&#39;t</i> mean that the people primarily focused
  on the programming language are more productive than others. Of course they aren&#39;t uniformly less productive, either.
  Some of the people with a programming language focus spend most of their time <a href="fqa.html#fqa-14.3">choosing</a>
  between <code>func(obj)</code> and <code>obj.func()</code>, some don&#39;t; it depends on the person, and people can change, further complicating matters.
</p>

<p>
Of course this problem exists with all computer languages and, more generally, with all software systems, and, more
  generally, with all formal systems. Basically there&#39;s the ice - the things compatible with human common sense -
  and the cold water under it, into which you can fall when the rules governing the system <a href="fqa.html#fqa-21.6">contradict</a>
  your common sense. So what&#39;s so special about C++?
</p>

<p>
Well, in C++, the very thin ice is covered with <a href="fqa.html#fqa-13.2">paint</a>, and the water is deep enough to <a href="fqa.html#fqa-35.20">drown</a>.
</p>

<a id="fqa-inheritance-mother"></a><h1>Inheritance -- what your mother never told you</h1>
<p>
Note: section names are copied verbatim from the FAQ. The document is not based on the assumption that it was your mother who told you the other things about inheritance.
</p>

<ul>
<li><a href="fqa.html#fqa-23.1">[23.1] Is it okay for a non-<code>virtual</code> function of the base class to call a <code>virtual</code> function?</a></li>
<li><a href="fqa.html#fqa-23.2">[23.2] That last FAQ confuses me. Is it a different strategy from the other ways to use <code>virtual</code> functions? What&#39;s going on?</a></li>
<li><a href="fqa.html#fqa-23.3">[23.3] Should I use protected virtuals instead of public virtuals?</a></li>
<li><a href="fqa.html#fqa-23.4">[23.4] When should someone use private virtuals?</a></li>
<li><a href="fqa.html#fqa-23.5">[23.5] When my base class&#39;s constructor calls a <code>virtual</code> function on its <code>this</code> object, why doesn&#39;t my derived class&#39;s override of that <code>virtual</code> function get invoked?</a></li>
<li><a href="fqa.html#fqa-23.6">[23.6] Okay, but is there a way to <i>simulate</i> that behavior as <i>if</i> dynamic binding worked on the <code>this</code> object within my base class&#39;s constructor?</a></li>
<li><a href="fqa.html#fqa-23.7">[23.7] I&#39;m getting the same mess with destructors: calling a <code>virtual</code> on my <code>this</code> object from my base class&#39;s destructor ends up ignoring the override in the derived class; what&#39;s going on?</a></li>
<li><a href="fqa.html#fqa-23.8">[23.8] Should a derived class redefine (&quot;override&quot;) a member function that is non-<code>virtual</code> in a base class?</a></li>
<li><a href="fqa.html#fqa-23.9">[23.9] What&#39;s the meaning of, <code>Warning: Derived::f(char) hides Base::f(double)</code>?</a></li>
<li><a href="fqa.html#fqa-23.10">[23.10] What does it mean that the &quot;virtual table&quot; is an unresolved external?</a></li>
<li><a href="fqa.html#fqa-23.11">[23.11] How can I set up my class so it won&#39;t be inherited from?</a></li>
<li><a href="fqa.html#fqa-23.12">[23.12] How can I set up my member function so it won&#39;t be overridden in a derived class?</a></li>
</ul>

<a id="fqa-23.1"></a>
<h2>[23.1] Is it okay for a non-<code>virtual</code> function of the base class to call a <code>virtual</code> function?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.1">FAQ:</a></b> Sometimes it is. Suppose you have a class <code>Animal</code> with a non-<code>virtual</code> <code>getAwfullyExcited()</code> method.
In your system, all animals do it similarly:
</p>

<pre>
void Animal::getAwfullyExcited()
{
  makeExcitedNoises(); // all animals make different noises
  cout &lt;&lt; &quot;And here comes the dance!&quot; &lt;&lt; endl; // all animals always warn people before they dance
  danceExcitedly(); // all animals dance differently
}
</pre>

<p>
So there you have it - an orderly hierarchy of animals, each getting excited according to the standard procedure
in its own unique way.
</p>

<p>
<b class="FQA">FQA:</b> The trouble with this whole thing in C++ is that you can&#39;t easily tell which functions can be overridden and which can&#39;t,
and what &quot;override&quot; means.
</p>

<p>
The default is &quot;can&#39;t&quot; - you have to explicitly say <code>virtual</code> to enable overriding. Unless you derive
your class from a base class having <code>virtual</code> functions - when you override those functions, the <code>virtual</code>
keyword becomes optional. But even if the function in the base class is <i>not</i> virtual, you still <i>can</i> override it -
except that <a href="fqa.html#fqa-23.8">now</a> the binding is static: if you call a function through a pointer statically typed as <code>Base*</code>,
the base class implementation is called, but if you call it through a <code>Derived*</code>, the derived class implementation
is called. So it&#39;s a different kind of &quot;overriding&quot;. And naturally you can have more than one link in the chain of derived classes.
</p>

<p>
Back to our question, it is generally OK to have a common base class implementation call
functions defined in the derived classes - in many cases that does exactly what you want.
However, in the specific case of C++ <code>virtual</code> functions it may become hard to figure out which functions
are <code>virtual</code> and which are not.
</p>

<p>
So it&#39;s sometimes better to separate <code>Animal</code> (having only pure virtual functions) and <code>EmotionalBehavior</code>
(having methods taking an animal and calling its functions to implement various common rituals).
No, it&#39;s probably <i>not</i> a good idea to add this rule to your local Coding Conventions Document -
 if the class is relatively small and simple, there&#39;s no point in creating more code by splitting it to several classes.
The thing is that C++ classes with <i>many</i> methods, some virtual and some not, especially when they are part of complex
 hierarchies with lots of overriding of both kinds, end up making people wonder why this piece of code was called.
 Why, why, why?..
</p>


<a id="fqa-23.2"></a>
<h2>[23.2] That last FAQ confuses me. Is it a different strategy from the other ways to use <code>virtual</code> functions? What&#39;s going on?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.2">FAQ:</a></b> Yes, there are two different strategies related to the use of <code>virtual</code> functions. In the first case,
 you have a common non-<code>virtual</code> method in the base class, but use <code>virtual</code> methods to implement the parts which
 do differ. In the second case, you have <code>virtual</code> methods implemented differently in derived classes,
 but they call common non-<code>virtual</code> methods in the base class. These common bits can also be implemented somewhere
 else - not necessarily in the base class.
</p>

<p>
Sometimes you use both strategies in the same class - one for some of the methods, the other for other methods.
 That&#39;s OK, too.
</p>

<p>
<b class="FQA">FQA:</b> Well, sort of, yeah. Is it just me or did we really learn nothing at all? This lengthy discussion follows
 quite directly from first principles. <code>virtual</code> functions allow different derived classes to implement a method
 differently. All functions, including non-<code>virtual</code>, can be called once or more from various places. Does something
totally obvious from these rules deserve the pompous name &quot;strategy&quot;?
</p>

<p>
No, it&#39;s not just the FAQ. This is very common in the &quot;software engineering&quot; community, especially in the C++ subculture.
Let&#39;s look at an example. You&#39;ve probably seen methods that create new objects of classes derived from a common base. Such methods are useful
 because their caller doesn&#39;t have to be aware of the different derived classes. For example, you can have a
 <code>createMovieReader(filename)</code> method that checks the file type and creates an <code>MPEGReader</code> or an <code>AVIReader</code> or whatever,
 and whoever calls <code>createMovieReader</code> doesn&#39;t have to care about the many different kinds of readers.
 Is this worth a special term
 accompanied by a whole discussion? Well, it has a term - it&#39;s the Factory Method Design Pattern. Sometimes
 you have an abstract base class with nothing but Factory Methods. This has a name of its own, too - it&#39;s the Abstract Factory Design Pattern.
</p>

<p>
The names used by people reveal a lot about them. For example, the people living close to North Pole have a two-digit
 number of names for &quot;snow&quot;. Clearly, the reason is that their visual diet is composed primarily of snow, so they
 know a lot about the different kinds of snow and never confuse them. But trees - those they come across once in a lifetime.
 No point in having many names for trees. A tree, you know, that dark, high thing with messy stuff sticking out.
</p>

<p>
This tells us something about the intellectual diet of people calling trivial combinations of basic language constructs
 &quot;strategies&quot; and &quot;patterns&quot;. Of course these people love C++ - look at all those different string classes,
 and all those ways to implement still new ones! So much snow to play with.
</p>

<p>
Disclaimer: my knowledge of anthropology is approximately zero. Therefore, it&#39;s better to consider the North Pole example above to be hypothetical
 than to make critical decisions assuming it&#39;s literally true.
</p>


<a id="fqa-23.3"></a>
<h2>[23.3] Should I use protected virtuals instead of public virtuals?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.3">FAQ:</a></b> Well, first of all avoid strict rules saying &quot;never do this, always do that&quot;. As a rule of thumb, experience
 tells that most of the time virtual functions are best made public, with two notable exceptions. First, there
 are functions which are supposed to be called only from the base class, the way described in the previous two FAQs. And second, there&#39;s
 the <i>Public Overloaded Non-Virtuals Call Protected Non-Overloaded Virtuals</i> Idiom:
</p>

<pre>
class Base
{
public:
  void overloadingTotallyRules(int x)   { butWeDontWantToOverloadVirtualFunctions_int(x); }
  void overloadingTotallyRules(short x) { butWeDontWantToOverloadVirtualFunctions_short(x); }
protected:
  virtual void butWeDontWantToOverloadVirtualFunctions_int(int);
  virtual void butWeDontWantToOverloadVirtualFunctions_short(short);
};
</pre>

<p>
This solves an important problem: overloading totally rules, but we <a href="fqa.html#fqa-23.9">don't want</a> to overload virtual functions. The
 <i>Public Overloaded Non-Virtuals Call Protected Non-Overloaded Virtuals</i> Idiom makes life easy for class
 users <i>and</i> the implementors of derived classes! Clearly you, the author of the base class,
 absolutely <i>must</i> clobber your code with this nonsense to make everyone&#39;s life better!
 Think about the reduced maintenance costs and <a href="fqa.html#fqa-13.4">the benefit of the many</a>, you selfish code grinder.
</p>

<p>
<b class="FQA">FQA:</b> Here&#39;s a simple answer to your question, trivially following from the definitions and without the need to create a taxonomy of
 rules and exceptions. C++ access control is for clarity: you want to make it clear which parts of the class
 are supposed to be used and which are just implementation details. This can make it easier to understand
 your code and prevents people from using the bits that you might want to change later.
</p>

<p>
Therefore, if you don&#39;t
 think that anyone outside of the class hierarchy is going to use a <code>virtual</code> method, make it <code>protected</code>.
 Otherwise, make it <code>public</code>. In particular, you can start with <code>protected</code> and change it to <code>public</code>
 if it turns out you were wrong. That&#39;s all. Why is any special case of this particularly interesting?
</p>

<p>
As to the <i>One Kind Of Function Calls Another Kind Of Function Idiom</i> - remember <a href="fqa.html#fqa-23.2">the snow example</a>?
 Well, now we are deep inside a pile of snow, coining names for each individual snowflake. I wonder if there&#39;s a <i>Function Is Passed A Parameter
 To Configure Its Operation Idiom</i>. No, there probably isn&#39;t - after all, it&#39;s not Object-Oriented.
</p>

<p>
More importantly, the &quot;idiom&quot; is a non-solution for the problems with overloading.
All we got is extra layers of code piling up. Ultimately, the people will have to read this code to figure
 out what the program does, and the layers of indirection adding no functionality at all will confuse them
 and occupy their short-term memory instead of other, actually useful details. Why not simply
<i>avoid</i> overloading in this case?
</p>

<p>
<a href="fqa.html#fqa-14.3">Talking</a> about &quot;reducing maintenance costs&quot; doesn&#39;t by itself actually reduce any maintenance costs, you know.
</p>


<a id="fqa-23.4"></a>
<h2>[23.4] When should someone use private virtuals?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.4">FAQ:</a></b> Probably never. It confuses people, because they don&#39;t think <code>private</code> virtuals can&#39;t be overridden, but they can.
</p>

<p>
<b class="FQA">FQA:</b> The FAQ is right - the behavior of <code>private virtual</code> is <a href="fqa.html#fqa-21.1">ridiculous</a>; it compiles, but for <a href="fqa.html#fqa-23.5">the wrong reasons</a>. Note that there are <a href="fqa.html#fqa-10.19">many</a>, <a href="fqa.html#fqa-35.18">many</a> more
 things in C++ that primarily confuse people. One excellent reason to avoid C++ altogether. I&#39;m not joking. Nothing
 funny about it. Well, maybe it is funny that C++ developers are confused for a living, but that&#39;s a cruel kind of humor.
</p>


<a id="fqa-23.5"></a>
<h2>[23.5] When my base class&#39;s constructor calls a <code>virtual</code> function on its <code>this</code> object, why doesn&#39;t my derived class&#39;s override of that <code>virtual</code> function get invoked?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.5">FAQ:</a></b> Suppose you have a base class called <code>Base</code>, calling a virtual function <code>f</code> in its constructor. Then, when objects
 of a derived class called <code>Derived</code> are created, <code>Base::virt</code> is called from <code>Base::Base</code>, not <code>Derived::f</code>.
</p>

<p>
The reason is that when <code>Base::Base</code> executes, the object is still of type <code>Base</code>. It only becomes an object of type
 <code>Derived</code> when the code in <code>Derived::Derived</code> is entered. If you wonder why C++ works this way, consider the fact that
 <code>Derived::f</code> could access uninitialized members of the class <code>Derived</code> if it could be called from <code>Base::Base</code>, which
 runs before <code>Derived::Derived</code> initializes the members of <code>Derived</code>.
</p>

<p>
Luckily, C++ doesn&#39;t let this happen, preventing subtle errors!
</p>

<p>
<b class="FQA">FQA:</b> Here&#39;s what actually happens. <code>Derived::Derived</code> calls <code>Base::Base</code>, and then it sets the vptr to point to the <code>Derived</code>
 vtable. Setting the vptr before calling <code>Base::Base</code> wouldn&#39;t work, because <code>Base::Base</code> sets the vptr to point to the
 <code>Base</code> vtable. <code>Base::Base</code> doesn&#39;t know that it&#39;s called in order to ultimately initialize a <code>Derived</code> object; the code
 of <code>Base::Base</code> and <code>Derived::Derived</code> is compiled separately <i><a class="corr" href="fqa.html#correction-1">(correction)</a></i>. That&#39;s what &quot;the object is still of type <code>Base</code>&quot; really means.
</p>

<p>
Now, there&#39;s a valid argument against describing the mechanisms of the implementation in order to explain the behavior
 of a system. The system is built by people for other people. Its behavior is supposed to make sense. If it doesn&#39;t,
and can only be explained by looking into the implementation instead of the needs of the user, it&#39;s a problem in the system.
 Sometimes such problems seem to be inevitable. But whenever possible, it&#39;s best to discuss why a certain behavior
is reasonable in the situation as perceived by the user, and  only talk about the implementation when absolutely necessary.
However, this argument is rarely applicable to C++.
</p>

<p>
First, C++ makes very little sense from the user&#39;s perspective. It only
 makes sense from the perspective of the language designer, provided that several axioms of questionable value are
 added to it
 (such as &quot;a language must look compatible with C, although it doesn&#39;t have to <a href="fqa.html#fqa-6.11">really be compatible</a>&quot;,
&quot;all built-in types <a href="fqa.html#fqa-17.6">should</a> be those found in C, unless they are <a href="fqa.html#fqa-33.7">a new kind of pointer</a>&quot;, etc.). For example, it is
 reasonable that <code>Base::Base</code> can&#39;t call <code>Derived::f</code> (well, sort of - it depends on what you think about the way
                                                                     C++ handles object construction in general). But is it reasonable that <code>Base::Base</code> <i>can</i> call a virtual method <code>Base::f</code> by simply saying
                                                                     <code>f()</code>? How often
 is that what you want? This question is irrelevant, because in C++, if something becomes technically possible as a side-effect
 of some language mechanism, it tends to be legal. For example, why does <code>private virtual</code> from <a href="fqa.html#fqa-23.4">the previous FAQ</a> compile?
 The answer is simple: why not?
</p>

<p>
The second reason to describe behavior in terms of implementation is that run time errors cause C++ programs to crash in ways
 undefined at the semantical specification level. It is theoretically possible to read the entire
 code of the program and find the semantically illegal code. In practice, you&#39;ll have to find the error by looking at the execution of the program
 (when you are lucky) or at a snapshot of its final state before the death (when you&#39;re not), and trying to understand
how things can behave this way. And you can&#39;t do that without understanding the implementation.
</p>


<a id="fqa-23.6"></a>
<h2>[23.6] Okay, but is there a way to <i>simulate</i> that behavior as <i>if</i> dynamic binding worked on the <code>this</code> object within my base class&#39;s constructor?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.6">FAQ:</a></b> Yes. It&#39;s an Idiom, of course. Namely, the <i>Dynamic Binding During Initialization Idiom</i>.
</p>

<p>
One option is to have a <code>virtual init</code> function to be called after construction. Another option is to have a second
hierarchy of classes, which doesn&#39;t always work, but... (sorry, I couldn&#39;t make it through all the code listings.
If you like lots of hierarchies of classes and find this solution interesting, please follow the link to the FAQ&#39;s
answer).
</p>

<p>
The first approach has the problem of requiring an extra function call upon initialization. We can rely on the self-discipline
of the programmers (the self-discipline is especially important when exceptions can be thrown by <code>init</code> - make sure you release the allocated object properly),
or we can wrap the construction and the <code>init</code> call in a single <code>create</code> function returning a
pointer to the object. The latter rules out allocation on the stack.
</p>

<p>
<b class="FQA">FQA:</b> We seem to be making progress. Let&#39;s see: we got rid of <a href="fqa.html#fqa-10.1">the allocation on the stack</a>, so we no longer
need to <a href="fqa.html#fqa-7.4">know</a> the <code>private</code> members of classes. And if we had <a href="fqa.html#fqa-16.1">garbage collection</a>, <a href="fqa.html#fqa-17.1">exception safety</a> would no longer be a problem,
either. Too bad C++ classes and memory management can&#39;t be changed. Or can they?
</p>

<p>
How about trying another programming language?
</p>


<a id="fqa-23.7"></a>
<h2>[23.7] I&#39;m getting the same mess with destructors: calling a <code>virtual</code> on my <code>this</code> object from my base class&#39;s destructor ends up ignoring the override in the derived class; what&#39;s going on?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.7">FAQ:</a></b> Again, you&#39;re being protected by the compiler. Protected from yourself! You could access members that were
already destroyed if the compiler let you do what you want.
</p>

<p>
When <code>Base::~Base</code> is called, the type of the object is changed from <code>Derived</code> to <code>Base</code>.
</p>

<p>
<b class="FQA">FQA:</b> Thanks for the protection. At least the behavior is <a href="fqa.html#fqa-23.5">symmetrical</a>.
</p>

<p>
Protect me from access to destroyed objects through <a href="fqa.html#fqa-16.1">dangling references</a> in <i>the general case</i> next time, will you?
</p>


<a id="fqa-23.8"></a>
<h2>[23.8] Should a derived class redefine (&quot;override&quot;) a member function that is non-<code>virtual</code> in a base class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.8">FAQ:</a></b> You can do that, but you shouldn&#39;t.
</p>

<p>
Experienced programmers sometimes do that for various reasons. Remember that the user-visible effects of both versions
of the functions must be identical.
</p>

<p>
<b class="FQA">FQA:</b> Here&#39;s a trade secret: not so experienced programmers do that, too. For the <a href="fqa.html#fqa-23.4">umpteen</a> time: <i>why does this compile</i>?
This particular case doesn&#39;t seem to be <a href="fqa.html#fqa-23.5">an unintended side effect</a>; it&#39;s a feature with elaborate design
(there&#39;s all this nonsense with <code>using</code> names from the base class shadowed by functions with the same name, etc.).
</p>

<p>
The redefinition-looking-like-an-override is <a href="fqa.html#fqa-13.1">overloading</a> on <a href="fqa.html#fqa-33.10">steroids</a>: it&#39;s even less useful and has even higher
 obfuscation potential. And it&#39;s only one of the zillions of various <i>name binding rules</i> - the bits of C++
 making it impossible to decipher what code is actually called by <code>f(x)</code>.
</p>


<a id="fqa-23.9"></a>
<h2>[23.9] What&#39;s the meaning of, <code>Warning: Derived::f(char) hides Base::f(double)</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.9">FAQ:</a></b> What do you think it means? You&#39;re going to die.
</p>

<p>
It&#39;s like this: <code>Derived::f(char)</code> doesn&#39;t override <code>Base::f(double)</code> - it hides it. In other words, it makes it impossible
 to call <code>Base::f(double)</code> via a <code>Derived*</code>. At the same time, <code>Derived::f(char)</code> can not be called via <code>Base*</code>.
</p>

<p>
<b class="FQA">FQA:</b> &quot;You&#39;re going to die&quot;, warns the FAQ. Well, according to a popular theory, all of us are. However, this interesting fact doesn&#39;t seem to belong here.
C++ surely is depressing, but I&#39;m not aware of any data showing a causal relationship between using C++ and suicide
 or lethal brain damage.
</p>

<p>
No, really, why is hiding a name <i>a lethal bug?</i> Sure, it makes the program more obscure, but, duh, this is C++.
 The worst thing that can happen is that someone will call <code>Base::f</code> with a <code>char</code> and <code>Base::f(double)</code>, not <code>Derived::f(char)</code>
 will get called. So what? Similar things happen with overloading without any inheritance involved. Do you really
 know the implicit conversion rules between different types, and can predict what happens when you pass an <code>int</code>
 to an overloaded <code>f</code> function which only has a <code>char</code> and a <code>double</code> version? I bet you can&#39;t do it when things
 get a little bit more complicated. No normal person can.
</p>

<p>
C++ overloading is a <a href="fqa.html#fqa-13.1">nightmare</a>. Using it is naive or stupid, depending on one&#39;s experience. Many languages, both statically and dynamically typed, don&#39;t
 have compile time overloading based on argument types. Have you ever heard a programmer using such a language
 complain about it, or become very enthusiastic about C++ overloading? What problem does overloading solve?
OK, suppose it improves clarity (a <i>very</i> questionable claim). Do you really think that overloading should come together
 with a ton of implicit conversion rules, and a type system with a ton of special cases
 (cv-qualifiers, pointers/arrays/references, single &amp; multiple inheritance, templates...)?
 When overloading does come with the extra ton of rules, does it <i>still</i> make the program more clear?
 What&#39;s that? &quot;Compile time polymorphism&quot;, you say? You mean <a href="fqa.html#fqa-35.1">C++ templates</a>? I see what you&#39;re up to. Happy debugging, pal.
</p>


<a id="fqa-23.10"></a>
<h2>[23.10] What does it mean that the &quot;virtual table&quot; is an unresolved external?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.10">FAQ:</a></b> Well, as you know, &quot;unresolved external&quot; means that there&#39;s a function or a global variable that your code declares
 and uses, but never defines. A virtual table is a global variable declared implicitly by a typical C++ implementation
 for each class with at least one virtual function.
</p>

<p>
Now, normally when you forget to define a virtual function, you&#39;ll get an &quot;unresolved external&quot; error saying that
 this function is missing. But in many implementations, if you forget the <i>first</i> virtual function, the whole
 virtual table will become &quot;unresolved&quot;. That&#39;s because these implementations define the virtual table
 at the translation unit where the first virtual function is implemented.
</p>

<p>
<b class="FQA">FQA:</b> GAAA!! So <a href="fqa.html#fqa-10.11">THAT'S</a> why you have to define <code>static</code> class variables explicitly in your .cpp file, but <i>don&#39;t</i> have to define vtables
 explicitly! This is sooo STUPID! I&#39;m shocked. Wait a second. Let me recover.
</p>

<p>
OK, here&#39;s how it works. In C++, there&#39;s really no such thing as &quot;a header file defining the class&quot; and &quot;a .cpp file
 implementing its functions&quot;. It&#39;s just a convention. According to the rules, the definition of the class members
 can be spread across several &quot;translation units&quot;, and each &quot;translation unit&quot; can in turn be spread across several
 files <code>#including</code> each other. This is inherited from C, and <a href="fqa.html#fqa-35.12">interacts badly</a> with the new features in C++.
</p>

<p>
For example, consider those virtual functions. You probably <a href="fqa.html#fqa-20.3">need a table of those</a>, which is similar to a global
 C variable. Of course you don&#39;t want to have the C++ programmer implement the table manually, the way they&#39;d do it in C - or else what&#39;s
 the point of the <code>virtual</code> keyword? But <i>where</i> should the vtable be implemented? In the .cpp file of a class? <i>Where&#39;s that?</i>
</p>

<p>
With vtables, there&#39;s a &quot;solution&quot;. After all, we don&#39;t need a vtable unless we have some virtual functions, do we?
 Well, then, one of these functions has to be the first one. Why not place the vtable near the definition of that function?
This is a good place, because it won&#39;t get <code>#included</code> twice (or the user will get a &quot;multiple definition&quot; error anyway).
</p>

<p>
And then there are the <code>static</code> class variables. Where do we stuff those? Well, um, there seems to be no good place at
 all; a class could consist of a single <code>static</code> member. No anchor in the sea of source code floating in the file system.
 Oh, well, we&#39;ll have the user choose a place for a duplicate <code>Type Class::member_name;</code> variable definition.
 A little bit more typing is not that bad.
</p>

<p>
I wonder what they do with <code>virtual</code> functions implemented in the body of a class though. I always wondered about those.
 Of course they can generate many vtables and throw away all copies but one the way they do with templates. But that
 won&#39;t work with a linker only supporting C. Maybe they didn&#39;t allow to implement non-<code>inline</code> functions in the body
 of a class before the brave decision to add features to the linker. Anyone knowledgeable about the history of the subject
 is welcome to enlighten me. However, the knowledge of the history of the subject can&#39;t possibly make this whole business
 seem less stupid to a language user.
</p>


<a id="fqa-23.11"></a>
<h2>[23.11] How can I set up my class so it won&#39;t be inherited from?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.11">FAQ:</a></b> You can have the constructors <code>private</code>. The objects will have to be created by <code>public</code> functions delegating to
 the constructor.
</p>

<p>
Alternatively, you can comment the fact that you don&#39;t want the class to be inherited from: <code>// if you inherit from
 this class, I&#39;ll hunt you down and kill you</code>.
</p>

<p>
There&#39;s a third solution (<b>WARNING</b> - this one can rot your brain): you can inherit your class from a <code>private virtual</code> base class, which has a <code>private</code> constructor
 and declares your class a <code>friend</code>. This way, if someone tries to inherit from you, they&#39;ll need to <a href="fqa.html#fqa-25.12">directly
 call</a> the base class of the constructor, which won&#39;t compile, since the constructor is <code>private</code>. This can add an extra word
 of memory to the size of your objects though.
</p>

<p>
<b class="FQA">FQA:</b> C++ doesn&#39;t have <code>final</code>. It probably isn&#39;t a big deal, especially considering the fact that if it <i>did</i> have
 <code>final</code>, it would be little more than a comment, just like <code>private</code> is <a href="fqa.html#fqa-7.4">little more than a comment</a>. So the
 comment-instead-of-a-keyword is probably the best approach.
</p>

<p>
The other approaches yield <a href="fqa.html#fqa-35.17">cryptic compile time error messages</a>. Many people in the C++ community believe that
 a cryptic compile time error message is <a href="fqa.html#fqa-33.4">a good thing</a>. This is probably reasonable if you only care about
 theory (&quot;early fault detection is good&quot;), and ignore <a href="fqa.html#fqa-6.1">practice</a> (<i>easy</i> fault detection is good, and running
a program <i>should</i> be easier than deciphering <a href="fqa.html#fqa-13.1">strongly encrypted</a> C++ compiler error messages, which tend
to come in large cascades).
</p>

<p>
Having no real experience with other languages helps one to stick to this bizarre point of view. C++ compiles <a href="fqa.html#fqa-35.12">very
 slowly</a>, so people who never worked with anything else <i>don&#39;t</i> think that running a program is easy. C++
 code is also hard to debug, so people develop a fear of run time errors.
</p>


<a id="fqa-23.12"></a>
<h2>[23.12] How can I set up my member function so it won&#39;t be overridden in a derived class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/strange-inheritance.html#faq-23.12">FAQ:</a></b> Use a <code>/* final */</code> comment instead of a <code>final</code> keyword. It&#39;s not a technical solution - so what?
 The important thing is that it works.
</p>

<p>
<b class="FQA">FQA:</b> So why does C++ have <code>private</code>? It&#39;s <a href="fqa.html#fqa-7.4">nothing but a comment</a> recognized by the compiler.
</p>

<p>
The real answer is as follows. If a function is not <code>virtual</code>, it shouldn&#39;t be overridden, as the FAQ itself has already <a href="fqa.html#fqa-23.8">explained</a>.
So the lack of a <code>virtual</code> keyword is effectively equivalent to a <code>final</code> keyword. Now if C++ didn&#39;t allow to
 override non-<code>virtual</code> methods, and if it would consistently require to use the <code>virtual</code> keyword in all virtual function
 declarations, it would be pretty clear which functions shouldn&#39;t be overridden in most cases.
</p>

<p>
If you look for non-technical solutions to overriding problems, consider banning non-<code>virtual</code> overrides
 in your organization. I didn&#39;t give this one a deep thought; quite frequently when you try to &quot;fix&quot; C++ by banning
 some of its features, but not others, your rules <a href="fqa.html#fqa-8.6">backfire</a>. And I can&#39;t know whether coding conventions
 work in your organization at all (believe me, there are <i>huge</i> and <i>very disciplined</i> organizations
where coding conventions are <i>not</i> really followed, and their primary effect is programmers feeling anger or guilt;
                                   another nice option is people mindlessly following &quot;best practices&quot;,
wreaking havoc in an orderly way). All I&#39;m saying is that non-<code>virtual</code> override seems both useless
 and largely independent of the rest of the language at first glance, so not using it looks like a good thing.
</p>

<a id="fqa-inheritance-multiple"></a><h1>Inheritance -- multiple and virtual inheritance</h1>
<p>
This section is about multiple inheritance. While inheritance and <code>virtual</code> functions are among the most useful (that is, <a href="fqa.html#fqa-20.1">the least useless</a>) C++ features, C++ multiple inheritance is at the other end of the spectrum.
</p>

<ul>
<li><a href="fqa.html#fqa-25.1">[25.1] How is this section organized?</a></li>
<li><a href="fqa.html#fqa-25.2">[25.2] I&#39;ve been told that I should never use multiple inheritance. Is that right?</a></li>
<li><a href="fqa.html#fqa-25.3">[25.3] So there are times when multiple inheritance isn&#39;t bad?!??</a></li>
<li><a href="fqa.html#fqa-25.4">[25.4] What are some disciplines for using multiple inheritance?</a></li>
<li><a href="fqa.html#fqa-25.5">[25.5] Can you provide an example that demonstrates the above guidelines?</a></li>
<li><a href="fqa.html#fqa-25.6">[25.6] Is there a simple way to visualize all these tradeoffs?</a></li>
<li><a href="fqa.html#fqa-25.7">[25.7] Can you give another example to illustrate the above disciplines?</a></li>
<li><a href="fqa.html#fqa-25.8">[25.8] What is the &quot;dreaded diamond&quot;?</a></li>
<li><a href="fqa.html#fqa-25.9">[25.9] Where in a hierarchy should I use virtual inheritance?</a></li>
<li><a href="fqa.html#fqa-25.10">[25.10] What does it mean to &quot;delegate to a sister class&quot; via virtual inheritance?</a></li>
<li><a href="fqa.html#fqa-25.11">[25.11] What special considerations do I need to know about when I use virtual inheritance?</a></li>
<li><a href="fqa.html#fqa-25.12">[25.12] What special considerations do I need to know about when I inherit from a class that uses virtual inheritance?</a></li>
<li><a href="fqa.html#fqa-25.13">[25.13] What special considerations do I need to know about when I use a class that uses virtual inheritance?</a></li>
<li><a href="fqa.html#fqa-25.14">[25.14] One more time: what is the exact order of constructors in a multiple and/or virtual inheritance situation?</a></li>
<li><a href="fqa.html#fqa-25.15">[25.15] What is the exact order of destructors in a multiple and/or virtual inheritance situation?</a></li>
</ul>

<a id="fqa-25.1"></a>
<h2>[25.1] How is this section organized?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.1">FAQ:</a></b> The FAQ section contains both &quot;high-level&quot; issues (the meaning &amp; purpose of the language constructs) and &quot;low-level&quot; issues
(the detailed semantics &amp; implementation of the language constructs), in that order. Be sure to understand the high-level stuff before
delving into the low-level stuff.
</p>

<p>
<b class="FQA">FQA:</b> This FQA section is organized exactly like the other FQA sections - by copying the structure of the FAQ sections.
</p>

<p>
The FAQ&#39;s note about the two levels of discussion is equally applicable to all C++ features/programming languages/software systems/formal definitions in the world. But it&#39;s located here and not elsewhere for a reason. The reason is
that C++ multiple inheritance makes very little sense even by C++ standards. In other words, the cases where you
can express a useful high-level idea using the actual features used to implement multiple inheritance in C++ are rare.
So people end up not using it, or abusing it, but fail to use it &quot;right&quot;, because it&#39;s unclear what &quot;right&quot; means
in this context.
</p>

<p>
The FAQ apparently believes that this situation can be fixed by explaining what &quot;right&quot; means.
Let&#39;s sit back and watch.
</p>


<a id="fqa-25.2"></a>
<h2>[25.2] I&#39;ve been told that I should never use multiple inheritance. Is that right?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.2">FAQ:</a></b> THESE PEOPLE REALLY BOTHER ME!! How can they know what you should do without knowing what you want done?!?!
</p>

<p>
<b class="FQA">FQA:</b> This rage may provoke some sympathy. We&#39;ve all met people who don&#39;t seem to be doing anything useful
themselves and compensate for it by getting in others&#39; way and telling them how to do their job, their ultimate goal apparently being to stop
any useful work around them. In particular, language features which should really <i>never</i> be used are rare. However,
language features which should be used really rarely and with careful consideration are <a href="fqa.html#fqa-23.12">more common</a>, and C++ multiple
inheritance is one of them.
</p>

<p>
There are two kinds of problems with multiple inheritance - &quot;static&quot; and &quot;dynamic&quot;.
</p>

<p>
The &quot;static&quot; problems have to do with
compile-time name lookup. Suppose you derive a class C from classes A and B, and both have a method called <code>name</code>. Which one
will get called when someone calls <code>name</code> using a pointer to a C object? If you override <code>name</code> in the class C, did you
override <code>A::name</code>, <code>B::name</code> or both? What happens if the two <code>name</code> functions accept arguments of the same type?
What happens if they don&#39;t?
</p>

<p>
The &quot;dynamic&quot; problems have to do with the way objects of the class C are actually built, and the run time effects
related to it. Basically, a C object will contain an A sub-object, and a B sub-object, and those two will be
completely unrelated. So if you have a pointer to a C object, and you (silently) upcast it to A*, and write code assuming
that you get an object which is derived from both A and B, and cast the A* to B*, the program will crash or worse. What you
should have done is first cast the object to C* and <i>then</i> to B*, since without knowing the definition of C, there&#39;s
<a href="fqa.html#fqa-32.8">no way</a> to figure out the location of the B sub-object given the location of the A sub-object. This is one trap
even a pretty experienced C++ programmer can fall into.
</p>

<p>
You can memorize the sharp edges, or you can stay away from the whole thing. Pick your poison.
</p>


<a id="fqa-25.3"></a>
<h2>[25.3] So there are times when multiple inheritance isn&#39;t bad?!??</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.3">FAQ:</a></b> Sure! Sometimes (but not always) using multiple inheritance will lower all kinds of costs. If this is so in your case,
use it! If it isn&#39;t, don&#39;t blame multiple inheritance - &quot;good workmen never blame their tools&quot;.
</p>

<p>
<b class="FQA">FQA:</b> No, there are no such times, it&#39;s a poorly designed language feature. But it could be that sometimes the other options
available in C++ are even worse.
</p>

<p>
While we&#39;re at it, let&#39;s clarify the whole blame issue. If you <i>choose</i> to use a tool not suitable for your job,
you shouldn&#39;t blame the tool. Well, actually, you should blame the vendor of the tool if it was advertised
as something it wasn&#39;t. Was C++ ever advertised that way, for example, what about
<a href="fqa.html#fqa-7.1">support for object-oriented programming</a>?
</p>

<p>
Well, we don&#39;t even need to discuss that, because a programming language is not exactly a tool. It is more accurately
described, well, as a <i>language</i>. The key difference between tools and languages in the context of &quot;blame&quot; is <i>choice</i>.
You probably don&#39;t choose to speak English - you do so in order to communicate with all the other people speaking
English. When a bunch of people do something because other people do it, too, it&#39;s called &quot;network effects&quot;.
For example, if you want to work on a project for reasons having nothing to do with computer linguistics,
and the project uses C++, you&#39;ll have to use C++, too. No choice.
</p>

<p>
So that&#39;s the difference between a language and a tool. Still, you wouldn&#39;t blame English because it&#39;s
so hard to learn or inconsistent or whatever, would you? Well, the difference between a programming language
and a natural language is that the latter is, um, natural, so there&#39;s nobody to blame, while the former
was actually designed by someone (well, usually). The other difference is <i>the cost of an error</i>. People
usually recover from bad English, computers tend to be less tolerant.
</p>

<p>
And this is why you seem to have more ground to &quot;blame the language&quot; than to &quot;blame the tools&quot; in the general case.
Of course you may not like the whole attitude of &quot;blaming&quot; things, etc.; everybody is free to feel
any way they feel like or something. But that
has nothing to do with being a &quot;good workman&quot; (which itself has an irksome sound to it, mind you).
</p>


<a id="fqa-25.4"></a>
<h2>[25.4] What are some disciplines for using multiple inheritance?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.4">FAQ:</a></b> There&#39;s a long answer saying 3 things. First, you should normally do it to achieve polymorphism, not base class code reuse.
Second, the classes you multiply inherit from should normally be pure abstract. Third, you should consider using
the &quot;bridge pattern&quot; or &quot;nested generalization&quot; - alternatives to MI described <a href="fqa.html#fqa-25.5">below</a>.
</p>

<p>
<b class="FQA">FQA:</b> The guidelines are pretty good, except for maybe &quot;nested generalization&quot;, which is really a way to work around the
deficiencies of the C++ object system rather than a reasonable way to model anything.
</p>

<p>
If you like &quot;disciplines&quot; without any reasoning having to do with the actual problem at hand, here&#39;s some more for you.
The FAQ&#39;s guidelines are a special case of &quot;don&#39;t use designs which would only work in one programming language&quot;
(footnote: <i>especially</i> if that language is C++). Specifically, the FAQ&#39;s guidelines pretty much summarize the <i>rules</i> for using
multiple inheritance in Java, so your design would be implementable in at least two languages, which is a good sign.
The reasoning behind the avoid-designs-tied-to-one-language rule is that if something is really good, many languages would have it, and if your design
depends on something only available in one language, it&#39;s probably bad because it probably depends on a bad thing.
This is the point where people loving the unique feature of language X scream that this reasoning is completely
<i>moronic</i>, but we already knew that, because we promised our reasoning wouldn&#39;t refer to the specific problem at hand, which isn&#39;t very
bright by itself.
</p>

<p>
If you&#39;re into real reasoning and not just &quot;disciplines&quot;, one nice thing about having the base classes pure is that this way,
you don&#39;t have to think about a whole class of questions related to reimplementation of methods. For example, if you
inherit a <code>RectangularWindow</code> from a <code>Rectangle</code> and a <code>Window</code>, and <code>Rectangle</code> isn&#39;t pure and it has a perfectly
good <code>resize</code> method, is this method still good for <code>RectangularWindow</code> or do you want it to resize the window, which
the implementation in the base class obviously won&#39;t do? And what if you can&#39;t <a href="fqa.html#fqa-23.8">really</a> override the <code>Rectangle::resize</code>
method because it isn&#39;t <code>virtual</code>? The problem with reusing code from the base class is that
multiple inheritance frequently breaks that code.
</p>

<p>
However, following these guidelines won&#39;t necessarily eliminate the problems with multiple inheritance mentioned <a href="fqa.html#fqa-25.2">above</a>.
</p>


<a id="fqa-25.5"></a>
<h2>[25.5] Can you provide an example that demonstrates the above guidelines?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.5">FAQ:</a></b> There&#39;s a very long discussion of an example with different kinds of vehicles having different kinds of engines.
The FAQ proposes to use MI, or the &quot;bridge pattern&quot; or &quot;nested generalization&quot;. &quot;Bridge pattern&quot; means that vehicle objects keep pointers to engine objects,
and users can pass many different kinds of engine to an object of the same vehicle class. &quot;Nested generalization&quot;
means that you have many classes derived from <code>Vehicle</code> (like <code>Plane</code>), and then for each such derived class there&#39;s a bunch of
classes derived from it to represent the different kinds of engine (like <code>OilPoweredPlane</code>). Trade-offs are discussed
in great detail.
</p>

<p>
<b class="FQA">FQA:</b> The &quot;bridge pattern&quot; (<a href="fqa.html#fqa-23.2">a fancy name</a> for the special case of aggregation when your member object has <code>virtual</code> functions) looks good here, since, um,
a vehicle has an engine and stuff. And hence multiple inheritance looks wrong, since an <code>OilPoweredPlane</code> isn&#39;t a kind
of an <code>OilPoweredEngine</code>.
</p>

<p>
I don&#39;t feel like arguing with the FAQ&#39;s lengthy statements, since the issue isn&#39;t worth it. The cases when you deal with the definition of
non-trivial object models are relatively rare. And when you do it, you have enough time to consider what stuff you
really want the model to support, and then think about the different possibilities to define the model and check if each possibility really supports that stuff.
I think that trying to memorize special cases (call them &quot;patterns&quot; or whatever) of object models is basically like
trying to formalize common sense, which doesn&#39;t really work.
</p>

<p>
Are you still with me after this blasphemy? Then let&#39;s look at one non-problem mentioned by the FAQ - the fact that with
aggregation (&quot;bridge pattern&quot;), you can&#39;t specialize algorithms such that a specific combination of vehicle and engine
exhibits a special behavior. In languages which support multimethods, doing that is trivial (multimethods are like <code>virtual</code>
functions, but they are dispatched at run time based on the types of all arguments, not just the first argument).
And in C++, you can emulate multimethods using double dispatching (ugly, especially when it becomes triple, quadruple
                                                                   and other such kinds of dispatching, but still possible).
</p>


<a id="fqa-25.6"></a>
<h2>[25.6] Is there a simple way to visualize all these tradeoffs?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.6">FAQ:</a></b> Here&#39;s a matrix with cute smilies for ya. Just don&#39;t apply it naively.
</p>

<p>
<i>Cute matrix omitted to avoid copyright problems, as well as cuteness problems</i>
</p>

<p>
<b class="FQA">FQA:</b> <b>WARNING:</b> there&#39;s no known way to represent common sense in a tabular form at the time of writing.
Therefore, if you choose to store the cute matrix anywhere in your brain, you do it at your own risk.
</p>


<a id="fqa-25.7"></a>
<h2>[25.7] Can you give another example to illustrate the above disciplines?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.7">FAQ:</a></b> Yes - consider the case with land &amp; water vehicles, when you also need to support amphibious vehicles. This case
is more &quot;symmetric&quot; than the <a href="fqa.html#fqa-25.5">previous</a> example, so multiple inheritance becomes more preferable. Still,
you have to make sure you really want it by asking various questions (for the list of questions, follow the link to the FAQ).
</p>

<p>
<b class="FQA">FQA:</b> Um, &quot;symmetry&quot; is an interesting aspect of this to focus on, but anyway, an amphibious vehicle is both a land vehicle
and a water vehicle, while an oiled powered plane is a plane, but is <a href="fqa.html#fqa-25.5">not</a> an oil powered engine. So yes, multiple
inheritance seems more appropriate, and yes, it&#39;s wise to think about the things you ultimately want your object
model to support before defining it.
</p>

<p>
We&#39;ll use the opportunity to show how to model this problem effectively using multiple inheritance
(implementation of multiple interfaces by the same class) without really using C++ multiple inheritance
(and thus avoiding some of its <a href="fqa.html#fqa-25.2">problems</a>). I&#39;m not saying that this always better
 than real C++ multiple inheritance, just that it sometimes can be.
</p>

<pre>
class AmphibiousVehicle {
  class WaterVehicleImpl : public WaterVehicle {
    WaterVehicleImpl(AmphibiousVehicle* p) { /* save p */ }
    ...
  };
  // similarly, there&#39;s a LandVehicleImpl class derived from WaterVehicle
  WaterVehicleImpl _water;
  LandVehicleImpl _land;
public:
  AmphibiousVehicle() : _water(this), _land(this) {}
  WaterVehicle&amp; getWaterVehicleIF() { return _water; }
  LandVehicle&amp; getLandVehicleIF() { return _land; }
};
</pre>

<p>
This way, you write more code than with multiple inheritance, which is bad.
It gets even uglier if you want to simulate <a href="fqa.html#fqa-25.9">virtual inheritance</a>,
which is bad if <code>WaterVehicle</code> and <code>LandVehicle</code> inherit from a non-abstract base class <code>Vehicle</code>
 (<a href="fqa.html#fqa-25.4">not necessarily recommended</a> by itself).
 And you have to call <code>get</code> functions
 instead of implicit upcasts, which may be considered good or bad.
 And there are no problems such as collisions
 between names of the members of the base classes (which is good).
</p>


<a id="fqa-25.8"></a>
<h2>[25.8] What is the &quot;dreaded diamond&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.8">FAQ:</a></b> It&#39;s when there are circles in the inheritance graph. Here&#39;s the simplest case: <code>Derived1</code> and <code>Derived2</code> are
 inherited from <code>Base</code>, and <code>Join</code> is inherited from both <code>Derived1</code> and <code>Derived2</code>. The circle in the graph may look
 like a diamond if your imagination works that way.
</p>

<p>
The problem is that <code>Join</code> objects have <i>two</i> <code>Base</code> sub-objects, so each data member is kept twice. Which is why
 the diamond is called &quot;dreaded&quot;.
</p>

<p>
The resulting ambiguities can be resolved. For example, when you have a <code>Join</code> object and refer to its <code>_x</code> variable inherited from <code>Base</code>,
 you can tell the compiler which one you mean using <code>Derived1::_x</code> or <code>Derived2_::x</code>. When you upcast from <code>Join*</code>
 to <code>Base*</code>, you can pick one of the two <code>Base</code> sub-objects by first casting the pointer to <code>Derived1*</code> or <code>Derived2*</code>.
 But this is almost always not the right thing to do. The right thing to do is usually to
 <a href="fqa.html#fqa-25.9">tell the compiler to keep a single sub-object</a>.
</p>

<p>
<b class="FQA">FQA:</b> Most C++ programmers out there don&#39;t understand why would anyone say <code>(Derived1*)pJoin</code> in a context where
 a <code>Base*</code> is expected. This by itself is a good reason to avoid having two sub-objects of <code>Base</code> in <code>Join</code>.
</p>

<p>
If you feel that things are getting pointlessly complicated at this point, it may be an indication of good taste.
</p>


<a id="fqa-25.9"></a>
<h2>[25.9] Where in a hierarchy should I use virtual inheritance?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.9">FAQ:</a></b> At the top of the dreaded diamond - when you derive from <code>Base</code>, you should say:
</p>

<pre>
class Derived1 : public virtual Base { ... };
class Derived2 : public virtual Base { ... };
</pre>

<p>
Note: when you define <code>Join</code>, you can&#39;t convince the compiler to keep a single <code>Base</code> sub-object - it will
 do whatever the definitions of <code>Derived1</code> and <code>Derived2</code> tell it to do. That is, when you define the
 classes derived from <code>Base</code>, you must plan ahead to support circles in the inheritance graph.
</p>

<p>
<b class="FQA">FQA:</b> Let&#39;s put aside the question whether the support for both options - one and two <code>Base</code> sub-objects -
 is a good thing, and concentrate on the way C++ gives you to choose between these options. Doing it
 &quot;at the top of the diamond&quot; is annoying, because you have to think about the entire hierarchy when you
 define the classes close to its top. That is, either <i>all</i> derived classes will have several <code>Base</code> sub-objects or
 <i>all</i> of them will have one (forcing the <a href="fqa.html#fqa-25.13">users</a> and the <a href="fqa.html#fqa-25.12">implementers</a> of derived classes to deal with the problems of virtual inheritance).
</p>

<p>
In general, it is a special case of the generic C++ principles of specifying everything in terms
 of <a href="fqa.html#fqa-15.1">types and their attributes</a>, as well as having the user <a href="fqa.html#fqa-32.8">deal with the low-level details</a>
 related to underlying language feature implementation.
</p>


<a id="fqa-25.10"></a>
<h2>[25.10] What does it mean to &quot;delegate to a sister class&quot; via virtual inheritance?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.10">FAQ:</a></b> If you have a <a href="fqa.html#fqa-25.9">diamond-like hierarchy with virtual inheritance</a>, and <code>Base</code> has two virtual functions f and g,
 then <code>Derived1</code> can implement f, <code>Derived2</code> can implement g and <code>Derived1::f</code> can call <code>Derived2::g</code> by simply
 saying <code>g();</code> or (more verbosely and equivalently) <code>Base::g();</code> - that is, without knowing anything about
 the existence of <code>Derived2</code>.
</p>

<p>
This is a &quot;powerful technique&quot;.
</p>

<p>
<b class="FQA">FQA:</b> &quot;Powerful&quot;. What exactly can you do this way that can&#39;t be done equally well or better in ways more clear
 to the average developer?
</p>

<p>
What&#39;s that? You say that you only care about the enlightened wizards (variant: the set of wizards consists of a single person - yourself),
 not the mediocre droids from the rank-and-file? Well, I&#39;ll leave the interesting discussion of your personality aside.
 I&#39;ll leave it aside in order to point out that some of the people whose programming abilities I admire can&#39;t be bothered to
 learn the quirks of C++ anywhere near my level. My level, in turn, isn&#39;t itself anywhere near &quot;complete&quot; knowledge
 of this wonderful language.
</p>


<a id="fqa-25.11"></a>
<h2>[25.11] What special considerations do I need to know about when I use virtual inheritance?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.11">FAQ:</a></b> Usually virtual inheritance is a good idea only if the virtual base class and classes derived from it have little
 or no data.
</p>

<p>
BTW, even if they have no data at all, using virtual inheritance can still be better than non-virtual inheritance.
 For example, if you have two <code>Base</code> sub-objects (with no members), you can end up with two pointers to the
 different sub-objects, and comparing them would tell you that these are two different objects, which they aren&#39;t,
 at some level. Quote: &quot;Just be careful - very careful&quot;.
</p>

<p>
<b class="FQA">FQA:</b> Yeah. Be vewy, vewy caweful...
</p>

<p>
The FAQ&#39;s advice is a special case of its <a href="fqa.html#fqa-25.4">other</a> advice about inheritance - data in base classes
 interacts badly with MI. And as the FAQ correctly points out, not having data in base classes
 doesn&#39;t solve all of the problems.
</p>


<a id="fqa-25.12"></a>
<h2>[25.12] What special considerations do I need to know about when I inherit from a class that uses virtual inheritance?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.12">FAQ:</a></b> Derived classes call the constructors of their virtual base classes directly. In particular, when a virtual
 base class has no default constructor, you have to call its constructor explicitly in the initialization
 lists of the constructors of the derived class.
</p>

<p>
If the base class follows <a href="fqa.html#fqa-25.11">the FAQ's advice</a> about not having data in virtual base classes, then the base class probably has a trivial default
 constructor and you don&#39;t have to care about the issue when you define derived classes.
</p>

<p>
<b class="FQA">FQA:</b> If the base class follows
<a href="fqa.html#fqa-10.6">the FQA's advice</a> to avoid non-trivial constructors and use
initialization functions when needed, you don&#39;t have to worry about initialization of derived classes
with virtual base classes, either.
</p>


<a id="fqa-25.13"></a>
<h2>[25.13] What special considerations do I need to know about when I use a class that uses virtual inheritance?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.13">FAQ:</a></b> Don&#39;t use downcasts using the C-like syntax <code>(Derived*)pBase</code>. Use <code>dynamic_cast&lt;Derived*&gt;(pBase)</code>.
</p>

<p>
The answer is unfinished according to a &quot;TODO&quot; remark in it.
</p>

<p>
<b class="FQA">FQA:</b> The problem seems to be that with virtual inheritance, the offset that must be added to <code>pBase</code> to make
 it <code>pDerived</code> depends on the classes <i>derived from Derived</i>
 (like the <code>Join</code> class from the <a href="fqa.html#fqa-25.8">"dreaded diamond"</a> example). So the compiler can&#39;t generate code
 adding a constant offset, which is what C-style casts do when it comes to class hierarchies (upcasting and downcasting).
</p>

<p>
Why does the code silently compile to a wrong program, despite the fact that C++
 <a href="fqa.html#fqa-25.9">already forced us</a> to inform the compiler that we have virtual inheritance at the definitions of
 the classes involved in the cast operation
 (not the definition of the <code>Join</code> class which isn&#39;t necessarily visible at the context where the cast operation is compiled)?
Why doesn&#39;t the compiler produce an error message or generates correct code as if we used <code>dynamic_cast</code>?
</p>

<p>
The answer is simple: in C++, the compiler compiles random meaningless things because it
<a href="fqa.html#fqa-23.5">can't be bothered</a> not to.
</p>


<a id="fqa-25.14"></a>
<h2>[25.14] One more time: what is the exact order of constructors in a multiple and/or virtual inheritance situation?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.14">FAQ:</a></b> So and so.
</p>

<p>
<b class="FQA">FQA:</b> I don&#39;t want to summarize it, because why would anyone want to know that? Well, except maybe to suppress
 stupid compiler warnings about the orders of things in initialization lists not matching the actual order of construction.
</p>

<p>
Well, <a href="fqa.html#fqa-25.12">why</a> would you use initialization lists?
</p>


<a id="fqa-25.15"></a>
<h2>[25.15] What is the exact order of destructors in a multiple and/or virtual inheritance situation?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/multiple-inheritance.html#faq-25.15">FAQ:</a></b> The reverse order of construction.
</p>

<p>
<b class="FQA">FQA:</b> Right. But you probably shouldn&#39;t write code that depends on these things. Your colleagues may get annoyed.
</p>

<a id="fqa-mixing"></a><h1>How to mix C and C++</h1>
<p>
These questions are about mixing C and C++, which may be harder than you&#39;d expect from the names of those languages, but easier than, say, <a href="fqa.html#fqa-32.1">mixing C++ and C++</a>. Stay tuned.
</p>

<ul>
<li><a href="fqa.html#fqa-32.1">[32.1] What do I need to know when mixing C and C++ code?</a></li>
<li><a href="fqa.html#fqa-32.2">[32.2] How can I include a standard C header file in my C++ code?</a></li>
<li><a href="fqa.html#fqa-32.3">[32.3] How can I include a non-system C header file in my C++ code?</a></li>
<li><a href="fqa.html#fqa-32.4">[32.4] How can I modify my own C header files so it&#39;s easier to #include them in C++ code?</a></li>
<li><a href="fqa.html#fqa-32.5">[32.5] How can I call a non-system C function <code>f(int,char,float)</code> from my C++ code?</a></li>
<li><a href="fqa.html#fqa-32.6">[32.6] How can I create a C++ function <code>f(int,char,float)</code> that is callable by my C code?</a></li>
<li><a href="fqa.html#fqa-32.7">[32.7] Why is the linker giving errors for C/C++ functions being called from C++/C functions?</a></li>
<li><a href="fqa.html#fqa-32.8">[32.8] How can I pass an object of a C++ <code>class</code> to/from a C function?</a></li>
<li><a href="fqa.html#fqa-32.9">[32.9] Can my C function directly access data in an object of a C++ <code>class</code>?</a></li>
<li><a href="fqa.html#fqa-32.10">[32.10] Why do I feel like I&#39;m &quot;further from the machine&quot; in C++ as opposed to C?</a></li>
</ul>

<a id="fqa-32.1"></a>
<h2>[32.1] What do I need to know when mixing C and C++ code?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.1">FAQ:</a></b>
 You should check your vendor&#39;s documentation. Most frequently the rules are:
</p>

<ul>
<li> You must compile <code>main</code> with your C++ compiler.</li>
<li> You must link everything with your C++ linker.</li>
<li> Your C and C++ compiler should be compatible, which probably means they should have the same vendor and version.</li>
</ul>

<p>
And you&#39;ll need to read the rest of this section so that your C functions can call your C++ functions and vice versa.
</p>

<p>
Or you can compile the C code with your C++ compiler - you may need to change the code, but you may also find bugs this
way, so it&#39;s a good thing to do. Unless you don&#39;t have the C code in source form, of course.
</p>

<p>
<b class="FQA">FQA:</b> You have little chances to successfully apply the rules unless you understand
the underlying technical problem the rules try to address. The problem is in all the things
in C++ that can not be translated to C straight-forwardly (mostly exceptions), and the things
which can be translated in <i>several</i> ways (initialization of global variables before <code>main</code>
and finalization after <code>main</code>, mangling names of overload &amp; template functions, virtual
function calls, constructor prototypes, layout of derived classes, RTTI - this list is quite
large). Many languages which are easy to mix with C have such features. However, unlike C++
they also come with a formal or a de-facto standard defining the ABI (application binary interface)
or a source-level interface for C interoperability. The C++ standard doesn&#39;t bother.
</p>

<p>
Most of these things can only cause problems when a particular C++ function is explicitly called.
This kind of things is addressed in the rest of the questions in this section. However,
the global initialization &amp; finalization sequences are never explicitly called - hence the
requirement about compiling <code>main</code> and linking the program with the C++ compiler. As to the
need to use C and C++ compilers from the same vendor - this is true in theory, but in practice
C compilers for a given hardware/OS configuration will interoperate smoothly. So will the
C++ compilers as long as the C subset of the calling conventions is involved. However, this requirement
is almost always a must when <i>mixing C++ and C++</i> - for example, when <a href="fqa.html#fqa-6.3">third-party libraries with C++ interfaces</a> are involved.
Think about it: mixing C and C++ is easier than mixing C++ and C++. Isn&#39;t this <i>amazing</i>?
</p>

<p>
This situation is one excellent reason <i>not</i> to follow the FAQ&#39;s advice to compile your C code
with a C++ compiler: C code is more portable. There are other reasons to keep C code in C, such
as compilation time, better accessibility (there&#39;s no name mangling so functions bundled into
a shared library are easier to call), etc.
</p>


<a id="fqa-32.2"></a>
<h2>[32.2] How can I include a standard C header file in my C++ code?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.2">FAQ:</a></b>
 Like this: <code>#include &lt;cstdio&gt;</code>, and then <code>std::printf(&quot;I like std::!\n&quot;)</code>. If you don&#39;t like
<code>std::</code>, get over it. That&#39;s the way standard names are accessed.
</p>

<p>
If you compile old C code with a C++ compiler, the following will also work: <code>#include &lt;stdio.h&gt;</code>,
and then <code>printf(&quot;No std::!\n&quot;);</code> - all due to the magic of namespaces.
</p>

<p>
If you want to include a <i>non-standard</i> C header, see the next questions.
</p>

<p>
<b class="FQA">FQA:</b> Um, if <code>printf</code> and <code>std::printf</code> both work, what&#39;s there to get over? <code>printf</code> is so standard
that there seems to be little point in mentioning it over and over again. As to the &quot;magic of namespaces&quot;,
this particular case doesn&#39;t really seem to have anything to do with it. For some reason, the global
unmangled <code>extern &quot;C&quot; printf</code> is also made accessible via <code>namespace std</code> by the C++ standard. What&#39;s
so mysterious or amusing here? Perhaps the FAQ meant &quot;the magic of standards&quot;.
</p>

<p>
If you want to include a non-standard C header, basically you&#39;ll have to <a href="fqa.html#fqa-32.3">tweak</a> them the same way your
compiler vendor tweaked the standard C headers.
</p>


<a id="fqa-32.3"></a>
<h2>[32.3] How can I include a non-system C header file in my C++ code?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.3">FAQ:</a></b>
 Like this:
</p>

<pre>
extern &quot;C&quot; {
#include &quot;foo.h&quot;
}
</pre>

<p>
If <code>foo.h</code> is your header, you can change it to make inclusion from C++ easier.
</p>

<p>
<b class="FQA">FQA:</b> The reason you have to do this is that C function names are not <i>mangled</i> - in C, there&#39;s
no overloading, so <code>printf</code> is known to the linkers, debuggers, etc. as <code>printf</code>. But in C++
there may be several functions with the same name. So the compiler has to make up a unique name using an encoding
of the argument types. For example, the GNU C compiler generates
an assembly function called <code>_Z6printfPKc</code> from C++ source code defining <code>int printf(const char*)</code>.
Different C++ compilers will do the name mangling differently - one of the many reasons making
them incompatible with each other.
</p>

<p>
Theoretically there may be more differences between C and C++ functions, and <code>extern &quot;C&quot;</code>
is your way to tell your C++ compiler &quot;these are C functions, deal with all the differences&quot;.
In practice, the problem is name mangling. Too bad there&#39;s no <code>extern &quot;C++ compiled with a different compiler&quot;</code>.
</p>


<a id="fqa-32.4"></a>
<h2>[32.4] How can I modify my own C header files so it&#39;s easier to #include them in C++ code?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.4">FAQ:</a></b>
 Like this:
</p>

<pre>
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
void foo();
void bar();
#ifdef __cplusplus
}
#endif
</pre>

<p>
Ew, macros are <i>evil</i>, <a href="fqa.html#fqa-6.16">wash your hands</a> when you are done.
</p>

<p>
<b class="FQA">FQA:</b> Together with the usual <code>#ifndef,#define,#endif</code> trinity, we&#39;ve just used 7 preprocessor
directives to define a single interface. And these seven directives contain zero information
specific to that interface. And they don&#39;t help the compiler to do things compilers of other
languages can do, like locating the implementation of the interface.
</p>

<p>
If you want to wash your hands after each preprocessor directive you touch in C++ and have
some time left to do anything else with those hands, you&#39;ll have to work in a bathroom.
</p>


<a id="fqa-32.5"></a>
<h2>[32.5] How can I call a non-system C function <code>f(int,char,float)</code> from my C++ code?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.5">FAQ:</a></b>
 Prefix its prototype with <code>extern &quot;C&quot;</code> when you declare it. You can declare
a whole bunch of C functions by surrounding the declarations with an <code>extern &quot;C&quot; { ... }</code>
block.
</p>

<p>
<b class="FQA">FQA:</b> Yeah, we&#39;ve <a href="fqa.html#fqa-32.4">been</a> through this already. It doesn&#39;t matter whether a declaration
is in a header file or not. Neither C nor C++ syntax is <a href="fqa.html#fqa-23.10">aware</a> of header files or other
preprocessor-related things. Header files are just an <a href="fqa.html#fqa-35.12">automated copy-paste mechanism</a>.
</p>


<a id="fqa-32.6"></a>
<h2>[32.6] How can I create a C++ function <code>f(int,char,float)</code> that is callable by my C code?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.6">FAQ:</a></b>
 Prefix the declaration and the definition with <code>extern &quot;C&quot;</code>. You can&#39;t have
more than one <code>f</code> C-callable function since C has no overloading.
</p>

<p>
<b class="FQA">FQA:</b> Oh, how simple! <i>And what if the function throws an exception</i>? You didn&#39;t think you were going
to escape <i>that</i> easily, did you?
</p>

<p>
I&#39;ve just tried this with the GNU C and C++ compilers. When a C++ function calls a C function
which calls a C++ function which throws an <a href="fqa.html#fqa-17.1">exception</a>, you can&#39;t even catch it at the first
C++ function, not to mention disposing the resources allocated by the C function.
</p>

<p>
So, make sure you catch all possible exceptions in your C-callable C++ functions. By the way, C++ exceptions
can be of <a href="fqa.html#fqa-17.6">any built-in or user-defined type</a>, and you can&#39;t catch an arbitrary exception and check
what kind of exception it is at run time, and <code>operator new</code> <a href="fqa.html#fqa-16.6">can throw exceptions</a>. Enjoy.
</p>


<a id="fqa-32.7"></a>
<h2>[32.7] Why is the linker giving errors for C/C++ functions being called from C++/C functions?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.7">FAQ:</a></b>
 You probably forgot <code>extern &quot;C&quot;</code>, so the linker looks for a <a href="fqa.html#fqa-32.3">mangled</a> C++ name instead
of an unmangled C name.
</p>

<p>
<b class="FQA">FQA:</b> Quiz: does a typical C++ linker <i>try to check</i> whether the unmangled C name is defined,
and if in fact it is, ask you something like &quot;did you forget <code>extern &quot;C&quot;</code>?&quot; Hint: if it actually did this simple thing,
how frequently would this question be asked?
</p>

<p>
You see, one of the advantages of using C++ is that you get to work with <a href="fqa.html#fqa-6.1">mature</a>,
industrial-strength tool chains.
</p>


<a id="fqa-32.8"></a>
<h2>[32.8] How can I pass an object of a C++ <code>class</code> to/from a C function?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.8">FAQ:</a></b>
 You can use <code>class Fred</code> in C++ (<code>#ifdef __cplusplus</code>), and a <code>typedef struct Fred Fred;</code> otherwise.
Then you can define <code>extern &quot;C&quot;</code> functions which accept <code>Fred*</code> (the FAQ contains two screens of code
illustrating this point, including both ANSI and K&amp;R C function prototypes).
</p>

<p>
Note that this way, C++ code will be able to tell whether two pointers to class objects point to
the same object, and C code won&#39;t. That&#39;s because when a pointer to a base class object is compared to
a pointer to a derived class object, the compiler may need to do some pointer arithmetics before the
comparison. In C++, this is done implicitly when the expression <code>p == q</code> is compiled.
</p>

<p>
Note that if you convert pointers to objects of classes to <code>void*</code> and compare them, neither C
nor C++ compilers will be able to do the right pointer adjustments.
</p>

<p>
<b class="FQA">FQA:</b> <i>Please</i> don&#39;t follow this advice! This FAQ keeps telling how <a href="fqa.html#fqa-6.15">evil</a> the preprocessor is,
and then it proudly presents this <i>really nasty</i> scheme. Defining type names to mean different
things based on a preprocessor flag is as close to &quot;evil preprocessor abuse&quot; as it gets. Especially
with all these pointer equality subtleties involved (these are <a href="fqa.html#fqa-25.11">ridiculous</a> by themselves - seriously,
if you can shoot yourself in the foot by simply <i>comparing two pointers to objects</i>, how &quot;object-oriented&quot;
is the language?).
</p>

<p>
Here&#39;s a pretty straight-forward solution: in the header file which is supposed to be used from C,
declare a <code>struct FredObj</code> or something (just <i>use a different name</i> than <code>Fred</code>, so that people can
at least figure out what each name means! Sheesh!). In the C++ implementation file, define the structure
to hold a single member - a <code>Fred</code> object. This doesn&#39;t lead to any run-time overhead. The extra
syntax needed for dereferencing is worth the benefits -  you can compare pointers and have fun in safety.
</p>

<p>
And if you <i>really</i> need to return objects of classes
derived from Fred - <i>just define a structure with a single member of type</i> <code>Fred*</code> <i>and never mind
the tiny run-time overhead</i>. If you are using class hierarchies to implement functionality so simple
that this tiny run-time overhead is comparable to the actual work done by the classes,
<i>throw these class hierarchies away</i> and stop messing
up the lives of your innocent users.
</p>

<p>
Why do these people have to make everything cryptic <i>and</i> dangerous?
</p>


<a id="fqa-32.9"></a>
<h2>[32.9] Can my C function directly access data in an object of a C++ <code>class</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.9">FAQ:</a></b>
 Yes, if the class has no <code>virtual</code> functions or non-public members, and so do all objects
it contains by value. The FAQ outlines the way inheritance and virtual functions are implemented
at a level allowing you to do the pointer arithmetics in order to access member data from C in
these clearly illegal cases.
</p>

<p>
<b class="FQA">FQA:</b> <i>&quot;Can&quot;</i> may mean many things: &quot;can do it with a particular version of C &amp; C++ compilers&quot;,
&quot;can do it with all compilers which are actually out there&quot;, &quot;can do it with any standard-conforming
compilers&quot;, and even &quot;should normally do it because provisions were made to make it easy&quot;.
</p>

<p>
The short answer is that you should only do it with the so-called POD types
(which basically means &quot;structures
defined using C syntax&quot; for people who are not professional language lawyers). The only reasonable
cases when breaking the rules is not an entirely moronic act are (1) when you play around with the language
to see what&#39;s inside, (2) when you have to retrieve data from classes with definitions only available
in binary form (you may want to check if your actions are legal first) and (3) you are implementing a debugger
or the like, in which case you&#39;re writing legitimately non-portable code.
</p>

<p>
In case (2), you could also ask &quot;Can my C++ function directly access private data in an
 object of a C++ class&quot;. Most often it can if you add a <code>#define private public</code> preprocessor directive
 at the top of your <code>.cpp</code> file. This works quite portably and does not depend on the layouts of C++ classes in your particular compiler.
</p>

<p>
People who want their C code to directly access data of a C++ class object for &quot;speed&quot; or something
probably don&#39;t have enough real problems. The artificial problems they create for themselves will
teach them a good lesson pretty soon.
</p>


<a id="fqa-32.10"></a>
<h2>[32.10] Why do I feel like I&#39;m &quot;further from the machine&quot; in C++ as opposed to C?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/mixing-c-and-cpp.html#faq-32.10">FAQ:</a></b>
 You are! C++ is a high-level language. In C, you can see where every clock cycle is spent;
on the other hand, in C++ you can work at higher levels of abstraction and write more compact programs.
Of course you can still write bad code - the idea is not to prevent bad programmers from doing it,
but make it possible for the reasonable ones to write superior code!
</p>

<p>
<b class="FQA">FQA:</b> What is this question doing here? Presumably people try to mix C and C++, and have an <code>extern &quot;C&quot;</code>
function implemented in C++ throw an exception, or the initialization stuff before <code>main</code> never gets
called, or they compare pointers to C++ class objects from C and it doesn&#39;t work, and they don&#39;t know why
or how to even start figuring it out. The real question
probably is &quot;why do I feel like I&#39;m underneath the machine, not just close to it as opposed to C&quot;?
</p>

<p>
C++ is not a higher-level language than C. The damage caused by low-level errors is still not limited. You
still have to think about pointers and object life cycles and integer endianness and many other things.
But on top of that, there&#39;s a huge amount of things done implicitly, like global initialization and
destruction, stack unwinding, base/derived classes pointer adjustment, and many more things - and all of them
combine with the low-level errors into a single deep, wide tar pit with the programmer in the middle.
</p>

<p>
A good high-level language allows you to forget about many small details of program execution.
A good low-level language allows you to control the many small details of program execution. C++ is not much
of a high-level language, but it&#39;s not a very good low-level language either.
</p>

<p>
As to the remark about &quot;seeing every cycle spent in C programs&quot;, I really believe that the FAQ author knows
 that you can&#39;t see that,
since that&#39;s a pretty basic fact. You can&#39;t &quot;see every cycle&quot; spent in <i>assembly</i> programs in most cases - you
have to know the exact target processor variant and the system configuration and a zillion other things. The FAQ
is probably just being poetical.
</p>

<p>
But there&#39;s more to this remark than factual inaccuracy - it concentrates on a moderate problem, failing
to mention an arguably more severe one. Consider the C++ code <code>p = obj.getVec().begin();</code>.
The run-time of this code is unclear because it depends on whether <code>obj</code> is a value or a reference (the
latter may be slower); in C it would be more clear. But there&#39;s another issue: is this code correct
at all? If <code>getVec()</code> returns a reference to <code>std::vector</code> object, maybe it is correct, but if it returns it
by value, it is certainly wrong. The compiler won&#39;t even warn you, and you won&#39;t <a href="fqa.html#fqa-8.6">notice</a> the problem in the code without
checking the definition of <code>getVec</code>. Not only is it hard to figure out how much time a C++ program runs,
it is hard to even tell what it <i>does</i>, which is not supposed to be typical of high-level languages.
</p>

<a id="fqa-function"></a><h1>Pointers to member functions</h1>
<p>
This is basically about the lack of function objects and closures in C++.
</p>

<ul>
<li><a href="fqa.html#fqa-33.1">[33.1] Is the type of &quot;pointer-to-member-function&quot; different from &quot;pointer-to-function&quot;?</a></li>
<li><a href="fqa.html#fqa-33.2">[33.2] How do I pass a pointer-to-member-function to a signal handler, X event callback, system call that starts a thread/task, etc?</a></li>
<li><a href="fqa.html#fqa-33.3">[33.3] Why do I keep getting compile errors (type mismatch) when I try to use a member function as an interrupt service routine?</a></li>
<li><a href="fqa.html#fqa-33.4">[33.4] Why am I having trouble taking the address of a C++ function?</a></li>
<li><a href="fqa.html#fqa-33.5">[33.5] How can I avoid syntax errors when calling a member function using a pointer-to-member-function?</a></li>
<li><a href="fqa.html#fqa-33.6">[33.6] How do I create and use an array of pointer-to-member-function?</a></li>
<li><a href="fqa.html#fqa-33.7">[33.7] Can I convert a pointer-to-member-function to a <code>void*</code>?</a></li>
<li><a href="fqa.html#fqa-33.8">[33.8] Can I convert a pointer-to-function to a <code>void*</code>?</a></li>
<li><a href="fqa.html#fqa-33.9">[33.9] I need something like function-pointers, but with more flexibility and/or thread-safety; is there another way?</a></li>
<li><a href="fqa.html#fqa-33.10">[33.10] What the heck is a functionoid, and why would I use one?</a></li>
<li><a href="fqa.html#fqa-33.11">[33.11] Can you make functionoids faster than normal function calls?</a></li>
</ul>

<a id="fqa-33.1"></a>
<h2>[33.1] Is the type of &quot;pointer-to-member-function&quot; different from &quot;pointer-to-function&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.1">FAQ:</a></b> It is.
</p>

<p>
If you have a non-member function <code>void f(int)</code>, then <code>&amp;f</code> is of type <code>void (*)(int)</code>.
</p>

<p>
If you have a non-<code>static</code> member function <code>void C::f(int)</code>, then <code>&amp;C::f</code> is of type <code>void (C::*)(int)</code>.
</p>

<p>
<b class="FQA">FQA:</b> Ahem.
<code>::*)(</code> - line noise creeps in. There&#39;s more of it in the rest of this section.
</p>

<p>
Anyway, the reason the types <i>should</i> be different is that a member function accepts a hidden
parameter - <code>this</code>. And the types of function pointers are derived from the types
      of the arguments and the return value. Obviously, the self-documenting bit of syntax <code>C::*</code>
      says that the function gets a <code>this</code>
      parameter of type <code>C</code>.
</p>


<a id="fqa-33.2"></a>
<h2>[33.2] How do I pass a pointer-to-member-function to a signal handler, X event callback, system call that starts a thread/task, etc?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.2">FAQ:</a></b> You don&#39;t. A member function can&#39;t be used without an object of the class, so the whole thing can&#39;t work.
What you can do is write a non-member function wrapping your pointer-to-member-function call.
</p>

<p>
For example,
      thread creation callbacks usually have a <code>void*</code> argument. You could pass an object pointer
      in that argument to the callback (which has to be a non-member). The callback would then cast the <code>void*</code> down to the actual type and call
      the object&#39;s method.
</p>

<p>
Some functions, like <code>signal</code>, use callbacks without a <code>void*</code> argument or anything similar. In that case, you have
      no choice but save a pointer to the object in a global variable. The callback can get the object
      pointer from that global variable and call the method.
</p>

<p>
<code>static</code> member functions <i>can</i> be used in the contexts where a C callback is expected, if
      they are <code>extern &quot;C&quot;</code>. Although on most compilers it would probably work without <code>extern &quot;C&quot;</code>,
      the standard says it doesn&#39;t have to work.
</p>

<p>
<b class="FQA">FQA:</b> The picture painted by the FAQ isn&#39;t very pretty, but the reality can get even worse - that is,
      more code to write. For example, you may want to call <i>any</i> method of an object - to select
      the method to call at run time, not compile time. <i>That</i> would really mean
      that you want to pass a pointer-to-member-function as a callback, which is what the question
      is all about. In the scenario in the FAQ,
      your problem is <i>passing the object pointer</i>, but there&#39;s actually <i>no pointer to a member function</i>.
</p>

<p>
Anyway, in this &quot;full-blown&quot; use case, passing just the object pointer via the
      <code>void*</code> argument is not enough. You&#39;d have to wrap the two pointers (the object pointer and the function pointer)
      in a structure, pass a <code>void*</code> to that structure to your callback and unpack the structure in that callback.
      Simple, but quite verbose. Pretty much like implementing function calls in assembly.
</p>

<p>
This illustrates the fact that C++ is a very low-level language. When you have a Python object <code>obj</code>
      with a method <code>func</code>, and you want someone expecting a callback to call <code>obj.func()</code>, you can create the callback object
      with the expression <code>obj.func</code>. As simple as that. In some high-level languages doing this is equally easy
      and in some it&#39;s more verbose, but <i>never, ever</i> would you have to save a pointer to your
      object to a global variable (and worry about making it thread-local when relevant, etc.).
</p>

<p>
The problem is that in C++, there&#39;s no single concept of a &quot;callable object&quot; - instead, there are <a href="fqa.html#fqa-33.7">unrelated</a>
      low-level mechanisms for calling functions. For example, non-member function pointers work differently
      from member function pointers. There are ubercompetent people out there who actually think they
      can get away with casting <code>void (C::*p)(int)</code> to type <code>void (*)(C*,int)</code>, because, you know,
      what we need is to pass <code>this</code> as the first parameter. This can work with many compilers, until
      you need to pass a pointer to a <code>virtual</code> function. Outsmarting compilers is usually dumb,
      especially C++ compilers. There really <i>is</i> more than one function call mechanism, and the different
      kinds of function pointer are not convertible - you have to implement adapters of varying
      degrees of clumsiness.
</p>

<p>
Regarding the <code>static</code>-members-as-callbacks issue: if your implementation uses different binary calling conventions for C functions and C++ <code>static</code> member
      functions, call the support and inform them that their developers consume mind-altering chemicals at work.
</p>


<a id="fqa-33.3"></a>
<h2>[33.3] Why do I keep getting compile errors (type mismatch) when I try to use a member function as an interrupt service routine?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.3">FAQ:</a></b> This is a special case of the <a href="fqa.html#fqa-33.2">previous</a> question.
</p>

<p>
<b class="FQA">FQA:</b> It is. So we&#39;ll use the opportunity to - surprise! - point out that handling interrupts in C++ can be done
      <i>just as well</i> as anything else. <i>Not much of a compliment</i>, really, but worth noting.
</p>

<p>
One of the problems
      with C++ is all the <i>unjustified</i> criticism. For example, some people will scream something like
      &quot;What?! Handling interrupts in C++?!&quot; - possibly followed by (false) claims about C++ being
      a &quot;high-level language&quot; (yeah, right) and maybe remarks about your mental health and stuff.
      These people don&#39;t know what they&#39;re talking about, and can make other people believe that C++
      only looks like a bad thing if one doesn&#39;t know what he&#39;s talking about.
</p>

<p>
Clarifications: of course you shouldn&#39;t throw exceptions in interrupt handlers, or call <code>new</code>, etc. Of course
      doing the job in C would be better, but this isn&#39;t special to interrupts. Of course
      many C++ features can do more damage when you <a href="fqa.html#fqa-13.3">use them
      to talk to hardware</a> than elsewhere. All I&#39;m saying is that when you criticize something,
you either accompany your claims with some reasoning or you have no chance to convince people
      (at least not the ones worth the effort).
</p>


<a id="fqa-33.4"></a>
<h2>[33.4] Why am I having trouble taking the address of a C++ function?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.4">FAQ:</a></b> Mmmm, you&#39;re trying to take the address in order to use it as a C function pointer, aren&#39;t you? Well,
<a href="fqa.html#fqa-33.2">don't do that</a>.
      And don&#39;t try to cast your way out of this, it won&#39;t work.
</p>

<p>
<b class="FQA">FQA:</b> The FAQ didn&#39;t answer your question, did it? Instead, it assumed it knew what your problem was,
 and then answered a different question.
 Well, you could also ask your original question for a different reason.
 Specifically, you are already aware of the fact that <code>&amp;C::f</code> <a href="fqa.html#fqa-33.1">has a different type</a> than <code>&amp;f</code>, but you don&#39;t know
how to spell that type. So you&#39;re doing something semantically sensible, but you can&#39;t get the syntax right,
 because C++ has <a href="fqa.html#fqa-35.16">so much syntax making so little sense</a>.
</p>

<p>
Well, I don&#39;t know the type of <code>&amp;C::f</code> either, because it depends on the arguments;
 I only know it&#39;s something like <code>T1 (C::*)(T2,T3,T4)</code>. So here&#39;s a way to find out the type of an arbitrary C++ expression:
</p>

<pre>
 template&lt;class T&gt;
 void show_type(const T&amp;)
 {
   int eat_flaming_death[-1];
 }
 void test_func()
 {
   show_type(&amp;C::f);  
 }
</pre>

<p>
The compiler will then say something like <code>In void show_type&lt;TheTypeYouWantedToFigureOut&gt;(): arrays of negative size are not allowed</code>.
In our case, <code>TheTypeYouWantedToFigureOut</code> will be substituted with the type of <code>&amp;C::f</code>.
</p>

<p>
Here&#39;s the best part: there&#39;s a large <a href="http://www.boost.org/doc/html/boost_staticassert.html">"compile time assertions"</a> movement promoting a plethora of arcane macros
 and templates which,
 like <code>show_type</code>, will cause the compiler to fail with an error message hopefully mentioning something
 related to the problem. This kind of thing is a <i>best practice</i> in C++. Isn&#39;t life amazing?
</p>


<a id="fqa-33.5"></a>
<h2>[33.5] How can I avoid syntax errors when calling a member function using a pointer-to-member-function?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.5">FAQ:</a></b> With a <code>typedef</code>, making the type name readable, and a <code>#define</code> macro, making the <code>((obj).*(func))</code> syntax readable.
 Ewww, macros are <a href="fqa.html#fqa-6.15">evil</a>!
</p>

<p>
There were <i>hundreds</i> of postings to <code>comp.lang.c++</code> about this, says the FAQ. The layer of syntax proposed above
 could save the traffic.
</p>

<p>
<b class="FQA">FQA:</b> The FAQ actually proposes to use the old and oh-so-evil C macros to cover up the brand new syntax introduced in C++. The FQA
 will avoid further comments on this advice, since the target is too easy.
</p>

<p>
The amazing part about the hundreds of messages is not the fact that people can&#39;t get the C++ syntax right.
 The amazing part is the fact that people <i>wanted to use</i> pointers to member functions, despite the fact
 that they are pretty useless. What you really need quite frequently is &quot;delegates&quot; or &quot;functors&quot; or &quot;closures&quot; - well,
 anything that represents <i>both</i> the code (a function/an expression/...) and the data
 (an object/bound local variables/...). C++
 <a href="fqa.html#fqa-33.10">doesn't</a> support these things very well. Perhaps the <code>comp.lang.c++</code> posters tried to implement
  something like this on top of C++ object and member function pointers. Maybe even something generic,
  with templates inheriting from abstract base classes involved. Yeah, that sounds quite like
  the favorite pass-time of C++ developers.
</p>


<a id="fqa-33.6"></a>
<h2>[33.6] How do I create and use an array of pointer-to-member-function?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.6">FAQ:</a></b> First, <a href="fqa.html#fqa-33.5">add</a> a <code>typedef</code> and a macro. Then, use <code>FuncPtrType arr[] = {&amp;C::f, &amp;C::g, &amp;C::h};</code>
</p>

<p>
<b class="FQA">FQA:</b> Hey, why are we using an <a href="fqa.html#fqa-6.15">evil</a> C array? Me not like this. How about:
</p>

<pre>
std::vector&lt;FuncPtrType&gt; arr;
arr.push_back(&amp;C::f);
arr.push_back(&amp;C::g);
arr.push_back(&amp;C::h);
</pre>

<p>
There, it&#39;s much better now. Wait till you see the full type name of <code>arr</code> in a <a href="fqa.html#fqa-35.17">compiler error message</a>.
</p>


<a id="fqa-33.7"></a>
<h2>[33.7] Can I convert a pointer-to-member-function to a <code>void*</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.7">FAQ:</a></b> No, and if it seems to work on some platform, it doesn&#39;t make it legal.
</p>

<p>
<b class="FQA">FQA:</b> Listen to the FAQ. This isn&#39;t just language lawyer talk - it <i>really</i> isn&#39;t going to work.
  Check out <a href="http://www.codeproject.com/cpp/FastDelegate.asp">this article</a> - it has a lot of material
  on C++ member function pointers. <b>WARNING:</b> this stuff can be used to scare little children.
</p>

<p>
The bottom line is that unlike a global function pointer,
 a member function pointer is not just the address of the first instruction of the function in most implementations,
  apparently with the exception of the compiler by <a href="http://www.digitalmars.com/">Digital Mars</a>
  (the company behind <a href="http://www.digitalmars.com/d/index.html">the D language</a>). That compiler generates &quot;thunk code&quot; which handles the differences
  between various dispatching mechanisms (<code>virtual</code> vs. statically dispatched functions, different kinds of inheritance),
  and uses the address of that thunk code to represent member function pointers. Quote from the article
  about this implementation: &quot;Why doesn&#39;t everyone else do it this way?&quot;
</p>

<p>
So, really, don&#39;t cast these things to <code>void*</code> - you can&#39;t even sensibly cast them to non-member function pointers.
</p>


<a id="fqa-33.8"></a>
<h2>[33.8] Can I convert a pointer-to-function to a <code>void*</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.8">FAQ:</a></b> Stop that. No. And don&#39;t tell me it worked for you. It&#39;s illegal.
</p>

<p>
<b class="FQA">FQA:</b> C and C++ strongly separate between code and data (so do many languages and hardware processor implementations).
  A pointer to a data object is not the same as a pointer to a function. However, in the vast majority of implementations
  their sizes are going to be the same, so it&#39;s possible to convert a function pointer to a <code>void*</code>, and
  then somewhere else convert it back and call the function.
</p>

<p>
This violates the language rules. So does code assuming 2&#39;s complement integers and IEEE floating point.
  The chance of both kinds of code to actually fail on an interesting platform is low. Admittedly, the
  code-pointers-are-just-like-data-pointers assumption is less useful than
  the signed-numbers-can-be-divided-using-right-shift assumption, though.
  So typically one wouldn&#39;t do this kind of cast, after all.
</p>


<a id="fqa-33.9"></a>
<h2>[33.9] I need something like function-pointers, but with more flexibility and/or thread-safety; is there another way?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.9">FAQ:</a></b> A functionoid is what you need.
</p>

<p>
<b class="FQA">FQA:</b> &quot;Functionoid&quot; rhymes with <a href="http://foldoc.org/?marketroid">"marketroid"</a>, and is a term local to the FAQ,
  used instead of the standard term
  <a href="fqa.html#fqa-33.10">"functor"</a>.
</p>


<a id="fqa-33.10"></a>
<h2>[33.10] What the heck is a functionoid, and why would I use one?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.10">FAQ:</a></b> It means &quot;a function on steroids&quot;, of course. The FAQ goes on to describe a class with a single <code>virtual</code> function
  called <code>doit</code>. An object of this class is basically just like a function except you can pass it arguments in its constructor,
  and it can keep state between calls without thread-unsafe global variables. The discussion is very lengthy and didactic, there are lots of
  examples. If you didn&#39;t say to yourself something like &quot;Oh, yeah, that problem&quot;, you can follow the link
to the real FAQ&#39;s answer to see what this is all about.
</p>

<p>
<b class="FQA">FQA:</b> A &quot;functionoid&quot;
(or functor, as it&#39;s normally called) is basically a manual emulation of
 <a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">closures</a>. Closures can save all those little
 classes people create in order to have a function-pointer-plus-some-context. For example,
 the following code, which tries to use a higher-order function (<code>for_each</code>) in a language without
 closures (C++), is completely ridiculous:
</p>

<pre>
struct Printer
{
  std::ostream&amp; out;
  Printer(std::ostream&amp; o) : out(o) {}
  template&lt;class T&gt;
  void operator()(const T&amp; x) const { out&lt;&lt;x&lt;&lt;std::endl; }
};
void print_them(const std::vector&lt;int&gt;&amp; them)
{
  std::for_each(them.begin(), them.end(), Printer(std::cout));
}
</pre>

<p>
Clearly, a <code>for</code> loop wouldn&#39;t be nearly as bad. However, if we had closures, we could do something like this:
</p>

<pre>
void print_them(const std::vector&lt;int&gt;&amp; them)
{
  std::for_each(them.begin(), them.end(), lambda(x) { std::cout &lt;&lt; x &lt;&lt; std::endl; });
}
</pre>

<p>
This would still be verbose because of smaller problems (<code>std::</code>, mentioning <code>them</code> twice),
 but at least the stupid <code>Printer</code> class is now replaced with code generated implicitly by the compiler.
</p>

<p>
Check out the monstrous <a href="http://www.boost.org/doc/html/lambda.html">boost lambda library</a> designed to work around the lack of closures in C++
 in a desperate attempt to make higher-level functions of the kind defined at <code>&lt;algorithm&gt;</code> not
 entirely useless. When I tried it, <code>gcc</code> wouldn&#39;t compile it without <code>-ftemplate-depth=40</code>
 (the default template nesting depth limit, 17, is not enough for this library),
 and I got <i>5 screens</i> of error messages from <i>a single line of code using the thing</i>. See also <a href="http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/100dd325c6d9ef77/a4444dc5dc9d94c0">this thread</a>,
 especially the part where they explain how <code>cout &lt;&lt; _1 &lt;&lt; endl</code> works
 but <code>cout &lt;&lt; &quot;\t&quot; &lt;&lt; _1 &lt;&lt; endl</code> doesn&#39;t (to get there quick, search for &quot;fails miserably&quot;, then continue to the reply).
</p>


<a id="fqa-33.11"></a>
<h2>[33.11] Can you make functionoids faster than normal function calls?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/pointers-to-members.html#faq-33.11">FAQ:</a></b> Sure! Instead of <code>virtual</code> functions, use <code>inline</code> member functions and make the code using the
 &quot;functionoid&quot; a template.
</p>

<p>
<b class="FQA">FQA:</b> This way the &quot;functionoid&quot; will compile slower than &quot;normal function calls&quot; though, not to mention
 the loss of flexibility at run time.
 The run time speed impact of the obsolete approach to inlining used by C++ is discussed <a href="fqa.html#fqa-9.3">here</a>.
 The compile time speed impact of C++ templates is discussed <a href="fqa.html#fqa-35.12">here</a>.
 The fact that it&#39;s <i>your</i> job to make sure things are inlined properly in this family of scenarios
 is one problem with the lack of closures in C++ discussed <a href="fqa.html#fqa-33.10">above</a>.
</p>

<a id="fqa-templates"></a><h1>Templates</h1>
<p>
This page is about C++ templates, one of the largest cannons to aim at your feet that the C++ arsenal has to offer. Templates solve the problems with C macros by creating 2 orders of magnitude more problems.
</p>

<ul>
<li><a href="fqa.html#fqa-35.1">[35.1] What&#39;s the idea behind templates?</a></li>
<li><a href="fqa.html#fqa-35.2">[35.2] What&#39;s the syntax / semantics for a &quot;class template&quot;?</a></li>
<li><a href="fqa.html#fqa-35.3">[35.3] What&#39;s the syntax / semantics for a &quot;function template&quot;?</a></li>
<li><a href="fqa.html#fqa-35.4">[35.4] How do I explicitly select which version of a function template should get called?</a></li>
<li><a href="fqa.html#fqa-35.5">[35.5] What is a &quot;parameterized type&quot;?</a></li>
<li><a href="fqa.html#fqa-35.6">[35.6] What is &quot;genericity&quot;?</a></li>
<li><a href="fqa.html#fqa-35.7">[35.7] My template function does something special when the template type <code>T</code> is <code>int</code> or <code>std::string</code>; how do I write my template so it uses the special code when <code>T</code> is one of those specific types?</a></li>
<li><a href="fqa.html#fqa-35.8">[35.8] Huh? Can you provide an example of template specialization that doesn&#39;t use <code>foo</code> and <code>bar</code>?</a></li>
<li><a href="fqa.html#fqa-35.9">[35.9] But most of the code in my template function is the same; is there some way to get the benefits of template specialization without duplicating all that source code?</a></li>
<li><a href="fqa.html#fqa-35.10">[35.10] All those templates and template specializations must slow down my program, right?</a></li>
<li><a href="fqa.html#fqa-35.11">[35.11] So templates are overloading, right?</a></li>
<li><a href="fqa.html#fqa-35.12">[35.12] Why can&#39;t I separate the definition of my templates class from its declaration and put it inside a .cpp file?</a></li>
<li><a href="fqa.html#fqa-35.13">[35.13] How can I avoid linker errors with my template functions?</a></li>
<li><a href="fqa.html#fqa-35.14">[35.14] How does the C++ keyword <code>export</code> help with template linker errors?</a></li>
<li><a href="fqa.html#fqa-35.15">[35.15] How can I avoid linker errors with my template classes?</a></li>
<li><a href="fqa.html#fqa-35.16">[35.16] Why do I get linker errors when I use template friends?</a></li>
<li><a href="fqa.html#fqa-35.17">[35.17] How can any human hope to understand these overly verbose template-based error messages?</a></li>
<li><a href="fqa.html#fqa-35.18">[35.18] Why am I getting errors when my template-derived-class uses a nested type it inherits from its template-base-class?</a></li>
<li><a href="fqa.html#fqa-35.19">[35.19] Why am I getting errors when my template-derived-class uses a member it inherits from its template-base-class?</a></li>
<li><a href="fqa.html#fqa-35.20">[35.20] Can the previous problem hurt me silently? Is it possible that the compiler will silently generate the wrong code?</a></li>
</ul>

<a id="fqa-35.1"></a>
<h2>[35.1] What&#39;s the idea behind templates?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.1">FAQ:</a></b> A template describes how to build definitions (classes or functions) which are basically the same.
</p>

<p>
One application is type-safe containers; there are many, many more.
</p>

<p>
<b class="FQA">FQA:</b> Let&#39;s get a bit more specific. The FAQ&#39;s answer is applicable to C macros, Lisp macros, ML functors, functions
like <code>eval</code> found in many interpreted languages, OS code that generates assembly instructions used to handle interrupts at run time, and just plain code generation (writing programs that print source code). The purpose of all such devices is meta-programming - writing code that works with code, creating pieces of code which are &quot;basically the same&quot; (after all, they are built from the same rules), and yet have some interesting differences. The question is, how do we specify these rules and these differences?
</p>

<p>
The approach used in C++ templates is to use integral constants and types to represent the differences, and to use
class &amp; function definitions to represent the rules. The first decision prevents you from generating code
dynamically, because the parameters can only be compile-time entities. The second decision prevents almost
everything else, because you don&#39;t get to use a <i>programming language</i> to generate code - the only thing you
can do is write code with some things factored out and made parameters. You can&#39;t do as simple and useful
a set of &quot;basically the same&quot; classes as automatically generated class wrappers for remote procedure calls
instead of normal &quot;local&quot; function calls (called &quot;proxies and stubs&quot; in <a href="http://en.wikipedia.org/wiki/Component_Object_Model">COM</a>
terminology; there are many other terms). Even computing the factorial of an integer parameter
is done using so much <a href="fqa.html#fqa-35.2">code</a> abusing the language mechanisms that people with no useful work to do are <i>proud</i> of being able to accomplish this.
</p>

<p>
Beyond those fundamental limitations, templates follow the tradition of C++ features of interacting poorly
with each other. Templates can&#39;t be compiled because they are not code - they are, well, templates from
which code can be generated once you have the parameters, and <i>then</i> you can compile it. C++, like C,
defines <a href="fqa.html#fqa-23.10">no way</a> to locate the compiled code of a definition given its name. Consequently, template
definitions are placed in <code>#include</code> files, and <i>recompiled in each translation unit each time they
are instantiated</i>, even if the exact same instantiation is used in N other files. This
problem is amplified by the tremendous complexity of the C++ grammar
(the most complicated part of it is probably <a href="fqa.html#fqa-35.18">templates themselves</a>), making this recompilation very
slow. If your code doesn&#39;t compile, you get <a href="fqa.html#fqa-35.17">cryptic error messages</a>. If it does compile, you might
wonder what it means. That&#39;s where the interactions of the C++ type system
(pointers, arrays, references, constants, literals...), function &amp; operator overload resolution,
function &amp; class template specialization selection, built-in and user-defined implicit conversions,
argument-dependent name look-up, namespaces, inheritance, dynamic binding and <i>other</i> things kick in.
The sheer length of this list should be convincing: neither a human nor a program (say, an IDE) has a
chance against this unprecedented syntactic power.
</p>

<p>
Poor support for meta-programming is not necessarily a very big deal, because you can do lots and
lots of things without it. That is, unless you work in C++. For example, there are no built-in lists or
dictionaries in C++; the standard library provides templates you can use, so you can recompile the
definition of each kind of dictionary each time you use it in a source file. In fact, most of
the code in the C++ standard library belongs to a conceptually and historically separate library called
STL, which stands for &quot;Standard Template Library&quot;. For example, that&#39;s where <code>std::vector</code>,
which the FAQ recommends to use instead of the <a href="fqa.html#fqa-6.15">evil</a> C arrays, comes from.
</p>

<p>
If you use C++, chances are that you&#39;re going to deal a lot with its obscure meta-programming facilities.
</p>


<a id="fqa-35.2"></a>
<h2>[35.2] What&#39;s the syntax / semantics for a &quot;class template&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.2">FAQ:</a></b> You add the parameters before the definition of your class, as in <code>template&lt;typename T&gt; class Array { ... };</code>,
and then you can use the parameters in the definition of the class, as in <code>T arr[N];</code>, and then you can use
your class by substituting the parameters as in <code>Array&lt;int&gt;</code>
(the FAQ gives a code listing instead of using words; its example is as simple as that).
</p>

<p>
<b class="FQA">FQA:</b> Wow, that sounds easy! Too bad it&#39;s wrong, in two ways.
</p>

<p>
First, things will not follow this straight-forward model - the FAQ itself discusses a couple of cases,
 like the <a href="fqa.html#fqa-35.18">need</a> to resort to the <code>typename</code> keyword and the <a href="fqa.html#fqa-35.19">look-up</a> of &quot;nondependent names&quot;. All such cases illustrate that you <i>can&#39;t</i> take the definition of a class, parameterize some things making it a template, and expect it to just work - it&#39;s way more tricky.
</p>

<p>
Second, what about the cases where nobody would <i>ever</i> write the classes generated from templates manually,
 but templates are still used because that&#39;s the only meta-programming facility offered by C++? Of course
 there are also C macros, which have some limitations templates don&#39;t have (and vice versa), and at least
 compile fast. But in the C++ community, macros are considered the most <a href="fqa.html#fqa-6.15">evil</a> feature ever, and using them is
 treated as a sin somewhere between speeding and blasphemy. Anyway, a majority of all uses of templates
 <a href="fqa.html#fqa-35.1">"beyond type-safe containers"</a> actually fall in this second category. Let&#39;s look at the previously mentioned compile-time factorial example, which is <i>trivial</i> compared to nifty stuff like type lists:
<br>
</p>

<pre>
template&lt;int N&gt;
struct Factorial
{
  enum { value = N*Factorial&lt;N-1&gt;::value };
};
template&lt;&gt;
struct Factorial&lt;0&gt;
{
  enum { value = 1 };
};
</pre>

<p>
This code generates N+1 classes in order to compute the factorial of N.
 Talk about &quot;the syntax / semantics of class templates&quot;. This is equally disturbing to humans - because it makes so little sense - and to compilers, which internally represent each class using a sizable data structure. This compile time computation technique tends to take a lot of compile time. When your only tool is a hammer template, not only does every problem look like a nail - you also hammer it with 100 hammers.
</p>

<p>
Oh, and when you want to use a template, be kind with the C++ lexer
(the part of the compiler converting text to &quot;tokens&quot; so that the parser can check whether they make meaningful statements).
 Code like <code>vector&lt;vector&lt;int&gt;&gt;</code>, which tries to declare an inefficient implementation of a <a href="fqa.html#fqa-13.11">2D array</a>,
 won&#39;t compile - you need a space before the two &gt; characters. Their concatenation looks just like the right bitwise shift operator. This is one of the more harmless, albeit confusing, awkward interactions between C++ features.
</p>


<a id="fqa-35.3"></a>
<h2>[35.3] What&#39;s the syntax / semantics for a &quot;function template&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.3">FAQ:</a></b> Pretty similar to class templates, plus you can usually omit the template parameters - the compiler will figure them
 out from the function arguments. For instance, you can write a <code>swap</code> function for swapping two values of any type,
 be it integers, strings, sets or file systems (yes, the FAQ <i>actually mentions</i> swapping some <code>FileSystem</code> objects).
</p>

<p>
By the way, an instantiation of a &quot;function template&quot; is called &quot;template function&quot;.
</p>

<p>
<b class="FQA">FQA:</b> In addition to all the <a href="fqa.html#fqa-35.2">problems</a> with class templates, we are now engaged in a battle of wits with the oh-so-smart compiler figuring out template parameters from function arguments. Or not. For example, <code>std::max(x,5)</code> compiles when x is a <code>int</code>, but fails to compile when it&#39;s a <code>float</code> or a <code>short</code>. You see, the point of templates is to make &quot;algorithms&quot; work with values of many different types, facilitating &quot;code reuse&quot; (the fact that <code>x&gt;5?x:5</code> is less code than <code>std::max(x,(short)5)</code> doesn&#39;t mean you don&#39;t want to <i>reuse code</i>, does it?).
</p>

<p>
For instance, you can reuse <code>std::swap</code> to swap a couple of file systems. All you have to do is implement a class
 <code>FileSystem</code> with a <a href="fqa.html#fqa-10.4">default constructor</a> creating a new empty disk partition. The copy constructor will
 copy all the files from a given <code>FileSystem</code> to a newly created partition, the <a href="fqa.html#fqa-11.1">destructor</a> will wipe it out,
 and <code>operator=</code> will do <a href="fqa.html#fqa-12.2">the latter followed by the former</a>. To handle errors, use <a href="fqa.html#fqa-17.1">exceptions</a>.
 You might get a few extra disk partitions created and destroyed, especially if you pass <code>FileSystem</code>
 objects around too much in the code, but that&#39;s a small price to pay for reusing the 3 lines of code in <code>std::swap</code>.
 And a &quot;commercial-grade&quot; compiler can even <a href="fqa.html#fqa-10.9">eliminate</a> some of those copies!
</p>

<p>
The note about &quot;function templates&quot; and &quot;template functions&quot; is very useful. Too bad there are people out there that confuse the two. Be careful with C++ terminology. For example, don&#39;t confuse &quot;object files&quot; (compiled code) with &quot;objects&quot; (which belong to a class), which in turn shouldn&#39;t be confused with &quot;instantiation&quot; of class templates (substituting template parameters is called &quot;instantiation&quot;, the result of this process is also &quot;instantiation&quot;, and creating objects is called &quot;construction&quot;). The good (or bad) news is that the terminology is the easy part.
</p>


<a id="fqa-35.4"></a>
<h2>[35.4] How do I explicitly select which version of a function template should get called?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.4">FAQ:</a></b> Most of the time you don&#39;t need to do it - the compiler will guess. It uses arguments to guess, so when your function has none,
 use <code>f&lt;int&gt;();</code>. Sometimes you want to force the compiler to choose a different type than it would choose by default -
 for example, <code>g(45)</code> will instantiate <code>g&lt;int&gt;</code>, while you want <code>g&lt;long&gt;</code>. You can force the compiler to call <code>g&lt;long&gt;</code> with explicit instantiation
 as in <code>g&lt;long&gt;(45);</code> or type conversion as in <code>g(45L);</code>.
</p>

<p>
<b class="FQA">FQA:</b> There is a good reason to avoid all kinds of &quot;clever&quot; behavior which gets in your way when you try to figure out
 what a program actually does
 (it doesn&#39;t always do what the author thought it would do). Overloading and template specialization are one kind of this
  behavior - go figure which function is actually called.
  But let&#39;s assume for a moment that it&#39;s not a problem, and that the important thing is to write code expressing
  the author&#39;s intent &quot;clearly&quot; in the sense that it&#39;s not cluttered with &quot;low-level&quot; details like which
  &quot;version&quot; of a function is called.
</p>

<p>
In that case, the picture presented by the FAQ looks fair - you only need to explicitly specify parameters when
  the compiler has no information to guess them itself, or when you don&#39;t like its guess. The truth is more
  complicated, because sometimes a function has more than one argument, and the template defines constraints
  on these arguments. That&#39;s what happens with <code>std::max(x,5)</code> when x is a <code>float</code>.
  The template wants two arguments of <i>the same</i> type, and the compiler thinks that &quot;5&quot; is of type <code>int</code>.
  So even though the intent seems clear (you probably want 5 to be treated as a number of the same type as that of x),
  the compiler can&#39;t make a decision.
  So you have to interfere in these cases, and choose between two almost equally unreadable alternatives, explicit instantiation or explicit type conversion.
</p>

<p>
Out of the two options, explicit instantiation, the syntax defined by C++ (as opposed to type conversion which is inherited from C) is typically worse. First, this way the code using a function forces it to be implemented as a template, although it doesn&#39;t really care, and makes it harder to get rid of the pesky templates when you feel like it. And second, when the need to interfere and disambiguate arises <i>inside another template</i>, you may have to use the following syntax, hideous even by C++ standards:
</p>

<pre>
a.template f&lt;long&gt;(45);
</pre>

<p>
While C++ features generally interact poorly with each other, templates set the record by interacting poorly with themselves.
</p>


<a id="fqa-35.5"></a>
<h2>[35.5] What is a &quot;parameterized type&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.5">FAQ:</a></b> A way to say &quot;class templates&quot;.
</p>

<p>
<b class="FQA">FQA:</b> Hmm, why do we need two ways of saying this?
</p>


<a id="fqa-35.6"></a>
<h2>[35.6] What is &quot;genericity&quot;?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.6">FAQ:</a></b> A way to say &quot;class templates&quot;. Don&#39;t confuse with &quot;generality&quot;.
</p>

<p>
<b class="FQA">FQA:</b> Hmm, why do we need three ways of saying this? Apparently C++ promoters consider templates an excellent and unique feature, despite their obscurity and the availability of much better meta-programming facilities in many languages. The many different synonyms are probably needed to illuminate the killer feature from many different directions.
</p>


<a id="fqa-35.7"></a>
<h2>[35.7] My template function does something special when the template type <code>T</code> is <code>int</code> or <code>std::string</code>; how do I write my template so it uses the special code when <code>T</code> is one of those specific types?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.7">FAQ:</a></b> First, make sure it&#39;s a good thing to do in your case. Generally, it is when the &quot;observable behavior&quot;
  in the special version you want to add is identical to the general case - otherwise, you&#39;re not helping your users.  If the special case is &quot;consistent&quot; with the generic case, you can do it as in <code>template&lt;&gt; void foo&lt;int&gt;() { ... }</code>.
</p>

<p>
<b class="FQA">FQA:</b> &quot;Observable behavior&quot; means different things to different people. In particular, many C++ users tend to <i>observe</i> performance (if you don&#39;t care about performance, but you still use a language that won&#39;t detect run time violations of language rules like out-of-bounds array indexes, you&#39;re probably wasting your time).
</p>

<p>
Consequently, the specialization of <code>vector&lt;bool&gt;</code> to be space-efficient (by storing bits instead of bytes) at the cost of speed (individual bits are harder to access than whole bytes) found in some STL versions is not a very good idea, because it ultimately confuses the performance-aware user. If the user wants a vector of bits, the user can  implement a vector of bits, or STL could supply one, but it&#39;s very inconvenient when you can&#39;t have a simple mental model describing what <code>vector</code> really means.
</p>

<p>
In addition, specialization is actually a pretty dangerous trap because it is your responsibility to make sure that all specializations are visible to the compiler
(<code>#included</code>) at each point where a template is used. If that&#39;s not the case, you can get too kinds of <code>vector&lt;bool&gt;</code> instantiated in your program, triggering &quot;undefined behavior&quot; (typically you&#39;ll pass a vector of the first kind to a function compiled to work with vectors of the second kind and crash). So specializing <i>others&#39; templates</i> is very likely to lead to a disaster (because you can&#39;t make sure that your specializations are visible in code you didn&#39;t write),
                                                                                                                                                                     and libraries which actually <i>assume</i> that you&#39;ll specialize templates they define are best avoided.
</p>

<p>
If you really want to use specialization, take into account that function templates don&#39;t support partial specialization (&quot;I want a special version for all types which are vectors of any T&quot;), only class templates do (template functions support <i>overloading</i>, which follows different rules). One workaround is to implement a single function template working with any T and delegate the call to a static method of a template class, as in:
</p>

<pre>
template&lt;class T&gt;
void f(const T&amp; x)
{
  FImpl&lt;T&gt;::f(x);
}
</pre>

<p>
This way, the class <code>FImpl</code> can be defined using partial specialization. All these layers of cryptic syntax could be considered tolerable if they ultimately were the only way to accomplish something really useful, and you could forget about them once you were done. But it&#39;s actually very easy to program <i>without</i> these complications, and almost always these complications get you nothing except for reducing maintainability, and you get to see them each time you have a compilation error deep down a chain of templates delegating trivial work to each other, and debugging run time errors becomes a real nightmare.
</p>

<p>
Basically you can choose simple interfaces and simple implementations, or C++-style cryptic interfaces and cryptic implementations. It&#39;s a trade-off.
</p>


<a id="fqa-35.8"></a>
<h2>[35.8] Huh? Can you provide an example of template specialization that doesn&#39;t use <code>foo</code> and <code>bar</code>?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.8">FAQ:</a></b> For instance, you can &quot;stringify&quot; values of different types using a template. The generic version boils down to <code>ostringstream out; out &lt;&lt; x</code>. But you might want to define specializations to handle types where the <code>ostream</code> output operator doesn&#39;t do what you like (you can set the output precision of floating point numbers, etc.)
</p>

<p>
<b class="FQA">FQA:</b> This means that all values of the same type will have to be formatted <a href="fqa.html#fqa-15.8">identically</a>.
 For example, all integers will be printed using decimal digits. If you prefer hexadecimal, you can define <code>class HexInt</code>
 (a template, of course, so that it can handle all the different integral types, including user-defined ones). Then you can use <code>stringify(HexInt&lt;int&gt;(x))</code>. You might need a partial specialization of <code>stringify</code> for <code>HexInt&lt;T&gt;</code> (see <a href="fqa.html#fqa-35.7">previous FAQ</a>). To save the trouble of explicitly passing the template parameters to <code>HexInt</code>, use a creator function template <code>HexInt&lt;T&gt; hexint(const T&amp;)</code> - the compiler will figure T out from <code>stringify(hexint(x))</code>.
 Specifying a number of leading zeros (as in the format string <code>&quot;%08x&quot;</code>) using advanced C++ type-based techniques is left as an exercise to the reader.
</p>

<p>
We&#39;ve done quite some work indeed in order to print an integer. Time to relax and let the compiler concentrate while it cleverly figures out all the things we want it to figure out. You usually print stuff for debugging, so the long build time may be annoying, but it&#39;s sure better than using a visual debugger where you get to see the line noise generated from all those other templates.
</p>

<p>
In the meanwhile, it is quite likely that whatever your <i>real</i> job was, someone else (probably some kind of competitor) has already done it. But did the result contain a mature, generic and efficient printing infrastructure with really, really minor usability and maintainability problems? Most certainly it didn&#39;t. Which is why C++ template specialization is your friend.
</p>


<a id="fqa-35.9"></a>
<h2>[35.9] But most of the code in my template function is the same; is there some way to get the benefits of template specialization without duplicating all that source code?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.9">FAQ:</a></b> You can factor out the common code and only specialize a helper function called from the common code. Two screens of source code are attached for illustration.
</p>

<p>
<b class="FQA">FQA:</b> Factoring out common code and helper functions are indeed very useful (which is why you can do that kind of thing with virtually every programming language). The existence of this question in the FAQ seems to indicate that people get unbelievably confused by templates, and lose hope that anything useful they know is applicable to them. Which is not that much of an exaggeration.
</p>


<a id="fqa-35.10"></a>
<h2>[35.10] All those templates and template specializations must slow down my program, right?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.10">FAQ:</a></b> You guessed wrong. Maybe the compilation will become &quot;slightly&quot; slower. But the compiler ends up figuring out the types of everything, and then doing all the usual nifty C++ optimizations.
</p>

<p>
<b class="FQA">FQA:</b> You guessed right. And the compilation will become intolerably slow. It&#39;s not like the FAQ is lying - it&#39;s just talking about the state of affairs in <a href="fqa.html#fqa-6.1">theory</a>,
 where C++ belongs. The &quot;slight&quot; slowdown of compilation is not even worth discussing: everything is
 &quot;slight&quot; if you have lots of time on your hands. Just try to build a C program and a <i>modern</i> C++ program full of templates
 and compare the time it took. As to execution time, there are practical problems making programs generated from templates slow compared to the hand-written alternatives.
</p>

<p>
First, the compiler generates the same code over and over again. Sometimes the linker throws away the extra copies and sometimes it doesn&#39;t, and the size of your program increases. In particular, the linker doesn&#39;t have a chance to throw away the functions which are identical at the <i>assembly</i> level, but not at the <i>source code</i> level (think about <code>vector&lt;int&gt;</code> and <code>vector&lt;void*&gt;</code>). It is possible to implement templates in a way avoiding these problems (by using the same implementation for all specializations yielding the same assembly code). It is very tedious and almost never done. Two identical functions almost always take more time to execute than a single function called twice, which has to do with instruction caches - a useful gadget frequently overlooked by many <a href="fqa.html#fqa-10.9">people</a> who care about &quot;theoretical efficiency&quot; without actually <i>measuring</i> performance.
</p>

<p>
Second, when people work with templates, they use <i>types</i> - their only hammer - for saying almost everything (consider the <code>HexInt</code> class from <a href="fqa.html#fqa-35.9">the previous FAQ</a>). More specifically, they wrap simple values of
 built-in types in user-defined types - classes. The type is used to select the right specialization and what-not -
 in fact it&#39;s used to specify what to do. An extreme example is the <a href="http://www.boost.org/doc/html/lambda.html">boost lambda library</a> - it creates structures representing entire <i>functions</i>, with a sub-structure representing addition, a sub-structure representing the constant 1, etc.
</p>

<p>
Now, &quot;theoretical performance fans&quot; may think that all of these structures get optimized out by the clever compiler. In practice, that&#39;s almost always close to impossible to do because of the so-called <a href="fqa.html#fqa-18.14">pointer aliasing problem</a>. When you have a local variable x, it&#39;s clear that nobody can change it but the code of the function, so the compiler can do lots of things with x, like stuffing it into a register or even completely optimizing it out. But once you push x into a structure, it&#39;s hard to see where it&#39;s modified - go figure who has a pointer to that structure, especially if you pass the object to a separately compiled function. So the compiler has to allocate a memory slot for x and make sure the memory cell gets updated when x is modified and that the memory cell gets read when there&#39;s a chance that it could have been changed by someone else. Code working with templates and relying on types to do compile time dispatching ends up doing lots of memory load/store operations at <i>run time</i> since the types don&#39;t really go away.
</p>

<p>
And anyway, there&#39;s such a huge amount of scenarios to take care of to optimize complicated template-based code well that compiler writers rarely bother. They are lucky if they get the <i>parsing</i> right. Even that is unlikely - when you are porting from one compiler to another, chances are that most of your compatibility problems will come from the semantics of the code using templates.
</p>


<a id="fqa-35.11"></a>
<h2>[35.11] So templates are overloading, right?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.11">FAQ:</a></b> They are in the sense that they are inspected when the compiler resolves names (figures out the version of <code>f</code> that should be called by <code>f(x)</code>). They are not in the sense that the rules are different. Specifically, there&#39;s the SFINAE (Substitution Failure Is Not An Error) rule: the argument types have to match exactly for a template to be considered in overload resolution. If they don&#39;t, the compiler won&#39;t try to apply conversions the way it would with a function - instead it will discard the template.
</p>

<p>
<b class="FQA">FQA:</b> Aside from the fact that the acronym &quot;SFINAE&quot; interpreted literally doesn&#39;t seem to describe what it&#39;s supposed to describe, this sounds <i>just a little bit</i> too easy. For example, what does &quot;exact match&quot; mean? Let&#39;s have a look at a real life example taken from the GNU implementation of the C++ standard library. I tried to make this short, but there are about <b>5</b> distinct stupid things involved, so it was hard. If you get tired in the middle of this and stop, it&#39;s probably an indication that you <i>do</i> get the main point - that things are actually very complicated in this department and that these complications are best avoided.
</p>

<p>
<b>Stupid thing #1</b>: Once upon a time, <code>vector&lt;int&gt;::iterator</code> was a plain old <code>typedef</code> for <code>int*</code> in the GNU STL. Of course this is <i>very, very</i> dangerous: people might use <code>std::vector</code> as if it were just an array of objects - a serious abstraction violation, you could get arrested for that in some jurisdictions. At the beginning of the 21st century, the guys behind GNU STL decided to &quot;fix&quot; this by creating a class template called <code>__normal_iterator</code>. This template serves as a &quot;strict typedef&quot; - it wraps any existing iterator type, such as <code>int*</code>, and delegates all operations to the existing type, but can not be converted to <code>int*</code>. This has many important benefits over the previous implementation, for example, much longer <a href="fqa.html#fqa-35.17">error messages</a>.
</p>

<p>
<b>Stupid thing #2</b>: As you may know, there are two kinds of iterators defined by STL containers: <code>iterator</code> and <code>const_iterator</code> because of <a href="fqa.html#fqa-18.2">inherent problems with const</a>: <code>const iterator</code> is <i>not at all</i> the same as <code>const_iterator</code>. If STL wanted to be consistent, it would also define <code>volatile_iterator</code> and <code>const_volatile_iterator</code>, and then nobody would even look at STL, which wouldn&#39;t necessarily be bad. But they didn&#39;t. So now you also need two kinds of &quot;normal iterators&quot; - for <code>int*</code> and <code>const int*</code>.
</p>

<p>
<b>Stupid thing #3</b>: <i>Of course</i> the GNU STL guys didn&#39;t want to define a <code>__normal_const_iterator</code> - after all, making conversion hard for <i>you</i> is an excellent thing, but making it hard for <i>them</i> is a completely different thing. Instead, they decided to support automatic conversion between different instantiations of <code>__normal_iterator</code>, by - of course - delegating the conversion to the wrapped types (templates normally delegate all useful work to someone else; their job is obfuscation). This way, you can compare const and non-const iterators using the same operator, having this elegant prototype:
</p>

<pre>
  template&lt;typename _IteratorL, typename _IteratorR, typename _Container&gt;
  inline bool
  operator&gt;(const __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,
            const __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs);
</pre>

<p>
<b>Stupid thing #4</b>: STL provides another, <i>seemingly unrelated</i> service to its users. It defines global relational operators which work on arguments of any type. How can they compare objects without knowing anything about them? At this point you can probably guess the answer - of course, they delegate the work to someone else, this time to <i>existing</i> relational operators, using interesting identities such as <code>(a&gt;b) == !(a&lt;=b)</code>. This way, you can define only 2 relational operators, and get the rest &quot;for free&quot;.
</p>

<p>
<b>Stupid thing #5</b>: Except when you can&#39;t. This is where our subject, overload resolution and templates, kicks in. Remember the rule about only considering templates when the argument types match the prototype <i>exactly</i>? Well, when you compare &quot;normal iterators&quot; of the same type (for example, both wrapping <code>int*</code>), the beautiful prototype above matches the arguments &quot;exactly&quot;. So do the &quot;generic&quot; relational operators. Oops, we have ambiguous overloading! The &quot;solution&quot; is to define a <i>third</i> overload, matching the types <i>even more exactly</i> by using a single template parameter <code>_Iterator</code> instead of two which can possibly differ. Why is this situation considered &quot;unambiguous&quot;? Frankly, beyond the basic intuition saying that you must show the compiler a type pattern as similar to your arguments as possible, I don&#39;t know. That&#39;s why I didn&#39;t list the Stupid thing #6. But the first 5 make me feel that in this case, <i>ignorance is bliss</i>.
</p>

<p>
Apparently this situation looks discouraging even from inside the C++ universe, as indicated by the following <i>rather sad</i> comment found in one of the header files of the GNU STL. You can probably decipher it, unless the 5 stupid things above have already faded from your memory:
</p>

<pre>
  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don&#39;t
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby
</pre>

<p>
This could be amusing (an implementor of the standard library of a language complaining about this language in files delivered to users and all) if it weren&#39;t so mind-numbing. People who think they are better at C++ than the GNU STL authors are welcome to waste their entire life chasing and &quot;solving&quot; problems with overload resolution, template specialization or whatever its name is. For the rest, trying to avoid templates &amp; overloading sounds like a good advice, which can be followed to an extent even if you are forced to use C++.
</p>


<a id="fqa-35.12"></a>
<h2>[35.12] Why can&#39;t I separate the definition of my templates class from its declaration and put it inside a .cpp file?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.12">FAQ:</a></b> &quot;Accept these facts&quot;, says the FAQ - templates are not code, just a recipe for generating code given parameters; in order to compile this code, it must first be generated, which takes knowing both the template definition and the definitions of the parameters which are passed to it; and the compiler doesn&#39;t know anything about code outside of a file when compiling the file (which is called &quot;separate compilation&quot;).
</p>

<p>
So you have to place template definitions in header files, or else the compiler won&#39;t get a chance to see all the definitions it needs at the same time. Experts should calm down - yes, it&#39;s oversimplified; if you know it is, you don&#39;t need this answer anyway.
</p>

<p>
<b class="FQA">FQA:</b> There are two problems with placing template definitions in header files which may bother you: you get to recompile them each time the file is included, and you disclose your source code to the user. Let&#39;s concentrate on the first problem. The second is minor anyway because source code of templates isn&#39;t necessarily easier to understand than disassembled object code. As to the first problem - to get an idea about its magnitude, consider the fact that an iostream-based &quot;hello, world&quot; program requires the GNU C++ compiler to parse <b>718K</b> (!!) bytes. And contrary to the claims in the FAQ, it turns out that the need to make the source code of templates available to the compiler is not the only reason we have this problem.
</p>

<p>
Suppose a C++ compiler could use some rules to locate compiled definitions of classes given their names, for example &quot;<code>std::vector&lt;int&gt;</code> is always located at the file <code>$OUTPUT_ROOT/templates/std/vector_int.o</code>&quot; and so on. This way, if you used <code>vector&lt;int&gt;</code> and <code>vector&lt;double&gt;</code>, you&#39;d have to compile <code>vector</code> twice, but if you used <code>vector&lt;int&gt;</code> twice, the compiler could avoid recompilation. That would make sense since you&#39;d only compile <i>different</i> classes each time you compile the template.
</p>

<p>
Unfortunately, this can&#39;t work in C++. That&#39;s because the compiler can&#39;t <i>parse</i> <code>std::vector&lt;int&gt;</code> without parsing
 the entire preprocessed output generated by <code>#include &lt;vector&gt;</code>. That parsing, which <i>has</i> to be done over and
 over again for each compiled source file, takes most of the compilation time. Generating the code of <code>std::vector&lt;int&gt;</code>
 several times is the small part of the problem, and most compiler writers don&#39;t bother to solve it, since you&#39;d still
 have the parsing bottleneck.
</p>

<p>
The basic problem inherited from C is that the compiler can&#39;t look up
 definitions. Instead, you have to arrange <code>#include</code> files so that the preprocessor can copy-and-paste definitions into a single huge bulk containing everything relevant (as well as many irrelevant things) for the compilation of your source file. C still compiles fast because its grammar is simple. Many newer languages define not only the concept of a &quot;class&quot;, but also rules to help the compiler locate definitions instead of parsing them over and over again. C++ programmers enjoy the worst of both worlds.
</p>


<a id="fqa-35.13"></a>
<h2>[35.13] How can I avoid linker errors with my template functions?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.13">FAQ:</a></b> You probably didn&#39;t make the definition of a template available to your compiler at the point where a template is used (did you implement a template in a .cpp file?). There are three solutions:
</p>

<ul>
<li>Move the definition to the .h file (which may increase the size of your compiled code, unless the compiler is &quot;smart enough&quot;).</li>
<li>Add explicit instantiations in your .cpp file. For example, <code>template void foo&lt;int&gt;();</code> will cause the compiler to generate the code of <code>foo&lt;int&gt;</code>, and the linker will find it.</li>
<li><code>#include</code> the .cpp file defining the template at the .cpp file using the template. If it feels weird, live with it or read <a href="fqa.html#fqa-35.12">the previous FAQ</a>.</li>
</ul>

<p>
<b class="FQA">FQA:</b> These &quot;solutions&quot; create new problems:
</p>

<ul>
<li><b>Moving code to .h file</b>: even if the code size doesn&#39;t increase, the compilation time will - you are going to recompile your templates from scratch each time they are used, and templates are one of the hardest parts of C++ to compile. It&#39;s nice that the FAQ at least acknowledges that your code size <i>might</i> increase though - in practice it most certainly <i>will</i>. Too bad the FAQ didn&#39;t mention it in <a href="fqa.html#fqa-35.10">the question about the speed of templates</a> - replicated code means more time spent in fetching code into instruction caches.</li>
<li><b>Explicit instantiations</b>: this is one big step back to C macros. Suppose you have a parameterized preprocessor macro which expands to a definition of a container class. One difference between this macro and an equivalent template is that if someone <i>uses</i> one such class, that someone must also make sure that the macro is actually <i>expanded</i> somewhere with the appropriate parameters - or you must provide these expansions. Otherwise, there will be linker errors. With templates, the compiler is supposed to generate the needed instantiations transparently - except it&#39;s almost impossible to accomplish. Along comes this &quot;solution&quot;, moving us back to square one.</li>
<li><b>Including the definition at the point of usage</b>: this shares the problems of the first two options. If you use templates in .h files, you may have to include the .cpp files defining them in these .h files, getting the problems of option 1. But the benefit of option 1 - transparency - is gone: quite similarly to option 2, it is now your job to make the definition of a template available wherever the template is used.</li>
</ul>


<a id="fqa-35.14"></a>
<h2>[35.14] How does the C++ keyword <code>export</code> help with template linker errors?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.14">FAQ:</a></b> It&#39;s &quot;designed&quot; to eliminate the need to make the definition of a template available to the compiler at the point of usage. Currently, there&#39;s only one compiler supporting it. The keyword&#39;s future is &quot;unknown&quot;.
</p>

<p>
An advice for futuristic programmers follows. It shows a way to make code compatible with both compilers that support <code>export</code> and those that don&#39;t using - guess what? - the wonders of the <a href="fqa.html#fqa-6.15">evil</a> C preprocessor. Among other things, the FAQ advises to <code>#define export</code> under certain conditions.
</p>

<p>
<b class="FQA">FQA:</b> &quot;How does it help&quot;, is that what you want to know? OK then. The <code>export</code> keyword helps with template linker errors just the way a song about peace helps to stop a bullet penetrating a foot. It helps just like a keyword <code>findbugs</code> telling the compiler to find and report all the bugs in a piece of code would help you with bugs.
</p>

<p>
The rest of C++ makes this keyword impossible to support in any useful way that would actually yield faster compilation compared to the case when template definitions are included at header files. That&#39;s why most compilers don&#39;t bother to support it, and that&#39;s why the future of the keyword is &quot;unknown&quot;: it&#39;s useless.
</p>

<p>
If you spot someone following the FAQ&#39;s advice (<code>#ifdef EXTRATERRESTRIAL_COMPILER</code> and all that), call an ambulance. Warning: the patient has likely reached a very agitated state and might escape before the people qualified to deal with the situation arrive. Try to occupy the patient&#39;s mind with a discussion about the fact that <code>#defining</code> keywords is illegal C++. Propose to consult your lawyer. Try to &quot;design&quot; a couple of keywords together (look up synonyms in a dictionary, imagine them printed in popular fonts, stuff like that). Improvise. It&#39;s gonna be over soon.
</p>


<a id="fqa-35.15"></a>
<h2>[35.15] How can I avoid linker errors with my template classes?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.15">FAQ:</a></b> It&#39;s just like errors with template functions, which were explained in the previous answers.
</p>

<p>
<b class="FQA">FQA:</b> Yep, it&#39;s about the same.
</p>


<a id="fqa-35.16"></a>
<h2>[35.16] Why do I get linker errors when I use template friends?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.16">FAQ:</a></b> If you have a class template <code>C</code> declaring a friend like <code>Foo&lt;T&gt; f()</code>, the compiler assumes that there&#39;s a global function <code>f()</code> returning <code>Foo&lt;T&gt;</code>. You probably meant a different thing, namely - there&#39;s a function template <code>template&lt;class T&gt; Foo&lt;T&gt; f()</code>, and you want its instantiation <code>f&lt;T&gt;()</code> to be a friend of your instantiation <code>C&lt;T&gt;</code>.
</p>

<p>
There are two ways around this:
</p>

<ul>
<li>Declare the function template before the definition of the class, and add <code>&lt;&gt;</code> to the friend declaration, as in <code>friend Foo&lt;T&gt; f&lt;&gt;();</code></li>
<li>Define the friend function template inside the body of the class.</li>
</ul>

<p>
<b class="FQA">FQA:</b> In both solutions the syntax is unrelated to the semantics to an extent remarkable even for C++.
</p>

<p>
Why does <code>&lt;&gt;</code> mean that we are talking about an instantiation of a template function? Why not use a keyword (like, just an example off the top of the head, the <code>template</code> keyword) to say that?! The C++ way is uncompromisingly ugly, especially in the example mentioned by the FAQ itself: <code>operator&lt;&lt; &lt;&gt;(...)</code>.
</p>

<p>
And even when you don&#39;t have a problem with placing the definition in a header file, the seemingly cleaner second way is actually <i>more</i> cryptic. This breaks one of the <i>very few</i> things in C++ you can normally count on: that a declaration of a function or a type looks just like a definition without the body. Here, we change the meaning of the prototype by adding a body: instead of declaring a function, we now declared and defined a function template.
</p>

<p>
Last but not least, the very fact that this problem <i>exists</i> is an indication of a readability problem with the C++ grammar. How many people would guess that the original declaration refers to a function and not a function template?
</p>

<p>
How is one supposed to navigate through this swamp of arbitrary syntax? <i>Of course</i> one shouldn&#39;t expect the kind of readability you get with a natural language from a programming language. <i>Of course</i> any formal language will behave &quot;counter-intuitively&quot; at times. But people <i>do</i> deal with formal languages quite successfully, when it is possible to keep a reasonably compact model of the key rules in one&#39;s mind. In these cases, even if you bump into a behavior which doesn&#39;t make sense at the first glance, you can think again and - &quot;Of course, of course, I know what it&#39;s doing!&quot;. Do you feel that you understand what a C++ compiler is actually doing? Neither do most C++ users out there.
</p>


<a id="fqa-35.17"></a>
<h2>[35.17] How can any human hope to understand these overly verbose template-based error messages?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.17">FAQ:</a></b> There&#39;s a &quot;free tool&quot; converting compiler error messages to more human-readable ones. It works with many compilers.
</p>

<p>
An example follows, having a snippet <code>[STL Decryptor: Suppressed 1 more STL standard header message]</code> in it.
</p>

<p>
<b class="FQA">FQA:</b> Oh <i>really</i>? <i>Any</i> &quot;template-based&quot; error messages? Hmm, why didn&#39;t the compiler writers produce clean error messages in the first place if a single tool can clean up all the mess created by many different compilers? These people must be quite lazy and/or stupid. Or are they?
</p>

<p>
Actually, no, they are not. The error messages are cryptic because templates are cryptic, and most compilers can&#39;t really do much better than they do today.
</p>

<p>
The tool mentioned (<i>without the name</i>) and <a href="http://www.bdsoft.com/tools/stlfilt.html">linked to</a> by the FAQ is called <code>STLFilt</code>. That&#39;s why the FAQ doesn&#39;t mention the name. That&#39;s why its output does mention STL. That&#39;s why it works at all - you can&#39;t improve generic template error messages, but you can filter STL-related messages if you know how STL is implemented in each specific case.
</p>

<p>
We need a couple more tools, like <code>STLCompilationTimeReducer</code> and <code>STLDebugInformationBeautifier</code>, and we&#39;re all set. Yet another proof that generic meta-programming facilities are a <a href="fqa.html#fqa-6.2">better</a> way to implement containers than build them into a language.
</p>

<p>
If you wish to implement a template library, don&#39;t forget to implement a tool filtering the error messages your users will get, as well as the other cool tools, for all the flavors of compilers out there.
</p>


<a id="fqa-35.18"></a>
<h2>[35.18] Why am I getting errors when my template-derived-class uses a nested type it inherits from its template-base-class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.18">FAQ:</a></b> This can hurt, sit down. The compiler doesn&#39;t look for &quot;non-dependent&quot; names (ones that don&#39;t mention the template parameters) in &quot;dependent&quot; base classes. So if you inherited a nested class or typedef <code>A</code> from your base class <code>B&lt;T&gt;</code>, you can only access it using a dependent name, like <code>B&lt;T&gt;::A</code>, but you can&#39;t use a non-dependent name, like plain <code>A</code>.
</p>

<p>
<i>And</i> you&#39;ll have to prefix that &quot;dependent&quot; name with the <code>typename</code> keyword. That&#39;s because the compiler doesn&#39;t know that <code>B&lt;T&gt;::A</code> is a type (think about two specializations, one defining a nested class <code>A</code> and one defining a global variable <code>A</code>).
</p>

<p>
<b class="FQA">FQA:</b> This illustrates two generic problems with the C++ grammar.
</p>

<p>
First, class templates are <i>not</i> <a href="fqa.html#fqa-35.2">just parameterized class definitions</a>, because the crazy C++ name look-up gets crazier when you are inside a template. So don&#39;t assume you can take a C++ class definition, factor out a bunch of parameters and get a working template definition.
</p>

<p>
Second, telling a C++ type name from a C++ object/function name is <a href="fqa.html#fqa-10.19">insanely complicated</a>. This interacts badly with templates, constructors, and everything else.
</p>

<p>
As to the possible reactions of users the FAQ attempts to anticipate: while <i>running away</i> may be justified, <i>sitting down</i> is probably not. Good developers tend to <i>test their code</i>, so even if the compiler didn&#39;t spit an error message and did the wrong thing silently (for instance, used a type called <code>A</code> from the global namespace), a test will find the error. Stupid compiler behavior only feels like pain for people who think that the extremely slow C++ compilers spend their time in finding all their bugs, and don&#39;t bother to test the result. Those people should relax and save their tears for the C++ <i>run-time</i> errors.
</p>


<a id="fqa-35.19"></a>
<h2>[35.19] Why am I getting errors when my template-derived-class uses a member it inherits from its template-base-class?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.19">FAQ:</a></b> The reasons are identical to those in <a href="fqa.html#fqa-35.18">the previous FAQ</a>. But the workarounds are <i>different</i> - convert <code>f()</code> to <code>this-&gt;f()</code> or add the statement <code>using B&lt;T&gt;::f()</code> to your class definition. Using the fully qualified name like it was done in the previous FAQ (<code>B&lt;T&gt;::f()</code>) will also work, except when the function is virtual, in which case the compiler will use static binding, not dynamic binding.
</p>

<p>
<b class="FQA">FQA:</b> Yep, the case with member functions is similar to the case with nested types, with the additional bonus of interacting badly with <a href="fqa.html#fqa-20.1">virtual functions</a>.
</p>

<p>
The FAQ has a hilarious comment in the spirit of &quot;this doesn&#39;t mean that template inheritance doesn&#39;t work - but the name look-up works differently&quot;. And that&#39;s C++ for you: it&#39;s not like you can&#39;t write code, it&#39;s just that you can&#39;t tell for sure what any particular name or some other part of it means.
</p>


<a id="fqa-35.20"></a>
<h2>[35.20] Can the previous problem hurt me silently? Is it possible that the compiler will silently generate the wrong code?</h2>
<p>
<b class="FAQ"><a href="http://www.dietmar-kuehl.de/mirror/c++-faq/templates.html#faq-35.20">FAQ:</a></b> Yes - the compiler might call a function or use a type from the global namespace instead of what you meant, for example.
</p>

<p>
<b class="FQA">FQA:</b> It&#39;s not as horrible that a language can silently misinterpret what you mean as it may sound. Any language will do this to the creative but imprecise human mind (formal languages aside, people frequently misunderstand each other).
</p>

<p>
With formal languages, you can form a relatively simple model which will help you understand these problems. It&#39;s the same with C++ except for the &quot;simple&quot; part, so C++ and you will misunderstand each other pretty frequently.
</p>

<p>
And you can also test your code by creating programs that check if it does what you want it to do in a bunch of cases. It&#39;s the same with C++ except that it compiles forever and you have to write notable amounts of code to implement the simplest test, so C++ code ends up being tested pretty rarely.
</p>

<a id="fqa-web-vs-fqa"></a><h1>FQA errors</h1>
<p>
This page lists the factual errors/inaccuracies in the C++ FQA. If you find one, please
<a href="http://yosefk.com">send me e-mail</a>. If you are right, I&#39;ll publish your correction, either giving
you the credit or anonymously, according to your choice.
</p>

<p>
By &quot;factual errors&quot;, I mean statements which can be proved wrong or refuted by a practically feasible test.
</p>

<p>
Positive examples: if I say that C++ compilers may generate slower code from C source than C compilers
unless exception support is off, and in fact no commercially significant compiler does that, I&#39;m wrong
(don&#39;t bother with this one - I already checked it). If I say that the C++ grammar is undecidable,
 and you formally prove it&#39;s decidable, I&#39;m wrong
 (advice: don&#39;t bother with this one, too).
</p>

<p>
Negative examples: if I say templates are mostly applicable to containers, and you know many other
  ways to use templates, it&#39;s really a qualitative argument. You call this &quot;uses&quot;, I call it <a href="fqa.html#fqa-35.2">"abuses"</a>.
It&#39;s like arguing whether <code>sed</code> is <a href="http://sed.sourceforge.net/grabbag/scripts/dc.sed">applicable to numerical computing</a>: it&#39;s a matter of common sense,
  and we&#39;ll get nowhere - there&#39;s no formal definition of a <a href="http://en.wikipedia.org/wiki/Turing_tarpit">Turing tarpit</a>.
  If you inform me that I&#39;m &quot;inconsistent&quot; because &quot;sometimes my problem with C++ is that
  it&#39;s too low-level for high-level work and sometimes I think it&#39;s too high-level for low-level work&quot;,
  the message will land in the bit bucket, too. I think that doing both low-level and high-level work in C++ is suboptimal
  (I tried both); you are free to call it &quot;inconsistency&quot;. If you think the fact that C++ is a <a href="fqa.html#fqa-6.11">"superset"</a>
  of C means that C++ can&#39;t be inferior to C, go visit <a href="http://en.wikipedia.org/wiki/Chernobyl">Chernobyl</a> and buy yourself a radioactive cat with 7 legs and
  a wing (codenamed &quot;cat++&quot;), but don&#39;t expect me to agree.
</p>

<ul>
<li><a href="fqa.html#correction-1">Sometimes base class constructors must have information on the actual object type</a></li>
<li><a href="fqa.html#correction-2">C++ has <code>bool</code>, a built-in type not in C</a></li>
<li><a href="fqa.html#correction-3"><code>#define private public</code> is not enough to cancel C++ encapsulation</a></li>
<li><a href="fqa.html#correction-4">The special case when N-dimensional arrays can be allocated dynamically with <code>new</code></a></li>
<li><a href="fqa.html#correction-5">Conversions between code and data pointers are common</a></li>
</ul>

<p>
<a id="correction-1"></a><h2>Sometimes base class constructors must have information on the actual object type</h2>

<p>
<i>Eugene Toder:</i> The FQA answer about <a href="fqa.html#fqa-23.5">the dispatching of virtual functions in constructors</a>
  is based on the following statement: <i>Base::Base doesn&#39;t know that it&#39;s called in order to ultimately initialize a Derived object</i>.
This is wrong, since virtual inheritance can&#39;t work that way. In particular, AFAIK, <code>cfront</code>, the first C++ compiler,
  always passed constructors a parameter telling whether it initializes a base class object or a derived class object,
  no matter what kind of inheritance was involved.
</p>

<p>
<i>Yossi:</i> This is an error by itself, and it&#39;s also inconsistent with other information in the FQA. Specifically,
  the FQA <a href="fqa.html#fqa-25.12">mentions</a> (following the FAQ) that with virtual inheritance, the programmer must directly initialize
  virtual base class objects in the derived classes, even if they are not its &quot;immediate&quot; base classes
  (that is, it inherits them indirectly). But what if someone derives another class, <code>Derived2</code>, from a class <code>Derived</code> with virtual
  base classes? It&#39;s <i>still</i> up to the programmer to initialize the virtual base class objects in <code>Derived2</code> - but <code>Derived</code>
   already contains code that does this (and maybe <i>other</i> base classes contain such code, which is
our problem in the first place). So we <i>don&#39;t</i> want to use the virtual base class initialization code
  in <code>Derived</code>, but we <i>do</i> want to use the other initialization code in <code>Derived</code>. Therefore,
  the constructor of <code>Derived</code> must know whether it ultimately initializes a <code>Derived</code> object or
  an object of some child class, such as <code>Derived2</code>, in order to conditionally execute
  some of the initialization code (or the constructor code must be generated twice, which is the same in this context).
</p>

<p>
I think that the FQA answer still has its value in the sense that it may actually be more intuitive to
  C++ programmers. That&#39;s because the FAQ answer basically says, &quot;C++ prevents you from a <i>potential</i> (not certain)
  error of accessing uninitialized members of a derived class, by silently doing something different than what you
  thought it would&quot;. This is a very special fact which has to be memorized; normally C++ <i>doesn&#39;t</i> try to prevent
  access to uninitialized data. The FQA answer says, &quot;C++ does the thing naturally and efficiently following
  from the underlying implementation: to set up <code>vptr</code> to point to the correct <code>vtable</code>, you&#39;d have to
  spend cycles (a tiny amount of them, but C++ is frequently very conservative about run time cost)&quot;.
  Arguably, this is more consistent with the rest of C++ and is easier to remember. But of course it
  doesn&#39;t make the erroneous statement in the FQA correct.
</p>

<p>
<a id="correction-2"></a><h2>C++ has <code>bool</code>, a built-in type not in C</h2>

<p>
<i>From a Usenet posting</i>
(in
<a href="http://groups.google.co.il/group/comp.lang.c++.moderated/tree/browse_frm/thread/870d15c57e831fc5/8396a5eaa8e3452d?hl=en&amp;rnum=41&amp;_done=%2Fgroup%2Fcomp.lang.c%2B%2B.moderated%2Fbrowse_frm%2Fthread%2F870d15c57e831fc5%2F5868fd6e57f6ae2c%3Fhl%3Den%26tvc%3D1%26#doc_1425cc7bbc57bcb8">comp.lang.c++.moderated</a>):
You said &quot;C++ doesn&#39;t add any built-in types to C.&quot;
What about <code>bool</code>?
</p>

<p>
<i>Yossi:</i> This statement is false (wait, that&#39;s not good, I mean the one quoted in the posting).
The FQA <a href="fqa.html#fqa-23.5">does mention</a> that C++ adds built-in types which are essentially <a href="fqa.html#fqa-8.1">new kinds of pointers</a>
(references, pointers to members), but it doesn&#39;t say this in Defective C++ where the false assertion
appears, and it fails to mention <code>bool</code> in this context anywhere.
</p>

<p>
Unlike the previous item, this error doesn&#39;t invalidate the reasoning in the text where it appears. Specifically, the context
 of the erroneous statement is the discussion of <i>high-level</i> built-in types, which don&#39;t map directly
 to C types the way <code>bool</code> does, primarily
 because their sizes are not known at compile time.
</p>

<p>
<a id="correction-3"></a><h2><code>#define private public</code> is not enough to cancel C++ encapsulation</h2>

<p>
As Andreas Krey pointed out, you&#39;d also need <code>#define protected public</code> and <code>#define class struct</code>.
The latter will fail to work with code like <code>template&lt;class T&gt; class X {...}</code>, because the keyword
<code>struct</code> can not be used in template parameter lists. There may be other problems related to
interactions between access control and name look-up.
</p>

<p>
Another thing I failed to mention in <a href="fqa.html#fqa-7.7">the original context</a>: re-#defining keywords isn&#39;t legal
C++. It will only work in implementations where preprocessing is a separate pass, which is
unaware of the keywords and treats them as identifiers. I&#39;ve never worked with an implementation
doing it differently, but <code>#define private public</code> is still illegal C++. It&#39;s only useful for
debugging (to print private data without changing header files and recompiling for hours),
and to illustrate that C++ encapsulation is useless for security (the latter was my original point).
</p>

<p>
<a id="correction-4"></a><h2>The special case when N-dimensional arrays can be allocated dynamically with <code>new</code></h2>

<p>
When all array dimensions except for the first are known at compile time, you can allocate
arrays dynamically with <code>new</code>. That&#39;s because C++ arrays are flat sequences of objects
of the same type. In our case, those objects are (N-1)-dimensional arrays. If any of those
N-1 dimensions weren&#39;t known at compile time, the (N-1)-dimensional array wouldn&#39;t be possible
to describe with a C++ type. But not knowing the first dimension until run time doesn&#39;t create
this problem.
</p>

<p>
Joe Zbiciak found that <a href="fqa.html#fqa-16.16">answer 16.16</a> fails to mention this. <a href="fqa.html#fqa-16.20">Answer 16.20</a> does,
but 16.16 is still incorrect because it says you only have 2 ways to allocate N-dimensional arrays
dynamically. However, in our special case, you have a third way.
</p>

<p>
<a id="correction-5"></a><h2>Conversions between code and data pointers are common</h2>

<p>
The FQA <a href="fqa.html#fqa-33.8">says</a> that conversions between function pointers and void pointers are rare (independently of being
illegal, though supported on many machines). Patrick Walton counters:
</p>

<p>
&quot;Actually, this is done all the time for dynamic linking, in <code>dlsym</code> on POSIX platforms (returns a <code>void*</code>, even for code pointers) and <code>GetProcAddress</code> on Windows (returns a <code>void (*)()</code>, even for data pointers). Interesting that both platforms violate the standard in opposite ways. In the case of POSIX, there&#39;s a lot of pain involved in making this required interface work on systems where function pointers are longer than data pointers.&quot;
</p>

<p>
I wonder why neither Windows nor POSIX defined two functions, one returning a <code>void*</code> and one returning a <code>void (*)()</code>.
</p>

<hr>
<small class="part">Copyright &copy; 2007-2025 <a href="http://yosefk.com">Yossi Kreinin</a><br>
<code>revised 18 September 2025</code></small>

</body>
</html>