<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>

<!-- Mirrored from www.dietmar-kuehl.de/mirror/c++-faq/ctors.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 18 Sep 2025 13:11:21 GMT -->
<head>
<title>[10] Constructors, C++ FAQ Lite</title>
<meta name="FILENAME" content="ctors.html">
<meta name="ABSTRACT" content="[10] Constructors, C++ FAQ Lite">
<meta name="OWNER"    content="cline@parashift.com">
<meta name="AUTHOR"   content="Marshall Cline, cline@parashift.com">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rev=made href="mailto:cline@parashift.com">
<style type='text/css'>
  <!--
  body       { font-family: arial; color: black; background: white }
  .CodeBlock { color: black; background-color: #dfdfdf; margin-left: 30px; margin-right: 30px; padding: 5pt }
  .CodeBlock small tt { font-size: small }
  .FaqTitle  { color: black; background-color: gold }
  .Updated   { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #ffff00; border: solid #e0e000 1px; }
  .New       { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #00ff00; border: solid #00d000 1px; }
  ul         { margin-bottom: 1px; margin-top: 1px }
  ol         { margin-bottom: 1px; margin-top: 1px }
  li         { margin-bottom: 4px; margin-top: 4px }
  -->
</style>
</head>
<body>
<h1><a name="top"></a>[10] Constructors<br>
<small><small>(Part of <a href="index-2.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>, <a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">Copyright&nbsp;&copy; 1991-2006</a>, <a href="http://www.parashift.com/" title="www.parashift.com/" target='_blank'>Marshall Cline</a>, <a href="mailto:cline@parashift.com" title="cline@parashift.com"><tt>cline@parashift.com</tt></a>)</small></small></h1>
<hr>
<h3>FAQs in section [10]:</h3>
<ul>
<li><a href="ctors.html#faq-10.1" title="[10.1] What's the deal with constructors?">[10.1] What's the deal with constructors?</a></li>
<li><a href="ctors.html#faq-10.2" title="[10.2] Is there any difference between List x; and List x();?">[10.2] Is there any difference between <nobr><tt>List x;</tt></nobr> and <nobr><tt>List x();</tt></nobr>?</a></li>
<li><a href="ctors.html#faq-10.3" title="[10.3] Can one constructor of a class call another constructor of the same class to initialize the this object?">[10.3] Can one constructor of a class call another constructor of the same class to initialize the <tt>this</tt> object?</a></li>
<li><a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">[10.4] Is the default constructor for <tt>Fred</tt> always <nobr><tt>Fred::Fred()</tt></nobr>?</a></li>
<li><a href="ctors.html#faq-10.5" title="[10.5] Which constructor gets called when I create an array of Fred objects?">[10.5] Which constructor gets called when I create an array of <tt>Fred</tt> objects?</a></li>
<li><a href="ctors.html#faq-10.6" title="[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?">[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?</a></li>
<li><a href="ctors.html#faq-10.7" title="[10.7] Should you use the this pointer in the constructor?">[10.7] Should you use the <tt>this</tt> pointer in the constructor?</a></li>
<li><a href="ctors.html#faq-10.8" title="[10.8] What is the &quot;Named Constructor Idiom&quot;?">[10.8] What is the &quot;Named Constructor Idiom&quot;?</a></li>
<li><a href="ctors.html#faq-10.9" title="[10.9] Does return-by-value mean extra copies and extra overhead?">[10.9] Does return-by-value mean extra copies and extra overhead?</a></li>
<li><a href="ctors.html#faq-10.10" title="[10.10] Why can't I initialize my static member data in my constructor's initialization list?">[10.10] Why can't I initialize my <tt>static</tt> member data in my constructor's initialization list?</a></li>
<li><a href="ctors.html#faq-10.11" title="[10.11] Why are classes with static data members getting linker errors?">[10.11] Why are classes with <tt>static</tt> data members getting linker errors?</a></li>
<li><a href="ctors.html#faq-10.12" title="[10.12] What's the &quot;static initialization order fiasco&quot;?">[10.12] What's the &quot;<tt>static</tt> initialization order fiasco&quot;?</a></li>
<li><a href="ctors.html#faq-10.13" title="[10.13] How do I prevent the &quot;static initialization order fiasco&quot;?">[10.13] How do I prevent the &quot;<tt>static</tt> initialization order fiasco&quot;?</a></li>
<li><a href="ctors.html#faq-10.14" title="[10.14] Why doesn't the construct-on-first-use idiom use a static object instead of a static pointer?">[10.14] Why doesn't the construct-on-first-use idiom use a static object instead of a static pointer?</a></li>
<li><a href="ctors.html#faq-10.15" title="[10.15] How do I prevent the &quot;static initialization order fiasco&quot; for my static data members?">[10.15] How do I prevent the &quot;<tt>static</tt> initialization order fiasco&quot; for my <tt>static</tt> data members?</a></li>
<li><a href="ctors.html#faq-10.16" title="[10.16] Do I need to worry about the &quot;static initialization order fiasco&quot; for variables of built-in/intrinsic types?">[10.16] Do I need to worry about the &quot;<tt>static</tt> initialization order fiasco&quot; for variables of built-in/intrinsic types?</a></li>
<li><a href="ctors.html#faq-10.17" title="[10.17] How can I handle a constructor that fails?">[10.17] How can I handle a constructor that fails?</a></li>
<li><a href="ctors.html#faq-10.18" title="[10.18] What is the &quot;Named Parameter Idiom&quot;?">[10.18] What is the &quot;Named Parameter Idiom&quot;?</a></li>
<li><a href="ctors.html#faq-10.19" title="[10.19] Why am I getting an error after declaring a Foo object via Foo x(Bar())?">[10.19] Why am I getting an error after declaring a <tt>Foo</tt> object via <nobr><tt>Foo x(Bar())</tt></nobr>?</a></li>
</ul>
<p><hr>
<p><a name="faq-10.1"></a>
<div class=FaqTitle><h3>[10.1] What's the deal with constructors?</h3></div>
<p>Constructors build objects from dust.
<p>Constructors are like &quot;init functions&quot;.  They turn a pile of arbitrary bits
into a living object.  Minimally they initialize internally used fields.  They
may also allocate resources (memory, files, semaphores, sockets, etc).
<p>&quot;ctor&quot; is a typical abbreviation for constructor.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.2"></a>
<div class=FaqTitle><h3>[10.2] Is there any difference between <nobr><tt>List x;</tt></nobr> and <nobr><tt>List x();</tt></nobr>?</h3></div>
<p>A <em>big</em> difference!
<p>Suppose that <tt>List</tt> is the name of some class.  Then function <nobr><tt>f()</tt></nobr> declares
a local <tt>List</tt> object called <tt>x</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;f()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;List&nbsp;x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Local&nbsp;object&nbsp;named&nbsp;<tt>x</tt>&nbsp;(of&nbsp;class&nbsp;<tt>List</tt>)</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>But function <nobr><tt>g()</tt></nobr> declares a function called <nobr><tt>x()</tt></nobr> that returns a
<tt>List</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;g()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;List&nbsp;x();&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Function&nbsp;named&nbsp;<tt>x</tt>&nbsp;(that&nbsp;returns&nbsp;a&nbsp;<tt>List</tt>)</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.3"></a>
<div class=FaqTitle><h3>[10.3] Can one constructor of a class call another constructor of the same class to initialize the <tt>this</tt> object?</h3></div>
<p>Nope.
<p>Let's work an example.  Suppose you want your constructor
<nobr><tt>Foo::Foo(char)</tt></nobr> to call another constructor of the same class, say
<nobr><tt>Foo::Foo(char,int)</tt></nobr>, in order that <nobr><tt>Foo::Foo(char,int)</tt></nobr> would
help initialize the <tt>this</tt> object.  Unfortunately there's no way to do this in
C++.
<p>Some people do it anyway.  Unfortunately it doesn't do what they want.  For
example, the line <nobr><tt>Foo(x, 0);</tt></nobr> does <em>not</em> call
<nobr><tt>Foo::Foo(char,int)</tt></nobr> on the <tt>this</tt> object.  Instead it calls
<nobr><tt>Foo::Foo(char,int)</tt></nobr> to initialize a temporary, local object
(<em>not</em> <tt>this</tt>), then it immediately destructs that temporary when
control flows over the <nobr><tt>;</tt></nobr>.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x);<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x,&nbsp;int&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;Foo::Foo(char&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Foo(x,&nbsp;0);&nbsp;&nbsp;</tt><em><small>//&nbsp;this&nbsp;line&nbsp;does&nbsp;NOT&nbsp;help&nbsp;initialize&nbsp;the&nbsp;<tt>this</tt>&nbsp;object!!</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>You can sometimes combine two constructors via a default parameter:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x,&nbsp;int&nbsp;y=0);&nbsp;&nbsp;</tt><em><small>//&nbsp;this&nbsp;line&nbsp;combines&nbsp;the&nbsp;two&nbsp;constructors</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};
</tt>
</div>
<p>If that doesn't work, e.g., if there isn't an appropriate default parameter
that combines the two constructors, sometimes you can share their common code
in a private <nobr><tt>init()</tt></nobr> member function:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x);<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x,&nbsp;int&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;void&nbsp;init(char&nbsp;x,&nbsp;int&nbsp;y);<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;Foo::Foo(char&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;init(x,&nbsp;int(x)&nbsp;+&nbsp;7);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Foo::Foo(char&nbsp;x,&nbsp;int&nbsp;y)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;init(x,&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;Foo::init(char&nbsp;x,&nbsp;int&nbsp;y)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>BTW do <em>NOT</em> try to achieve this via <a href="dtors.html#faq-11.10" title="[11.10] What is &quot;placement new&quot; and why would I use it?">placement
new<!--rawtext:[11.10]:rawtext--></a>.  Some people think they can say <nobr><tt>new(this) Foo(x, int(x)+7)</tt></nobr>
within the body of <nobr><tt>Foo::Foo(char)</tt></nobr>.  However that is bad, bad, bad.
Please don't write me and tell me that it <em>seems</em> to work on your
particular version of your particular compiler; it's bad.  Constructors do a
bunch of little magical things behind the scenes, but that bad technique steps
on those partially constructed bits.  Just say no.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.4"></a>
<div class=FaqTitle><h3>[10.4] Is the default constructor for <tt>Fred</tt> always <nobr><tt>Fred::Fred()</tt></nobr>?</h3></div>
<p>No.  A &quot;default constructor&quot; is a constructor that <em>can be called</em> with
no arguments.  One example of this is a constructor that takes no parameters:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred();&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Default&nbsp;constructor:&nbsp;can&nbsp;be&nbsp;called&nbsp;with&nbsp;no&nbsp;args</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};
</tt>
</div>
<p>Another example of a &quot;default constructor&quot; is one that can take arguments,
provided they are given default values:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred(int&nbsp;i=3,&nbsp;int&nbsp;j=5);&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Default&nbsp;constructor:&nbsp;can&nbsp;be&nbsp;called&nbsp;with&nbsp;no&nbsp;args</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.5"></a>
<div class=FaqTitle><h3>[10.5] Which constructor gets called when I create an array of <tt>Fred</tt> objects?</h3></div>
<p><tt>Fred</tt>'s <a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default constructor<!--rawtext:[10.4]:rawtext--></a> (except as
discussed below).
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred();<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;a[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;calls&nbsp;the&nbsp;<a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default&nbsp;constructor<!--rawtext:[10.4]:rawtext--></a>&nbsp;10&nbsp;times</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;new&nbsp;Fred[10];&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;calls&nbsp;the&nbsp;<a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default&nbsp;constructor<!--rawtext:[10.4]:rawtext--></a>&nbsp;10&nbsp;times</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>If your class doesn't have a <a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default constructor<!--rawtext:[10.4]:rawtext--></a>,
you'll get a compile-time error when you attempt to create an array using the
above simple syntax:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred(int&nbsp;i,&nbsp;int&nbsp;j);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;assume&nbsp;there&nbsp;is&nbsp;no&nbsp;<a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default&nbsp;constructor<!--rawtext:[10.4]:rawtext--></a></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;a[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;ERROR:&nbsp;<tt>Fred</tt>&nbsp;doesn't&nbsp;have&nbsp;a&nbsp;default&nbsp;constructor</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;new&nbsp;Fred[10];&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;ERROR:&nbsp;<tt>Fred</tt>&nbsp;doesn't&nbsp;have&nbsp;a&nbsp;default&nbsp;constructor</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>However, even if your class already has a default constructor, you should try
to use <a href="class-libraries.html#faq-37.1" title="[37.1] What is the &quot;STL&quot;?"><nobr><tt>std::vector&lt;Fred&gt;</tt></nobr><!--rawtext:[37.1]:rawtext--></a> rather than an
array (<a href="containers.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">arrays are evil<!--rawtext:[34.1]:rawtext--></a>).  <nobr><tt>std::vector</tt></nobr>
lets you decide to use any constructor, not just the default constructor:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;vector&gt;<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::vector&lt;Fred&gt;&nbsp;a(10,&nbsp;Fred(5,7));&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;the&nbsp;10&nbsp;<tt>Fred</tt>&nbsp;objects&nbsp;in&nbsp;<nobr><tt>std::vector</tt></nobr>&nbsp;<tt>a</tt>&nbsp;will&nbsp;be&nbsp;initialized&nbsp;with&nbsp;<nobr><tt>Fred(5,7)</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Even though you <em>ought</em> to use a <nobr><tt>std::vector</tt></nobr> rather than an
array, there are times when an array might be the right thing to do, and for
those, you might need the &quot;explicit initialization of arrays&quot; syntax.  Here's
how:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred(int&nbsp;i,&nbsp;int&nbsp;j);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;assume&nbsp;there&nbsp;is&nbsp;no&nbsp;<a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default&nbsp;constructor<!--rawtext:[10.4]:rawtext--></a></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;a[10]&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;&nbsp;</tt><em><small>//&nbsp;The&nbsp;10&nbsp;<tt>Fred</tt>&nbsp;objects&nbsp;are</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7)&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;initialized&nbsp;using&nbsp;<nobr><tt>Fred(5,7)</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;};<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Of course you don't have to do <nobr><tt>Fred(5,7)</tt></nobr> for every entry &#151; you can
put in any numbers you want, even parameters or other variables.
<p>Finally, <a href="dtors.html#faq-11.10" title="[11.10] What is &quot;placement new&quot; and why would I use it?">you can use placement-new<!--rawtext:[11.10]:rawtext--></a> to manually
initialize the elements of the array.  Warning: it's ugly: the raw array can't
be of type <tt>Fred</tt>, so you'll need a bunch of pointer-casts to do things
like compute array index operations.  Warning: it's compiler- and
hardware-dependent: you'll need to make sure the storage is aligned with an
alignment that is at least as strict as is required for objects of class
<tt>Fred</tt>.  Warning: it's tedious to make it exception-safe: you'll need to
manually destruct the elements, including in the case when an exception is
thrown part-way through the loop that calls the constructors.  But if you
really want to do it anyway, <a href="dtors.html#faq-11.10" title="[11.10] What is &quot;placement new&quot; and why would I use it?">read up on
placement-new<!--rawtext:[11.10]:rawtext--></a>.  (BTW placement-new is the magic that is used inside of
<nobr><tt>std::vector</tt></nobr>.  The complexity of getting everything right is yet
another reason to use <nobr><tt>std::vector</tt></nobr>.)
<p>By the way, did I ever mention that <a href="containers.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">arrays are
evil<!--rawtext:[34.1]:rawtext--></a>?  Or did I mention that you ought to use a <nobr><tt>std::vector</tt></nobr>
unless there is a compelling reason to use an array?
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.6"></a>
<div class=FaqTitle><h3>[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?</h3></div>
<p>Initialization lists.  In fact, constructors should initialize as a rule
<em>all</em> member objects in the initialization list.  One exception is
discussed further down.
<p>Consider the following constructor that initializes member object <tt>x_</tt>
using an initialization list: <nobr><tt>Fred::Fred() : x_(</tt></nobr><em>whatever</em><nobr><tt>)
{&nbsp;}</tt></nobr>.  The most common benefit of doing this is improved performance.
For example, if the expression <em>whatever</em> is the same type as member
variable <tt>x_</tt>, the result of the <em>whatever</em> expression is
constructed directly inside <tt>x_</tt> &#151; the compiler does not make a
separate copy of the object.  Even if the types are not the same, the compiler
is usually able to do a better job with initialization lists than with
assignments.
<p>The other (inefficient) way to build constructors is via assignment, such as:
<nobr><tt>Fred::Fred() {&nbsp;x_&nbsp;=&nbsp;</tt></nobr><em>whatever</em><nobr><tt>;&nbsp;}</tt></nobr>.  In this
case the expression <em>whatever</em> causes a separate, temporary object to be
created, and this temporary object is passed into the <tt>x_</tt> object's
assignment operator.  Then that temporary object is destructed at the
<nobr><tt>;</tt></nobr>.  That's inefficient.
<p>As if that wasn't bad enough, there's another source of inefficiency when
using assignment in a constructor: the member object will get fully constructed
by its default constructor, and this might, for example, allocate some default
amount of memory or open some default file.  All this work could be for naught
if the <em>whatever</em> expression and/or assignment operator causes the
object to close that file and/or release that memory (e.g., if the default
constructor didn't allocate a large enough pool of memory or if it opened the
wrong file).
<p>Conclusion: All other things being equal, your code will run faster if you use
initialization lists rather than assignment.
<p>Note: There is no performance difference if the type of <tt>x_</tt> is some
built-in/intrinsic type, such as <tt>int</tt> or <nobr><tt>char*</tt></nobr> or <tt>float</tt>.  But even in
these cases, my personal preference is to set those data members in the
initialization list rather than via assignment for consistency.  Another
symmetry argument in favor of using initialization lists even for
built-in/intrinsic types: non-static <tt>const</tt> and non-static reference data members <em>can't</em> be
assigned a value in the constructor, so for symmetry it makes sense to
initialize everything in the initialization list.
<p>Now for the exceptions.  Every rule has exceptions (hmmm; does &quot;every rule has
exceptions&quot; have exceptions? reminds me of G&ouml;del's Incompleteness
Theorems), and there are a couple of exceptions to the &quot;use initialization
lists&quot; rule.  Bottom line is to use common sense: if it's cheaper, better,
faster, etc. to not use them, then by all means, don't use them.  This might
happen when your class has two constructors that need to initialize the
<tt>this</tt> object's data members in different orders.  Or it might happen
when two data members are self-referential.  Or when a data-member needs a
reference to the <tt>this</tt> object, and you want to avoid a compiler warning
about using the <tt>this</tt> keyword prior to the <nobr><tt>{</tt></nobr> that begins the
constructor's body (when your particular compiler happens to issue that
particular warning).  Or when you need to do <a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">an
if/throw test on a variable<!--rawtext:[13.10]:rawtext--></a> (parameter, global, etc.) prior to using
that variable to initialize one of your <tt>this</tt> members.  This list is
not exhaustive; please don't write me asking me to add another &quot;Or when...&quot;.
The point is simply this: use common sense.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.7"></a>
<div class=FaqTitle><h3>[10.7] Should you use the <tt>this</tt> pointer in the constructor?</h3></div>
<p>Some people feel you should not use the <tt>this</tt> pointer in a constructor
because the object is not fully formed yet.  However you can use <tt>this</tt>
in the constructor (in the <nobr><tt>{</tt></nobr>body<nobr><tt>}</tt></nobr> and even in the
<a href="ctors.html#faq-10.6" title="[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?">initialization list<!--rawtext:[10.6]:rawtext--></a>) if you are careful.
<p>Here is something that <em>always</em> works: the <nobr><tt>{</tt></nobr>body<nobr><tt>}</tt></nobr> of a constructor
(or a function called from the constructor) can reliably access the data
members declared in a base class and/or the data members declared in the
constructor's own class.  This is because all those data members are
guaranteed to have been fully constructed by the time the constructor's
<nobr><tt>{</tt></nobr>body<nobr><tt>}</tt></nobr> starts executing.
<p>Here is something that <em>never</em> works: the <nobr><tt>{</tt></nobr>body<nobr><tt>}</tt></nobr> of a
constructor (or a function called from the constructor) can<em>not</em> get
down to a derived class by calling a <tt>virtual</tt> member function that is
overridden in the derived class.  If your goal was to get to the overridden
function in the derived class, <a href="strange-inheritance.html#faq-23.5" title="[23.5] When my base class's constructor calls a virtual function on its this object, why doesn't my derived class's override of that virtual function get invoked?">you won't get
what you want<!--rawtext:[23.5]:rawtext--></a>.  Note that you won't get to the override in the derived
class independent of <em>how</em> you call the <tt>virtual</tt> member function:
explicitly using the <tt>this</tt> pointer (e.g., <nobr><tt>this-&gt;method()</tt></nobr>),
implicitly using the <tt>this</tt> pointer (e.g., <nobr><tt>method()</tt></nobr>), or even
calling some other function that calls the <tt>virtual</tt> member function on
your <tt>this</tt> object.  The bottom line is this: even if the caller is
constructing an object of a derived class, during the constructor of the base
class, <a href="strange-inheritance.html#faq-23.5" title="[23.5] When my base class's constructor calls a virtual function on its this object, why doesn't my derived class's override of that virtual function get invoked?">your object is not yet of that
derived class<!--rawtext:[23.5]:rawtext--></a>.  You have been warned.
<p>Here is something that <em>sometimes</em> works: if you pass any of the data
members in <tt>this</tt> object to another data member's
<a href="ctors.html#faq-10.6" title="[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?">initializer<!--rawtext:[10.6]:rawtext--></a>, you must make sure that the other data
member has already been initialized.  The good news is that you can determine
whether the other data member has (or has not) been initialized using some
straightforward language rules that are independent of the particular compiler
you're using.  The bad news it that you have to know those language rules
(e.g., base class sub-objects are initialized first (look up the order if you
have multiple and/or <tt>virtual</tt> inheritance!), then data members defined
in the class are initialized in the order in which they appear in the class
declaration).  If you don't know these rules, then don't pass any data member
from the <tt>this</tt> object (regardless of whether or not you explicitly use
the <tt>this</tt> keyword) to any other data member's
<a href="ctors.html#faq-10.6" title="[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?">initializer<!--rawtext:[10.6]:rawtext--></a>!  And if you do know the rules, please be
careful.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.8"></a>
<div class=FaqTitle><h3>[10.8] What is the &quot;Named Constructor Idiom&quot;?</h3></div>
<p>A technique that provides more intuitive and/or safer construction operations
for users of your class.
<p>The problem is that constructors always have the same name as the class.
Therefore the only way to differentiate between the various constructors of a
class is by the parameter list.  But if there are lots of constructors, the
differences between them become somewhat subtle and error prone.
<p>With the Named Constructor Idiom, you declare all the class's constructors in
the <tt>private</tt> or <tt>protected</tt> sections, and you provide
<tt>public</tt> <tt>static</tt> methods that return an object.  These
<tt>static</tt> methods are the so-called &quot;Named Constructors.&quot; In general
there is one such <tt>static</tt> method for each different way to construct an
object.
<p>For example, suppose we are building a <tt>Point</tt> class that represents a
position on the X-Y plane.  Turns out there are two common ways to specify a
2-space coordinate: rectangular coordinates (X+Y), polar coordinates
(Radius+Angle).  (Don't worry if you can't remember these; the point isn't the
particulars of coordinate systems; the point is that there are several ways to
create a <tt>Point</tt> object.) Unfortunately the parameters for these two
coordinate systems are the same: two <tt>float</tt>s.  This would create an
ambiguity error in the overloaded constructors:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Point&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Point(float&nbsp;x,&nbsp;float&nbsp;y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Rectangular&nbsp;coordinates</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Point(float&nbsp;r,&nbsp;float&nbsp;a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Polar&nbsp;coordinates&nbsp;(radius&nbsp;and&nbsp;angle)</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;ERROR:&nbsp;Overload&nbsp;is&nbsp;Ambiguous:&nbsp;<nobr><tt>Point::Point(float,float)</tt></nobr></small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Point&nbsp;p&nbsp;=&nbsp;Point(5.7,&nbsp;1.2);&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Ambiguous:&nbsp;Which&nbsp;coordinate&nbsp;system?</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>One way to solve this ambiguity is to use the Named Constructor Idiom:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;cmath&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;To&nbsp;get&nbsp;<nobr><tt>sin()</tt></nobr>&nbsp;and&nbsp;<nobr><tt>cos()</tt></nobr></small></em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;Point&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Point&nbsp;rectangular(float&nbsp;x,&nbsp;float&nbsp;y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Rectangular&nbsp;coord's</small></em><tt><br>
&nbsp;&nbsp;&nbsp;static&nbsp;Point&nbsp;polar(float&nbsp;radius,&nbsp;float&nbsp;angle);&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Polar&nbsp;coordinates</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;These&nbsp;<tt>static</tt>&nbsp;methods&nbsp;are&nbsp;the&nbsp;so-called&nbsp;&quot;named&nbsp;constructors&quot;</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;Point(float&nbsp;x,&nbsp;float&nbsp;y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Rectangular&nbsp;coordinates</small></em><tt><br>
&nbsp;&nbsp;&nbsp;float&nbsp;x_,&nbsp;y_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;inline&nbsp;Point::Point(float&nbsp;x,&nbsp;float&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;x_(x),&nbsp;y_(y)&nbsp;{&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;Point&nbsp;Point::rectangular(float&nbsp;x,&nbsp;float&nbsp;y)<br>
&nbsp;{&nbsp;return&nbsp;Point(x,&nbsp;y);&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;Point&nbsp;Point::polar(float&nbsp;radius,&nbsp;float&nbsp;angle)<br>
&nbsp;{&nbsp;return&nbsp;Point(radius*cos(angle),&nbsp;radius*sin(angle));&nbsp;}
</tt>
</div>
<p>Now the users of <tt>Point</tt> have a clear and unambiguous syntax for creating
<tt>Point</tt>s in either coordinate system:
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Point&nbsp;p1&nbsp;=&nbsp;Point::rectangular(5.7,&nbsp;1.2);&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Obviously&nbsp;rectangular</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Point&nbsp;p2&nbsp;=&nbsp;Point::polar(5.7,&nbsp;1.2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Obviously&nbsp;polar</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Make sure your constructors are in the <tt>protected</tt> section if you expect
<tt>Point</tt> to have derived classes.
<p>The Named Constructor Idiom can also be used to
<a href="freestore-mgmt.html#faq-16.21" title="[16.21] How can I force objects of my class to always be created via new rather than as locals or global/static objects?">make sure your objects are always created via
<tt>new</tt><!--rawtext:[16.21]:rawtext--></a>.
<p>Note that the Named Constructor Idiom, at least as implemented above, is just
as fast as directly calling a constructor &#151;
<a href="ctors.html#faq-10.9" title="[10.9] Does return-by-value mean extra copies and extra overhead?">modern compilers will not make any extra
copies of your object<!--rawtext:[10.9]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.9"></a>
<div class=FaqTitle><h3>[10.9] Does return-by-value mean extra copies and extra overhead?</h3></div>
<p>Not necessarily.
<p>All(?) commercial-grade compilers optimize away the extra copy, at least in
cases as illustrated in <a href="ctors.html#faq-10.8" title="[10.8] What is the &quot;Named Constructor Idiom&quot;?">the previous FAQ<!--rawtext:[10.8]:rawtext--></a>.
<p>To keep the example clean, let's strip things down to the bare essentials.
Suppose <nobr><tt>yourCode()</tt></nobr> calls <nobr><tt>rbv()</tt></nobr> (&quot;rbv&quot; stands for &quot;return by
value&quot;) which returns a <tt>Foo</tt> object by value:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Foo&nbsp;{&nbsp;...&nbsp;};<br>
&nbsp;<br>
&nbsp;Foo&nbsp;rbv();<br>
&nbsp;<br>
&nbsp;void&nbsp;yourCode()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Foo&nbsp;x&nbsp;=&nbsp;rbv();&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;the&nbsp;return-value&nbsp;of&nbsp;<nobr><tt>rbv()</tt></nobr>&nbsp;goes&nbsp;into&nbsp;<tt>x</tt></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Now the question is, How many <tt>Foo</tt> objects will there be?  Will
<nobr><tt>rbv()</tt></nobr> create a temporary <tt>Foo</tt> object that gets copy-constructed
into <tt>x</tt>?  How many temporaries?  Said another way, does return-by-value
necessarily degrade performance?
<p>The point of this FAQ is that the answer is No, commercial-grade C++ compilers
implement return-by-value in a way that lets them eliminate the overhead, at
least in simple cases like those shown in the previous FAQ.  In particular,
all(?) commercial-grade C++ compilers will optimize this case:
<p><div class=CodeBlock>
<tt>
&nbsp;Foo&nbsp;rbv()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;Foo(42,&nbsp;73);&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;suppose&nbsp;<tt>Foo</tt>&nbsp;has&nbsp;a&nbsp;ctor&nbsp;<nobr><tt>Foo::Foo(int&nbsp;a,&nbsp;int&nbsp;b)</tt></nobr></small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Certainly the compiler is <em>allowed</em> to create a temporary, local
<tt>Foo</tt> object, then copy-construct that temporary into variable <tt>x</tt>
within <nobr><tt>yourCode()</tt></nobr>, then destruct the temporary.  But all(?)
commercial-grade C++ compilers won't do that: the <tt>return</tt> statement
will directly construct <tt>x</tt> itself.  Not a copy of <tt>x</tt>, not a
pointer to <tt>x</tt>, not a reference to <tt>x</tt>, but <tt>x</tt> itself.
<p>You can stop here if you don't want to genuinely understand the previous
paragraph, but if you want to know the secret sauce (so you can, for example,
reliably predict when the compiler can and cannot provide that optimization
for you), the key is to know that compilers usually implement return-by-value
using pass-by-pointer.  When <nobr><tt>yourCode()</tt></nobr> calls <nobr><tt>rbv()</tt></nobr>, the
compiler secretly passes a pointer to the location where <nobr><tt>rbv()</tt></nobr> is
supposed to construct the &quot;returned&quot; object.  It might look something like
this (it's shown as a <nobr><tt>void*</tt></nobr> rather than a <nobr><tt>Foo*</tt></nobr> since the
<tt>Foo</tt> object has not yet been constructed):
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;Pseudo-code</small></em><tt><br>
&nbsp;void&nbsp;rbv(void*&nbsp;put_result_here)&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Original&nbsp;C++&nbsp;code:&nbsp;<nobr><tt>Foo&nbsp;rbv()</tt></nobr></small></em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;</tt><em><small>//&nbsp;Pseudo-code</small></em><tt><br>
&nbsp;void&nbsp;yourCode()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;struct&nbsp;Foo&nbsp;x;<br>
&nbsp;&nbsp;&nbsp;rbv(&amp;x);&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Original&nbsp;C++&nbsp;code:&nbsp;<nobr><tt>Foo&nbsp;x&nbsp;=&nbsp;rbv()</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>So the first ingredient in the secret sauce is that the compiler (usually)
transforms return-by-value into pass-by-pointer.  This means that
commercial-grade compilers don't bother creating a temporary: they directly
construct the returned object in the location pointed to by
<tt>put_result_here</tt>.
<p>The second ingredient in the secret sauce is that compilers typically
implement constructors using a similar technique.  This is compiler-dependent
and somewhat idealized (I'm intentionally ignoring how to handle <tt>new</tt>
and overloading), but compilers typically implement <nobr><tt>Foo::Foo(int a, int
b)</tt></nobr> using something like this:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;Pseudo-code</small></em><tt><br>
&nbsp;void&nbsp;Foo_ctor(Foo*&nbsp;this,&nbsp;int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Original&nbsp;C++&nbsp;code:&nbsp;<nobr><tt>Foo::Foo(int&nbsp;a,&nbsp;int&nbsp;b)</tt></nobr></small></em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Putting these together, the compiler might implement the <tt>return</tt>
statement in <nobr><tt>rbv()</tt></nobr> by simply passing <tt>put_result_here</tt> as the
constructor's <tt>this</tt> pointer:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;Pseudo-code</small></em><tt><br>
&nbsp;void&nbsp;rbv(void*&nbsp;put_result_here)&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Original&nbsp;C++&nbsp;code:&nbsp;<nobr><tt>Foo&nbsp;rbv()</tt></nobr></small></em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Foo_ctor((Foo*)put_result_here,&nbsp;42,&nbsp;73);&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Original&nbsp;C++&nbsp;code:&nbsp;<nobr><tt>return&nbsp;Foo(42,73);</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;return;<br>
&nbsp;}
</tt>
</div>
<p>So <nobr><tt>yourCode()</tt></nobr> passes <nobr><tt>&amp;x</tt></nobr> to <nobr><tt>rbv()</tt></nobr>, and <nobr><tt>rbv()</tt></nobr> in
turn passes <nobr><tt>&amp;x</tt></nobr> to the constructor (as the <tt>this</tt> pointer).  That
means constructor <em>directly</em> constructs <tt>x</tt>.
<p>In the early 90s I did a seminar for IBM's compiler group in Toronto, and one
of their engineers told me that they found this return-by-value optimization
to be so fast that you get it even if you don't compile with optimization
turned on.  Because the return-by-value optimization causes the compiler to
generate less code, it actually improves compile-times in addition to making
your generated code smaller and faster.  The point is that the return-by-value
optimization is almost universally implemented, at least in code cases like
those shown above.
<p>Some compilers also provide the return-by-value optimization your function
returns a local variable by value, provided <em>all</em> the function's
<tt>return</tt> statements return the same local variable.  This requires a
little more work on the part of the compiler writers, so it isn't universally
implemented; for example, GNU g++ 3.3.3 does it but Microsoft Visual C++.NET
2003 does not:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;Actual&nbsp;C++&nbsp;code&nbsp;for&nbsp;<nobr><tt>rbv()</tt></nobr></small></em><tt><br>
&nbsp;Foo&nbsp;rbv()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Foo&nbsp;ans&nbsp;=&nbsp;Foo(42,&nbsp;73);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;do_something_with(ans);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}
</tt>
</div>
<p>The compiler might construct <tt>ans</tt> in a local object, then in the
<tt>return</tt> statement copy-construct <tt>ans</tt> into the location pointed
to by <tt>put_result_here</tt> and destruct <tt>ans</tt>.  But if <em>all</em>
<tt>return</tt> statements return the same local object, in this case
<tt>ans</tt>, the compiler is also allowed to construct <tt>ans</tt> in the
location pointed to by <tt>put_result_here</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;Pseudo-code</small></em><tt><br>
&nbsp;void&nbsp;rbv(void*&nbsp;put_result_here)&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Original&nbsp;C++&nbsp;code:&nbsp;<nobr><tt>Foo&nbsp;rbv()</tt></nobr></small></em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Foo_ctor((Foo*)put_result_here,&nbsp;42,&nbsp;73);&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Original&nbsp;C++&nbsp;code:&nbsp;<nobr><tt>Foo&nbsp;ans&nbsp;=&nbsp;Foo(42,73);</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;do_something_with(*(Foo*)put_result_here);&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Original&nbsp;C++&nbsp;code:&nbsp;<nobr><tt>do_something_with(ans);</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;return;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Original&nbsp;C++&nbsp;code:&nbsp;<nobr><tt>return&nbsp;ans;</tt></nobr></small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Final thought: this discussion was limited to whether there will be any extra
copies of the returned object in a return-by-value call.  Don't confuse that
with other things that could happen in <nobr><tt>yourCode()</tt></nobr>.  For example, if
you changed <nobr><tt>yourCode()</tt></nobr> from <nobr><tt>Foo x = rbv();</tt></nobr> to <nobr><tt>Foo x;</tt></nobr>
<nobr><tt>x = rbv();</tt></nobr> (note the <nobr><tt>;</tt></nobr> after the declaration), the compiler is
required to use <tt>Foo</tt>'s assignment operator, and unless the compiler can
prove that <tt>Foo</tt>'s default constructor followed by assignment operator
is exactly the same as its copy constructor, the compiler is required by the
language to put the returned object into an unnamed temporary within
<nobr><tt>yourCode()</tt></nobr>, use the assignment operator to copy the temporary into
<tt>x</tt>, then destruct the temporary.  The return-by-value optimization
still plays its part since there will be only one temporary, but by changing
<nobr><tt>Foo x = rbv();</tt></nobr> to <nobr><tt>Foo x;</tt></nobr> <nobr><tt>x = rbv();</tt></nobr>, you have
prevented the compiler from eliminating that last temporary.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.10"></a>
<div class=FaqTitle><h3>[10.10] Why can't I initialize my <tt>static</tt> member data in my constructor's initialization list?</h3></div>
<p>Because you must <em>explicitly</em> define your class's <tt>static</tt> data
members.
<p><tt>Fred.h</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred();<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;int&nbsp;i_;<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;j_;<br>
&nbsp;};
</tt>
</div>
<p><tt>Fred.cpp</tt> (or <tt>Fred.C</tt> or whatever):
<p><div class=CodeBlock>
<tt>
&nbsp;Fred::Fred()<br>
&nbsp;&nbsp;&nbsp;:&nbsp;i_(10)&nbsp;&nbsp;</tt><em><small>//&nbsp;OK:&nbsp;you&nbsp;can&nbsp;(and&nbsp;should)&nbsp;initialize&nbsp;member&nbsp;data&nbsp;this&nbsp;way</small></em><tt><br>
&nbsp;&nbsp;&nbsp;,&nbsp;j_(42)&nbsp;&nbsp;</tt><em><small>//&nbsp;Error:&nbsp;you&nbsp;cannot&nbsp;initialize&nbsp;<tt>static</tt>&nbsp;member&nbsp;data&nbsp;like&nbsp;this</small></em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;</tt><em><small>//&nbsp;You&nbsp;must&nbsp;define&nbsp;<tt>static</tt>&nbsp;data&nbsp;members&nbsp;this&nbsp;way:</small></em><tt><br>
&nbsp;int&nbsp;Fred::j_&nbsp;=&nbsp;42;
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.11"></a>
<div class=FaqTitle><h3>[10.11] Why are classes with <tt>static</tt> data members getting linker errors?</h3></div>
<p>Because <a href="ctors.html#faq-10.10" title="[10.10] Why can't I initialize my static member data in my constructor's initialization list?"><tt>static</tt> data members must be
explicitly defined in exactly one compilation unit<!--rawtext:[10.10]:rawtext--></a>.  If you didn't do
this, you'll probably get an <nobr><tt>&quot;undefined external&quot;</tt></nobr> linker error.  For
example:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;Fred.h</small></em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;j_;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Declares&nbsp;<tt>static</tt>&nbsp;data&nbsp;member&nbsp;<nobr><tt>Fred::j_</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};
</tt>
</div>
<p>The linker will holler at you (<nobr><tt>&quot;Fred::j_ is not defined&quot;</tt></nobr>) unless you
define (as opposed to merely declare) <nobr><tt>Fred::j_</tt></nobr> in (exactly) one of your
source files:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;Fred.cpp</small></em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;Fred.h&quot;<br>
&nbsp;<br>
&nbsp;int&nbsp;Fred::j_&nbsp;=&nbsp;some_expression_evaluating_to_an_int;<br>
&nbsp;<br>
&nbsp;</tt><em><small>//&nbsp;Alternatively,&nbsp;if&nbsp;you&nbsp;wish&nbsp;to&nbsp;use&nbsp;the&nbsp;implicit&nbsp;0&nbsp;value&nbsp;for&nbsp;<tt>static</tt>&nbsp;<tt>int</tt>s:</small></em><tt><br>
&nbsp;</tt><em><small>//&nbsp;<nobr><tt>int&nbsp;Fred::j_;</tt></nobr></small></em><tt>
</tt>
</div>
<p>The usual place to define <tt>static</tt> data members of <tt>class</tt> <tt>Fred</tt> is file
<tt>Fred.cpp</tt> (or <tt>Fred.C</tt> or whatever source file extension you use).
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.12"></a>
<div class=FaqTitle><h3>[10.12] What's the &quot;<tt>static</tt> initialization order fiasco&quot;?</h3></div>
<p>A subtle way to crash your program.
<p>The <em><tt>static</tt> initialization order fiasco</em> is a very subtle and
commonly misunderstood aspect of C++.  Unfortunately it's very hard to detect
&#151; the errors occur before <nobr><tt>main()</tt></nobr> begins.
<p>In short, suppose you have two <tt>static</tt> objects <tt>x</tt> and <tt>y</tt>
which exist in separate source files, say <tt>x.cpp</tt> and <tt>y.cpp</tt>.
Suppose further that the initialization for the <tt>y</tt> object (typically
the <tt>y</tt> object's constructor) calls some method on the <tt>x</tt> object.
<p>That's it.  It's that simple.
<p>The tragedy is that you have a 50%-50% chance of dying.  If the compilation
unit for <tt>x.cpp</tt> happens to get initialized first, all is well.  But if
the compilation unit for <tt>y.cpp</tt> get initialized first, then <tt>y</tt>'s
initialization will get run before <tt>x</tt>'s initialization, and you're
toast.  E.g., <tt>y</tt>'s constructor could call a method on the <tt>x</tt>
object, yet the <tt>x</tt> object hasn't yet been constructed.
<p>I hear they're hiring down at McDonalds.  Enjoy your new job flipping burgers.
<p>If you think it's &quot;exciting&quot; to play Russian Roulette with live rounds in half
the chambers, you can stop reading here.  On the other hand if you like to
improve your chances of survival by preventing disasters in a systematic way,
you probably want to read <a href="ctors.html#faq-10.13" title="[10.13] How do I prevent the &quot;static initialization order fiasco&quot;?">the next
FAQ<!--rawtext:[10.13]:rawtext--></a>.
<p>Note: The static initialization order fiasco can also,
<a href="ctors.html#faq-10.16" title="[10.16] Do I need to worry about the &quot;static initialization order fiasco&quot; for variables of built-in/intrinsic types?">in some cases<!--rawtext:[10.16]:rawtext--></a>, apply to
built-in/intrinsic types.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.13"></a>
<div class=FaqTitle><h3>[10.13] How do I prevent the &quot;<tt>static</tt> initialization order fiasco&quot;?</h3></div>
<p>Use the &quot;construct on first use&quot; idiom, which simply means to wrap your
<tt>static</tt> object inside a function.
<p>For example, suppose you have two classes, <tt>Fred</tt> and <tt>Barney</tt>.
There is a global <tt>Fred</tt> object called <tt>x</tt>, and a global
<tt>Barney</tt> object called <tt>y</tt>.  <tt>Barney</tt>'s constructor invokes
the <nobr><tt>goBowling()</tt></nobr> method on the <tt>x</tt> object.  The file
<tt>x.cpp</tt> defines the <tt>x</tt> object:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;x.cpp</small></em><tt><br>
&nbsp;#include&nbsp;&quot;Fred.h&quot;<br>
&nbsp;Fred&nbsp;x;
</tt>
</div>
<p>The file <tt>y.cpp</tt> defines the <tt>y</tt> object:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;y.cpp</small></em><tt><br>
&nbsp;#include&nbsp;&quot;Barney.h&quot;<br>
&nbsp;Barney&nbsp;y;
</tt>
</div>
<p>For completeness the <tt>Barney</tt> constructor might look something like
this:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;Barney.cpp</small></em><tt><br>
&nbsp;#include&nbsp;&quot;Barney.h&quot;<br>
&nbsp;<br>
&nbsp;Barney::Barney()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;x.goBowling();<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>As described <a href="ctors.html#faq-10.12" title="[10.12] What's the &quot;static initialization order fiasco&quot;?">above<!--rawtext:[10.12]:rawtext--></a>, the disaster occurs if
<tt>y</tt> is constructed before <tt>x</tt>, which happens 50% of the time since
they're in different source files.
<p>There are many solutions to this problem, but a very simple and completely
portable solution is to replace the global <tt>Fred</tt> object, <tt>x</tt>,
with a global function, <nobr><tt>x()</tt></nobr>, that returns the <tt>Fred</tt> object by
reference.
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;x.cpp</small></em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;Fred.h&quot;<br>
&nbsp;<br>
&nbsp;Fred&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred*&nbsp;ans&nbsp;=&nbsp;new&nbsp;Fred();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;*ans;<br>
&nbsp;}
</tt>
</div>
<p>Since <tt>static</tt> local objects are constructed the first time control
flows over their declaration (only), the above <nobr><tt>new Fred()</tt></nobr> statement
will only happen once: the first time <nobr><tt>x()</tt></nobr> is called.  Every subsequent
call will return the same <tt>Fred</tt> object (the one pointed to by
<tt>ans</tt>).  Then all you do is change your usages of <tt>x</tt> to
<nobr><tt>x()</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;Barney.cpp</small></em><tt><br>
&nbsp;#include&nbsp;&quot;Barney.h&quot;<br>
&nbsp;<br>
&nbsp;Barney::Barney()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;x().goBowling();<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>This is called the <em>Construct On First Use Idiom</em> because it does just
that: the global <tt>Fred</tt> object is constructed on its first use.
<p>The downside of this approach is that the <tt>Fred</tt> object is never
destructed.  There is <a href="ctors.html#faq-10.14" title="[10.14] Why doesn't the construct-on-first-use idiom use a static object instead of a static pointer?">another technique<!--rawtext:[10.14]:rawtext--></a>
that answers this concern, but it needs to be used with care since it creates
the possibility of another (equally nasty) problem.
<p>Note: The static initialization order fiasco can also,
<a href="ctors.html#faq-10.16" title="[10.16] Do I need to worry about the &quot;static initialization order fiasco&quot; for variables of built-in/intrinsic types?">in some cases<!--rawtext:[10.16]:rawtext--></a>, apply to
built-in/intrinsic types.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.14"></a>
<div class=FaqTitle><h3>[10.14] Why doesn't the construct-on-first-use idiom use a static object instead of a static pointer?</h3></div>
<p>Short answer: it's possible to use a static object
<a href="ctors.html#faq-10.13" title="[10.13] How do I prevent the &quot;static initialization order fiasco&quot;?">rather than a static pointer<!--rawtext:[10.13]:rawtext--></a>, but
doing so opens up another (equally subtle, equally nasty) problem.
<p>Long answer: sometimes people worry about the fact that
<a href="ctors.html#faq-10.13" title="[10.13] How do I prevent the &quot;static initialization order fiasco&quot;?">the previous solution<!--rawtext:[10.13]:rawtext--></a> &quot;leaks.&quot; In
many cases, this is not a problem, but it is a problem in some cases.  Note:
even though the object pointed to by <tt>ans</tt> in the previous FAQ is never
deleted, the memory doesn't actually &quot;leak&quot; when the program exits since the
operating system automatically reclaims all the memory in a program's heap
when that program exits.  In other words, the only time you'd need to worry
about this is when the destructor for the <tt>Fred</tt> object performs some
important action (such as writing something to a file) that must occur
sometime while the program is exiting.
<p>In those cases where the construct-on-first-use object (the <tt>Fred</tt>, in
this case) needs to eventually get destructed, you might consider changing
function <nobr><tt>x()</tt></nobr> as follows:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;x.cpp</small></em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;Fred.h&quot;<br>
&nbsp;<br>
&nbsp;Fred&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&nbsp;ans;&nbsp;&nbsp;</tt><em><small>//&nbsp;was&nbsp;<nobr><tt>static&nbsp;Fred*&nbsp;ans&nbsp;=&nbsp;new&nbsp;Fred();</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;was&nbsp;<nobr><tt>return&nbsp;*ans;</tt></nobr></small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>However there is (or rather, may be) a rather subtle problem with this change.
To understand this potential problem, let's remember why we're doing all this
in the first place: we need to make 100% sure our static object (a) gets
constructed prior to its first use and (b) doesn't get destructed until after
its last use.  Obviously it would be a disaster if any static object got used
either before construction or after destruction.  The message here is that you
need to worry about two situations (static initialization and static
deinitialization), not just one.
<p>By changing the declaration from <nobr><tt>static Fred* ans = new Fred();</tt></nobr> to
<nobr><tt>static Fred ans;</tt></nobr>, we still correctly handle the initialization
situation but we no longer handle the deinitialization situation.  For
example, if there are 3 static objects, say <tt>a</tt>, <tt>b</tt> and
<tt>c</tt>, that use <tt>ans</tt> during their destructors, the only way to
avoid a static deinitialization disaster is if <tt>ans</tt> is destructed after
all three.
<p>The point is simple: if there are any other static objects whose destructors
might use <tt>ans</tt> after <tt>ans</tt> is destructed, bang, you're dead.  If
the <em>constructors</em> of <tt>a</tt>, <tt>b</tt> and <tt>c</tt> use
<tt>ans</tt>, you <em>should</em> normally be okay since the runtime system
will, during static deinitialization, destruct <tt>ans</tt> after the last of
those three objects is destructed.  However if <tt>a</tt> and/or <tt>b</tt>
and/or <tt>c</tt> fail to use <tt>ans</tt> in their constructors and/or if any
code anywhere gets the address of <tt>ans</tt> and hands it to some other
static object, all bets are off and you have to be very, very careful.
<p>There is a third approach that handles both the static initialization and
static deinitialization situations, but it has other non-trivial costs.  I'm
too lazy (and busy!) to write any more FAQs today so if you're interested in
that third approach, you'll have to buy a book that describes that third
approach in detail.  The <a href="faq-book.html#faq-3.1" title="[3.1] Is there a C++ FAQ Book in addition to the C++ FAQ Lite?">C++ FAQs book<!--rawtext:[3.1]:rawtext--></a> is one of
those books, and it also gives the cost/benefit analysis to decide if/when
that third approach should be used.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.15"></a>
<div class=FaqTitle><h3>[10.15] How do I prevent the &quot;<tt>static</tt> initialization order fiasco&quot; for my <tt>static</tt> data members?</h3></div>
<p>Just use <a href="ctors.html#faq-10.13" title="[10.13] How do I prevent the &quot;static initialization order fiasco&quot;?">the same technique just
described<!--rawtext:[10.13]:rawtext--></a>, but this time use a <tt>static</tt> member function rather than a
global function.
<p>Suppose you have a class <tt>X</tt> that has a <tt>static</tt> <tt>Fred</tt> object:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;X.h</small></em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;X&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&nbsp;x_;<br>
&nbsp;};
</tt>
</div>
<p>Naturally this <tt>static</tt> member is initialized separately:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;X.cpp</small></em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;X.h&quot;<br>
&nbsp;<br>
&nbsp;Fred&nbsp;X::x_;
</tt>
</div>
<p>Naturally also the <tt>Fred</tt> object will be used in one or more of
<tt>X</tt>'s methods:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;X::someMethod()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x_.goBowling();<br>
&nbsp;}
</tt>
</div>
<p>But now the &quot;disaster scenario&quot; is if someone somewhere somehow calls this
method before the <tt>Fred</tt> object gets constructed.  For example, if
someone else creates a static <tt>X</tt> object and invokes its
<nobr><tt>someMethod()</tt></nobr> method during <tt>static</tt> initialization, then you're at the
mercy of the compiler as to whether the compiler will construct <nobr><tt>X::x_</tt></nobr>
before or after the <nobr><tt>someMethod()</tt></nobr> is called.  (Note that the ANSI/ISO
C++ committee is working on this problem, but compilers aren't yet generally
available that handle these changes; watch this space for an update in the
future.)
<p>In any event, it's always portable and safe to change the <nobr><tt>X::x_</tt></nobr>
<tt>static</tt> data member into a <tt>static</tt> member function:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;X.h</small></em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;X&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&amp;&nbsp;x();<br>
&nbsp;};
</tt>
</div>
<p>Naturally this <tt>static</tt> member is initialized separately:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;X.cpp</small></em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;X.h&quot;<br>
&nbsp;<br>
&nbsp;Fred&amp;&nbsp;X::x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred*&nbsp;ans&nbsp;=&nbsp;new&nbsp;Fred();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;*ans;<br>
&nbsp;}
</tt>
</div>
<p>Then you simply change any usages of <tt>x_</tt> to <nobr><tt>x()</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;X::someMethod()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x().goBowling();<br>
&nbsp;}
</tt>
</div>
<p>If you're super performance sensitive and you're concerned about the overhead
of an extra function call on each invocation of <nobr><tt>X::someMethod()</tt></nobr> you can
set up a <tt>static</tt> <nobr><tt>Fred&amp;</tt></nobr> instead.  As you recall, <tt>static</tt> local are
only initialized once (the first time control flows over their declaration), so
this will call <nobr><tt>X::x()</tt></nobr> only once: the first time <nobr><tt>X::someMethod()</tt></nobr>
is called:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;X::someMethod()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&amp;&nbsp;x&nbsp;=&nbsp;X::x();<br>
&nbsp;&nbsp;&nbsp;x.goBowling();<br>
&nbsp;}
</tt>
</div>
<p>Note: The static initialization order fiasco can also,
<a href="ctors.html#faq-10.16" title="[10.16] Do I need to worry about the &quot;static initialization order fiasco&quot; for variables of built-in/intrinsic types?">in some cases<!--rawtext:[10.16]:rawtext--></a>, apply to
built-in/intrinsic types.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.16"></a>
<div class=FaqTitle><h3>[10.16] Do I need to worry about the &quot;<tt>static</tt> initialization order fiasco&quot; for variables of built-in/intrinsic types?</h3></div>
<p>Yes.
<p>If you initialize your built-in/intrinsic type using a function call, the
static initialization order fiasco is able to kill you just as bad as with
user-defined/class types.  For example, the following code shows the failure:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;<br>
&nbsp;int&nbsp;f();&nbsp;&nbsp;</tt><em><small>//&nbsp;forward&nbsp;declaration</small></em><tt><br>
&nbsp;int&nbsp;g();&nbsp;&nbsp;</tt><em><small>//&nbsp;forward&nbsp;declaration</small></em><tt><br>
&nbsp;<br>
&nbsp;int&nbsp;x&nbsp;=&nbsp;f();<br>
&nbsp;int&nbsp;y&nbsp;=&nbsp;g();<br>
&nbsp;<br>
&nbsp;int&nbsp;f()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;using&nbsp;'y'&nbsp;(which&nbsp;is&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;y&nbsp;&lt;&lt;&nbsp;&quot;)\n&quot;;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;3*y&nbsp;+&nbsp;7;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&nbsp;g()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;initializing&nbsp;'y'\n&quot;;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;5;<br>
&nbsp;}
</tt>
</div>
<p>The output of this little program will show that it uses <tt>y</tt> before
initializing it.  The solution, as before, is the <em>Construct On First Use
Idiom</em>:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;<br>
&nbsp;int&nbsp;f();&nbsp;&nbsp;</tt><em><small>//&nbsp;forward&nbsp;declaration</small></em><tt><br>
&nbsp;int&nbsp;g();&nbsp;&nbsp;</tt><em><small>//&nbsp;forward&nbsp;declaration</small></em><tt><br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans&nbsp;=&nbsp;f();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;y()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans&nbsp;=&nbsp;g();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&nbsp;f()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;using&nbsp;'y'&nbsp;(which&nbsp;is&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;y()&nbsp;&lt;&lt;&nbsp;&quot;)\n&quot;;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;3*y()&nbsp;+&nbsp;7;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&nbsp;g()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;initializing&nbsp;'y'\n&quot;;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;5;<br>
&nbsp;}
</tt>
</div>
<p>Of course you might be able to simplify this by moving the initialization code
for <tt>x</tt> and <tt>y</tt> into their respective functions:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;y();&nbsp;&nbsp;</tt><em><small>//&nbsp;forward&nbsp;declaration</small></em><tt><br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;static&nbsp;bool&nbsp;firstTime&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(firstTime)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstTime&nbsp;=&nbsp;false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;using&nbsp;'y'&nbsp;(which&nbsp;is&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;y()&nbsp;&lt;&lt;&nbsp;&quot;)\n&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;3*y()&nbsp;+&nbsp;7;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;y()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;static&nbsp;bool&nbsp;firstTime&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(firstTime)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstTime&nbsp;=&nbsp;false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;initializing&nbsp;'y'\n&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;5;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}
</tt>
</div>
<p>And, if you can get rid of the print statements you can further simplify these
to something really simple:
<p><div class=CodeBlock>
<tt>
&nbsp;int&amp;&nbsp;y();&nbsp;&nbsp;</tt><em><small>//&nbsp;forward&nbsp;declaration</small></em><tt><br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans&nbsp;=&nbsp;3*y()&nbsp;+&nbsp;7;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;y()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans&nbsp;=&nbsp;5;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}
</tt>
</div>
<p>Furthermore, since <tt>y</tt> is initialized using a constant expression, it no
longer needs its wrapper function &#151; it can be a simple variable again.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.17"></a>
<div class=FaqTitle><h3>[10.17] How can I handle a constructor that fails?</h3></div>
<p>Throw an exception.  See <a href="exceptions.html#faq-17.2" title="[17.2] How can I handle a constructor that fails?">[17.2]</a> for details.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.18"></a>
<div class=FaqTitle><h3>[10.18] What is the &quot;Named Parameter Idiom&quot;?</h3></div>
<p>It's a fairly useful way to exploit <a href="references.html#faq-8.4" title="[8.4] What does object.method1().method2() mean?">method
chaining<!--rawtext:[8.4]:rawtext--></a>.
<p>The fundamental problem solved by the Named Parameter Idiom is that C++ only
supports <em>positional parameters</em>.  For example, a caller of a function
isn't allowed to say, &quot;Here's the value for formal parameter <tt>xyz</tt>, and
this other thing is the value for formal parameter <tt>pqr</tt>.&quot; All you can
do in C++ (and C and Java) is say, &quot;Here's the first parameter, here's the
second parameter, etc.&quot; The alternative, called <em>named parameters</em> and
implemented in the language Ada, is especially useful if a function takes a
large number of mostly default-able parameters.
<p>Over the years people have cooked up lots of workarounds for the lack of named
parameters in C and C++.  One of these involves burying the parameter values
in a string parameter then parsing this string at run-time.  This is what's
done in the second parameter of <nobr><tt>fopen()</tt></nobr>, for example.  Another
workaround is to combine all the boolean parameters in a bit-map, then the
caller <em>or</em>'s a bunch of bit-shifted constants together to produce the
actual parameter.  This is what's done in the second parameter of
<nobr><tt>open()</tt></nobr>, for example.  These approaches work, but the following
technique produces caller-code that's more obvious, easier to write, easier to
read, and is generally more elegant.
<p>The idea, called the Named Parameter Idiom, is to change the function's
parameters to methods of a newly created class, where all these methods return
<nobr><tt>*this</tt></nobr> by reference.  Then you simply rename the main function into a
parameterless &quot;do-it&quot; method on that class.
<p>We'll work an example to make the previous paragraph easier to understand.
<p>The example will be for the &quot;open a file&quot; concept.  Let's say that concept
logically requires a parameter for the file's name, and optionally allows
parameters for whether the file should be opened read-only <em>vs.</em> read-write
<em>vs.</em> write-only, whether or not the file should be created if it doesn't
already exist, whether the writing location should be at the end (&quot;append&quot;) or
the beginning (&quot;overwrite&quot;), the block-size if the file is to be created,
whether the I/O is buffered or non-buffered, the buffer-size, whether it is to
be shared <em>vs.</em> exclusive access, and probably a few others.  If we implemented
this concept using a normal function with positional parameters, the caller
code would be very difficult to read: there'd be as many as 8 positional
parameters, and the caller would probably make a lot of mistakes.  So instead
we use the Named Parameter Idiom.
<p>Before we go through the implementation, here's what the caller code might
look like, assuming you are willing to accept all the function's default
parameters:
<p><div class=CodeBlock>
<tt>
&nbsp;File&nbsp;f&nbsp;=&nbsp;OpenFile(&quot;foo.txt&quot;);
</tt>
</div>
<p>That's the easy case.  Now here's what it might look like if you want to
change a bunch of the parameters.
<p><div class=CodeBlock>
<tt>
&nbsp;File&nbsp;f&nbsp;=&nbsp;OpenFile(&quot;foo.txt&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.readonly()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.createIfNotExist()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.appendWhenWriting()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.blockSize(1024)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.unbuffered()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.exclusiveAccess();
</tt>
</div>
<p>Notice how the &quot;parameters&quot;, if it's fair to call them that, are in random
order (they're not positional) and they all have names.  So the programmer
doesn't have to remember the order of the parameters, and the names are
(hopefully) obvious.
<p>So here's how to implement it: first we create a class (<tt>OpenFile</tt>) that
houses all the parameter values as <tt>private</tt> data members.  The required
parameters (in this case, the only required parameter is the file's name) is
implemented as a normal, positional parameter on <tt>OpenFile</tt>'s
constructor, but that constructor doesn't actually open the file.  Then all
the optional parameters (readonly <em>vs.</em> readwrite, etc.) become methods.  These
methods (e.g., <nobr><tt>readonly()</tt></nobr>, <nobr><tt>blockSize(unsigned)</tt></nobr>, etc.) return a
reference to their <tt>this</tt> object so the method calls can be
<a href="references.html#faq-8.4" title="[8.4] What does object.method1().method2() mean?">chained<!--rawtext:[8.4]:rawtext--></a>.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;File;<br>
&nbsp;<br>
&nbsp;class&nbsp;OpenFile&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;OpenFile(const&nbsp;std::string&amp;&nbsp;filename);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;sets&nbsp;all&nbsp;the&nbsp;default&nbsp;values&nbsp;for&nbsp;each&nbsp;data&nbsp;member</small></em><tt><br>
&nbsp;&nbsp;&nbsp;OpenFile&amp;&nbsp;readonly();&nbsp;&nbsp;</tt><em><small>//&nbsp;changes&nbsp;<tt>readonly_</tt>&nbsp;to&nbsp;<tt>true</tt></small></em><tt><br>
&nbsp;&nbsp;&nbsp;OpenFile&amp;&nbsp;readwrite();&nbsp;</tt><em><small>//&nbsp;changes&nbsp;<tt>readonly_</tt>&nbsp;to&nbsp;<tt>false</tt></small></em><tt><br>
&nbsp;&nbsp;&nbsp;OpenFile&amp;&nbsp;createIfNotExist();<br>
&nbsp;&nbsp;&nbsp;OpenFile&amp;&nbsp;blockSize(unsigned&nbsp;nbytes);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;class&nbsp;File;<br>
&nbsp;&nbsp;&nbsp;std::string&nbsp;filename_;<br>
&nbsp;&nbsp;&nbsp;bool&nbsp;readonly_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;defaults&nbsp;to&nbsp;<tt>false</tt>&nbsp;[for&nbsp;example]</small></em><tt><br>
&nbsp;&nbsp;&nbsp;bool&nbsp;createIfNotExist_;&nbsp;&nbsp;</tt><em><small>//&nbsp;defaults&nbsp;to&nbsp;<tt>false</tt>&nbsp;[for&nbsp;example]</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;unsigned&nbsp;blockSize_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;defaults&nbsp;to&nbsp;4096&nbsp;[for&nbsp;example]</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;inline&nbsp;OpenFile::OpenFile(const&nbsp;std::string&amp;&nbsp;filename)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;filename_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filename)<br>
&nbsp;&nbsp;&nbsp;,&nbsp;readonly_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(false)<br>
&nbsp;&nbsp;&nbsp;,&nbsp;createIfNotExist_&nbsp;(false)<br>
&nbsp;&nbsp;&nbsp;,&nbsp;blockSize_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4096u)<br>
&nbsp;{&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;OpenFile&amp;&nbsp;OpenFile::readonly()<br>
&nbsp;{&nbsp;readonly_&nbsp;=&nbsp;true;&nbsp;return&nbsp;*this;&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;OpenFile&amp;&nbsp;OpenFile::readwrite()<br>
&nbsp;{&nbsp;readonly_&nbsp;=&nbsp;false;&nbsp;return&nbsp;*this;&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;OpenFile&amp;&nbsp;OpenFile::createIfNotExist()<br>
&nbsp;{&nbsp;createIfNotExist_&nbsp;=&nbsp;true;&nbsp;return&nbsp;*this;&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;OpenFile&amp;&nbsp;OpenFile::blockSize(unsigned&nbsp;nbytes)<br>
&nbsp;{&nbsp;blockSize_&nbsp;=&nbsp;nbytes;&nbsp;return&nbsp;*this;&nbsp;}
</tt>
</div>
<p>The only other thing to do is make the constructor for class <tt>File</tt> to
take an <tt>OpenFile</tt> object:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;File&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;File(const&nbsp;OpenFile&amp;&nbsp;params);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};
</tt>
</div>
<p>This constructor gets the actual parameters from the OpenFile object, then actually opens the file:
<p><div class=CodeBlock>
<tt>
&nbsp;File::File(const&nbsp;OpenFile&amp;&nbsp;params)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Note that <tt>OpenFile</tt> declares <tt>File</tt> as its
<a href="friends.html" title="[14] Friends"><tt>friend</tt><!--rawtext:[14]:rawtext--></a>, that way
<a href="friends.html#faq-14.2" title="[14.2] Do friends violate encapsulation?"><tt>OpenFile</tt> doesn't need a bunch of (otherwise
useless) <nobr><tt>public:</tt></nobr> <em>get</em> methods<!--rawtext:[14.2]:rawtext--></a>.
<p>Since each member function in the chain returns a reference, there is no
copying of objects and the chain is highly efficient.  Furthermore, if the
various member functions are <tt>inline</tt>, the generated object code will probably
be on par with C-style code that sets various members of a <tt>struct</tt>.  Of
course if the member functions are not <tt>inline</tt>, there may be a slight
increase in code size and a slight decrease in performance (but only if the
construction occurs on the critical path of a CPU-bound program; this is a can
of worms I'll try to avoid opening; read <a href="faq-book.html#faq-3.1" title="[3.1] Is there a C++ FAQ Book in addition to the C++ FAQ Lite?">the C++ FAQs
book<!--rawtext:[3.1]:rawtext--></a> for a rather thorough discussion of the issues), so it may, in this
case, be a tradeoff for making the code more reliable.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.19"></a>
<div class=FaqTitle><h3>[10.19] Why am I getting an error after declaring a <tt>Foo</tt> object via <nobr><tt>Foo x(Bar())</tt></nobr>?</h3></div>
<p>Because that doesn't create a <tt>Foo</tt> object - it declares a non-member
function that <em>returns</em> a <tt>Foo</tt> object.
<p>This is really going to hurt; you might want to sit down.
<p>First, here's a better explanation of the problem.  Suppose there is a class
called <tt>Bar</tt> that has a default ctor.  This might even be a library
class such as <nobr><tt>std::string</tt></nobr>, but for now we'll just call it <tt>Bar</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Bar&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Bar();<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};
</tt>
</div>
<p>Now suppose there's another class called <tt>Foo</tt> that has a ctor that
takes a <tt>Bar</tt>.  As before, this might be defined by someone other than
you.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(const&nbsp;Bar&amp;&nbsp;b);&nbsp;&nbsp;</tt><em><small>//&nbsp;or&nbsp;perhaps&nbsp;<nobr><tt>Foo(Bar&nbsp;b)</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;void&nbsp;blah();<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};
</tt>
</div>
<p>Now you want to create a <tt>Foo</tt> object using a temporary <tt>Bar</tt>.  In
other words, you want to create an object via <nobr><tt>Bar()</tt></nobr>, and pass that to
the <tt>Foo</tt> ctor to create a local <tt>Foo</tt> object called <tt>x</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;yourCode()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Foo&nbsp;x(Bar());&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;you&nbsp;<b>think</b>&nbsp;this&nbsp;creates&nbsp;a&nbsp;<tt>Foo</tt>&nbsp;object&nbsp;called&nbsp;<tt>x</tt>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;x.blah();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;...but&nbsp;it&nbsp;doesn't,&nbsp;so&nbsp;this&nbsp;line&nbsp;gives&nbsp;you&nbsp;a&nbsp;bizarre&nbsp;error&nbsp;message</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>It's a long story, but the solution (hope you're sitting down!) is to use
<nobr><tt>=</tt></nobr> in your declaration:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;yourCode()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Foo&nbsp;x&nbsp;=&nbsp;Foo(Bar());&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Yes,&nbsp;Virginia,&nbsp;that&nbsp;thar&nbsp;syntax&nbsp;really&nbsp;works</small></em><tt><br>
&nbsp;&nbsp;&nbsp;x.blah();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;Ahhhh,&nbsp;this&nbsp;works&nbsp;now&nbsp;&#151;&nbsp;no&nbsp;more&nbsp;error&nbsp;messages</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Here's <em>why</em> that happens (this part is optional; only read it if you
think your future as a programmer is worth two minutes of your precious time
today): When the compiler sees <nobr><tt>Foo x(Bar())</tt></nobr>, it thinks that the
<nobr><tt>Bar()</tt></nobr> part is declaring a non-member function that returns a
<tt>Bar</tt> object, so it thinks you are declaring the existence of a
<em>function</em> called <tt>x</tt> that returns a <tt>Foo</tt> and that takes as
a single parameter of type &quot;non-member function that takes nothing and returns
a <tt>Bar</tt>.&quot;
<p>Now here's the sad part.  In fact it's pathetic.  Some mindless drone out
there is going to skip that last paragraph, then they're going to impose a
bizarre, incorrect, irrelevant, and just plain <em>stupid</em> coding standard
that says something like, &quot;Never create temporaries using a default
constructor&quot; or &quot;Always use <nobr><tt>=</tt></nobr> in all initializations&quot; or something
else equally inane.  If that's you, please fire yourself before you do any
more damage.  Those who don't <em>understand the problem</em> shouldn't tell
others how to solve it.  Harumph.
<p>(Okay, that was mostly tongue in cheek.  But there's a grain of truth in it.
The real problem is that people tend to worship consistency, and they tend to
extrapolate from the obscure to the common.  That's not wise.)
<p>Follow-up: if your <nobr><tt>Foo::Foo(const Bar&amp;)</tt></nobr> constructor is not
<tt>explicit</tt>, and if <tt>Foo</tt>'s copy constructor is accessible, you can
use this syntax instead: <nobr><tt>Foo x = Bar();</tt></nobr>.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="bottom"></a>
<a href="mailto:cline@parashift.com" title="cline@parashift.com"><img src="mbox.gif" height=26 width=89 alt="E-Mail">&nbsp;E-mail the author</a><br>
[&nbsp;<a href="index-2.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>
|&nbsp;<a href="index-2.html#table-of-contents" title="Table of contents">Table&nbsp;of&nbsp;contents</a>
|&nbsp;<a href="subject-index.html" title="Subject index; 5111 links to 3243 topics">Subject&nbsp;index</a>
|&nbsp;<a href="copy-permissions.html#faq-1.1" title="[1.1] Author">About&nbsp;the&nbsp;author</a>
|&nbsp;<a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">&copy;</a>
|&nbsp;<a href="on-line-availability.html#faq-2.2" title="[2.2] What happened to the one-click-download option?">Download&nbsp;your&nbsp;own&nbsp;copy</a>&nbsp;]<br>
<small>Revised Mar 1, 2006</small>
</body>

<!-- Mirrored from www.dietmar-kuehl.de/mirror/c++-faq/ctors.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 18 Sep 2025 13:11:21 GMT -->
</html>
