<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>

<!-- Mirrored from www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 18 Sep 2025 13:11:21 GMT -->
<head>
<title>[13] Operator overloading &nbsp;Updated!&nbsp;, C++ FAQ Lite</title>
<meta name="FILENAME" content="operator-overloading.html">
<meta name="ABSTRACT" content="[13] Operator overloading [Updated!], C++ FAQ Lite">
<meta name="OWNER"    content="cline@parashift.com">
<meta name="AUTHOR"   content="Marshall Cline, cline@parashift.com">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rev=made href="mailto:cline@parashift.com">
<style type='text/css'>
  <!--
  body       { font-family: arial; color: black; background: white }
  .CodeBlock { color: black; background-color: #dfdfdf; margin-left: 30px; margin-right: 30px; padding: 5pt }
  .CodeBlock small tt { font-size: small }
  .FaqTitle  { color: black; background-color: gold }
  .Updated   { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #ffff00; border: solid #e0e000 1px; }
  .New       { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #00ff00; border: solid #00d000 1px; }
  ul         { margin-bottom: 1px; margin-top: 1px }
  ol         { margin-bottom: 1px; margin-top: 1px }
  li         { margin-bottom: 4px; margin-top: 4px }
  -->
</style>
</head>
<body>
<h1><a name="top"></a>[13] Operator overloading <span class=Updated>&nbsp;Updated!&nbsp;</span><br>
<small><small>(Part of <a href="index-2.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>, <a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">Copyright&nbsp;&copy; 1991-2006</a>, <a href="http://www.parashift.com/" title="www.parashift.com/" target='_blank'>Marshall Cline</a>, <a href="mailto:cline@parashift.com" title="cline@parashift.com"><tt>cline@parashift.com</tt></a>)</small></small></h1>
<hr>
<h3>FAQs in section [13]:</h3>
<ul>
<li><a href="operator-overloading.html#faq-13.1" title="[13.1] What's the deal with operator overloading?">[13.1] What's the deal with <tt>operator</tt> overloading?</a></li>
<li><a href="operator-overloading.html#faq-13.2" title="[13.2] What are the benefits of operator overloading?">[13.2] What are the benefits of operator overloading?</a></li>
<li><a href="operator-overloading.html#faq-13.3" title="[13.3] What are some examples of operator overloading?">[13.3] What are some examples of operator overloading?</a></li>
<li><a href="operator-overloading.html#faq-13.4" title="[13.4] But operator overloading makes my class look ugly; isn't it supposed to make my code clearer?">[13.4] But <tt>operator</tt> overloading makes my class look ugly; isn't it supposed to make my code clearer?</a></li>
<li><a href="operator-overloading.html#faq-13.5" title="[13.5] What operators can/cannot be overloaded?">[13.5] What operators can/cannot be overloaded?</a></li>
<li><a href="operator-overloading.html#faq-13.6" title="[13.6] Can I overload operator== so it lets me compare two char[] using a string comparison?">[13.6] Can I overload <nobr><tt>operator==</tt></nobr> so it lets me compare two <nobr><tt>char[]</tt></nobr> using a string comparison?</a></li>
<li><a href="operator-overloading.html#faq-13.7" title="[13.7] Can I create a operator** for &quot;to-the-power-of&quot; operations?">[13.7] Can I create a <nobr><tt>operator**</tt></nobr> for &quot;to-the-power-of&quot; operations?</a></li>
<li><a href="operator-overloading.html#faq-13.8" title="[13.8] Okay, that tells me the operators I can override; which operators should I override?">[13.8] Okay, that tells me the operators I <em>can</em> override; which operators <em>should</em> I override?</a></li>
<li><a href="operator-overloading.html#faq-13.9" title="[13.9] What are some guidelines / &quot;rules of thumb&quot; for overloading operators?">[13.9] What are some guidelines / &quot;rules of thumb&quot; for overloading operators?</a> <span class=Updated>&nbsp;Updated!&nbsp;</span></li>
<li><a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">[13.10] How do I create a subscript <tt>operator</tt> for a <tt>Matrix</tt> class?</a></li>
<li><a href="operator-overloading.html#faq-13.11" title="[13.11] Why shouldn't my Matrix class's interface look like an array-of-array?">[13.11] Why shouldn't my <tt>Matrix</tt> class's interface look like an array-of-array?</a></li>
<li><a href="operator-overloading.html#faq-13.12" title="[13.12] I still don't get it. Why shouldn't my Matrix class's interface look like an array-of-array?">[13.12] I still don't get it. Why shouldn't my <tt>Matrix</tt> class's interface look like an array-of-array?</a> <span class=Updated>&nbsp;Updated!&nbsp;</span></li>
<li><a href="operator-overloading.html#faq-13.13" title="[13.13] Should I design my classes from the outside (interfaces first) or from the inside (data first)?">[13.13] Should I design my classes from the outside (interfaces first) or from the inside (data first)?</a></li>
<li><a href="operator-overloading.html#faq-13.14" title="[13.14] How can I overload the prefix and postfix forms of operators ++ and --?">[13.14] How can I overload the prefix and postfix forms of operators <nobr><tt>++</tt></nobr> and <nobr><tt>--</tt></nobr>?</a></li>
<li><a href="operator-overloading.html#faq-13.15" title="[13.15] Which is more efficient: i++ or ++i?">[13.15] Which is more efficient: <nobr><tt>i++</tt></nobr> or <nobr><tt>++i</tt></nobr>?</a></li>
</ul>
<p><hr>
<p><a name="faq-13.1"></a>
<div class=FaqTitle><h3>[13.1] What's the deal with <tt>operator</tt> overloading?</h3></div>
<p>It allows you to provide an intuitive interface to users of your class, plus
makes it possible for <a href="templates.html#faq-35.1" title="[35.1] What's the idea behind templates?">templates<!--rawtext:[35.1]:rawtext--></a> to work equally
well with classes and built-in/intrinsic types.
<p>Operator overloading allows C/C++ operators to have user-defined meanings on
user-defined types (classes).  Overloaded operators are syntactic sugar for
function calls:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;#if&nbsp;0<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Without&nbsp;<tt>operator</tt>&nbsp;overloading:</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;add(const&nbsp;Fred&amp;&nbsp;x,&nbsp;const&nbsp;Fred&amp;&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;mul(const&nbsp;Fred&amp;&nbsp;x,&nbsp;const&nbsp;Fred&amp;&nbsp;y);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;f(const&nbsp;Fred&amp;&nbsp;a,&nbsp;const&nbsp;Fred&amp;&nbsp;b,&nbsp;const&nbsp;Fred&amp;&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;add(add(mul(a,b),&nbsp;mul(b,c)),&nbsp;mul(c,a));&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Yuk...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;#else<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;With&nbsp;<tt>operator</tt>&nbsp;overloading:</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;operator+&nbsp;(const&nbsp;Fred&amp;&nbsp;x,&nbsp;const&nbsp;Fred&amp;&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;operator*&nbsp;(const&nbsp;Fred&amp;&nbsp;x,&nbsp;const&nbsp;Fred&amp;&nbsp;y);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;f(const&nbsp;Fred&amp;&nbsp;a,&nbsp;const&nbsp;Fred&amp;&nbsp;b,&nbsp;const&nbsp;Fred&amp;&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a*b&nbsp;+&nbsp;b*c&nbsp;+&nbsp;c*a;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;#endif
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.2"></a>
<div class=FaqTitle><h3>[13.2] What are the benefits of operator overloading?</h3></div>
<p>By overloading standard operators on a class, you can exploit the intuition of
the users of that class.  This lets users program in the language of the
problem domain rather than in the language of the machine.
<p>The ultimate goal is to reduce both the learning curve and the defect rate.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.3"></a>
<div class=FaqTitle><h3>[13.3] What are some examples of operator overloading?</h3></div>
<p>Here are a few of the many examples of operator overloading:
<ul>
<li><nobr><tt>myString + yourString</tt></nobr> might concatenate two <nobr><tt>std::string</tt></nobr>
objects</li>
<li><nobr><tt>myDate++</tt></nobr> might increment a <tt>Date</tt> object</li>
<li><nobr><tt>a * b</tt></nobr> might multiply two <tt>Number</tt> objects</li>
<li><nobr><tt>a[i]</tt></nobr> might access an element of an <tt>Array</tt> object</li>
<li><nobr><tt>x = *p</tt></nobr> might dereference a &quot;smart pointer&quot; that &quot;points&quot; to
a disk record &#151; it could seek to the location on disk where <tt>p</tt> &quot;points&quot; and
return the appropriate record into <tt>x</tt></li>
</ul>
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.4"></a>
<div class=FaqTitle><h3>[13.4] But <tt>operator</tt> overloading makes my class look ugly; isn't it supposed to make my code clearer?</h3></div>
<p>Operator overloading <a href="operator-overloading.html#faq-13.2" title="[13.2] What are the benefits of operator overloading?">makes life easier for the
<em>users</em> of a class<!--rawtext:[13.2]:rawtext--></a>, not for the developer of the class!
<p>Consider the following example.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Array&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;int&amp;&nbsp;operator[]&nbsp;(unsigned&nbsp;i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Some&nbsp;people&nbsp;don't&nbsp;like&nbsp;this&nbsp;syntax</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;int&amp;&nbsp;Array::operator[]&nbsp;(unsigned&nbsp;i)&nbsp;&nbsp;</tt><em><small>//&nbsp;Some&nbsp;people&nbsp;don't&nbsp;like&nbsp;this&nbsp;syntax</small></em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Some people don't like the keyword <tt>operator</tt> or the somewhat funny
syntax that goes with it in the body of the class itself.  But the <tt>operator</tt>
overloading syntax isn't supposed to make life easier for the <em>developer</em>
of a class.  It's supposed to make life easier for the <em>users</em> of the
class:
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Array&nbsp;a;<br>
&nbsp;&nbsp;&nbsp;a[3]&nbsp;=&nbsp;4;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;User&nbsp;code&nbsp;should&nbsp;be&nbsp;obvious&nbsp;and&nbsp;easy&nbsp;to&nbsp;understand...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Remember: in a reuse-oriented world, there will usually be many people who use
your class, but there is only one person who builds it (yourself); therefore
you should do things that favor the many rather than the few.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.5"></a>
<div class=FaqTitle><h3>[13.5] What operators can/cannot be overloaded?</h3></div>
<p>Most can be overloaded. The only C operators that can't be are <tt>.</tt> and <nobr><tt>?:</tt></nobr>
(and <tt>sizeof</tt>, which is technically an operator).  C++ adds a few of its own
operators, most of which can be overloaded except <nobr><tt>::</tt></nobr> and <nobr><tt>.*</tt></nobr>.
<p>Here's an example of the subscript <tt>operator</tt> (it returns a reference).  First
with<em>out</em> <tt>operator</tt> overloading:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Array&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;int&amp;&nbsp;elem(unsigned&nbsp;i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;if&nbsp;(i&nbsp;&gt;&nbsp;99)&nbsp;error();&nbsp;return&nbsp;data[i];&nbsp;}<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;int&nbsp;data[100];<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Array&nbsp;a;<br>
&nbsp;&nbsp;&nbsp;a.elem(10)&nbsp;=&nbsp;42;<br>
&nbsp;&nbsp;&nbsp;a.elem(12)&nbsp;+=&nbsp;a.elem(13);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Now the same logic is presented <em>with</em> operator overloading:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Array&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;int&amp;&nbsp;operator[]&nbsp;(unsigned&nbsp;i)&nbsp;{&nbsp;if&nbsp;(i&nbsp;&gt;&nbsp;99)&nbsp;error();&nbsp;return&nbsp;data[i];&nbsp;}<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;int&nbsp;data[100];<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Array&nbsp;a;<br>
&nbsp;&nbsp;&nbsp;a[10]&nbsp;=&nbsp;42;<br>
&nbsp;&nbsp;&nbsp;a[12]&nbsp;+=&nbsp;a[13];<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.6"></a>
<div class=FaqTitle><h3>[13.6] Can I overload <nobr><tt>operator==</tt></nobr> so it lets me compare two <nobr><tt>char[]</tt></nobr> using a string comparison?</h3></div>
<p>No: <a href="intrinsic-types.html#faq-26.10" title="[26.10] Can I define an operator overload that works with built-in / intrinsic / primitive types?">at least one operand of any
overloaded <tt>operator</tt> must be of some user-defined type<!--rawtext:[26.10]:rawtext--></a> (most of the
time that means a <tt>class</tt>).
<p>But even if C++ allowed you to do this, which it doesn't, you wouldn't want to
do it anyway since you really should be using a <a href="exceptions.html#faq-17.5" title="[17.5] How do I change the string-length of an array of char to prevent memory leaks even if/when someone throws an exception?"><nobr><tt>std::string</tt></nobr>-like class rather than an array of <tt>char</tt> in the first place<!--rawtext:[17.5]:rawtext--></a>
since <a href="containers.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">arrays are evil<!--rawtext:[34.1]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.7"></a>
<div class=FaqTitle><h3>[13.7] Can I create a <nobr><tt>operator**</tt></nobr> for &quot;to-the-power-of&quot; operations?</h3></div>
<p>Nope.
<p>The names of, precedence of, associativity of, and arity of operators is fixed
by the language.  There is no <nobr><tt>operator**</tt></nobr> in C++, so you cannot create one for
a <tt>class</tt> type.
<p>If you're in doubt, consider that <nobr><tt>x ** y</tt></nobr> is the same as <nobr><tt>x *
(*y)</tt></nobr> (in other words, the compiler assumes <tt>y</tt> is a pointer).  Besides,
<tt>operator</tt> overloading is just syntactic sugar for function calls.  Although
this particular syntactic sugar can be very sweet, it doesn't add anything
fundamental.  I suggest you overload <nobr><tt>pow(base,exponent)</tt></nobr> (a double
precision version is in <nobr><tt>&lt;cmath&gt;</tt></nobr>).
<p>By the way, <nobr><tt>operator^</tt></nobr> can work for to-the-power-of, except it has the wrong
precedence and associativity.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.8"></a>
<div class=FaqTitle><h3>[13.8] Okay, that tells me the operators I <em>can</em> override; which operators <em>should</em> I override?</h3></div>
<p>Bottom line: don't confuse your users.
<p>Remember the purpose of operator overloading: to reduce the cost and defect
rate in code that uses your class.  If you create operators that confuse your
users (because they're cool, because they make the code faster, because you
need to prove to yourself that you can do it; doesn't really matter why),
you've violated the whole reason for using operator overloading in the first
place.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.9"></a>
<div class=FaqTitle><h3>[13.9] What are some guidelines / &quot;rules of thumb&quot; for overloading operators? <span class=Updated>&nbsp;Updated!&nbsp;</span></h3></div>
<small><em>[Recently clarified point #7 (in 3/06).  <a href="operator-overloading.html#faq-13.12" title="[13.12] I still don't get it. Why shouldn't my Matrix class's interface look like an array-of-array?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[13.12]:rawtext--></a>.]</em></small>
<p>Here are a few guidelines / rules of thumb (but be sure to read
<a href="operator-overloading.html#faq-13.8" title="[13.8] Okay, that tells me the operators I can override; which operators should I override?">the previous FAQ<!--rawtext:[13.8]:rawtext--></a> before reading this
list):
<ol>
<li>Use common sense.  If your overloaded operator makes life easier and safer
for your users, do it; otherwise don't.  This is the most important guideline.
In fact it is, in a very real sense, the only guideline; the rest are just
special cases.</li>
<li>If you define arithmetic operators, maintain the usual arithmetic
identities.  For example, if your class defines <nobr><tt>x + y</tt></nobr> and <nobr><tt>x -
y</tt></nobr>, then <nobr><tt>x + y - y</tt></nobr> ought to return an object that is behaviorally
equivalent to <tt>x</tt>.  The term behaviorally equivalent is defined in the
bullet on <nobr><tt>x == y</tt></nobr> below, but simply put, it means the two objects
should ideally act like they have the same state.  This should be true even if
you decide not to define an <nobr><tt>==</tt></nobr> operator for objects of your class.</li>
<li>You should provide arithmetic operators only when they make logical sense
to users.  Subtracting two dates makes sense, logically returning the duration
between those dates, so you might want to allow <nobr><tt>date1 - date2</tt></nobr> for
objects of your <tt>Date</tt> class (provided you have a reasonable class/type
to represent the duration between two <tt>Date</tt> objects).  However adding
two dates makes no sense: what does it mean to add July 4, 1776 to June 5,
1959?  Similarly it makes no sense to multiply or divide dates, so you should
not define any of those operators.</li>
<li>You should provide mixed-mode arithmetic operators only when they make
logical sense to users.  For example, it makes sense to add a duration (say 35
days) to a date (say July 4, 1776), so you might define <nobr><tt>date +
duration</tt></nobr> to return a <tt>Date</tt>.  Similarly <nobr><tt>date - duration</tt></nobr>
could also return a <tt>Date</tt>.  But <nobr><tt>duration - date</tt></nobr> does not make
sense at the conceptual level (what does it mean to subtract July 4, 1776 from
35 days?) so you should not define that operator.</li>
<li>If you provide constructive operators, they should return their result by
value.  For example, <nobr><tt>x + y</tt></nobr> should return its result by value.  If it
returns by reference, you will probably run into lots of problems figuring out
who owns the referent and when the referent will get destructed.  Doesn't
matter if returning by reference is more efficient; it is <em>probably
wrong</em>.  See the next bullet for more on this point.</li>
<li>If you provide constructive operators, they should not change their
operands.  For example, <nobr><tt>x + y</tt></nobr> should not change <tt>x</tt>.  For some
crazy reason, programmers often define <nobr><tt>x + y</tt></nobr> to be logically the same
as <nobr><tt>x += y</tt></nobr> because the latter is faster.  But remember, your users
<em>expect</em> <nobr><tt>x + y</tt></nobr> to make a copy.  In fact they selected the
<nobr><tt>+</tt></nobr> operator (over, say, the <nobr><tt>+=</tt></nobr> operator) precisely because they
<em>wanted</em> a copy.  If they wanted to modify <tt>x</tt>, they would have
used whatever is equivalent to <nobr><tt>x += y</tt></nobr> instead.  Don't make semantic
decisions for your users; it's <em>their</em> decision, not yours, whether they
want the semantics of <nobr><tt>x + y</tt></nobr> <em>vs.</em> <nobr><tt>x += y</tt></nobr>.  Tell them that one is
faster if you want, but then step back and let them make the final decision
&#151; they know what they're trying to achieve and you do not.</li>
<li>If you provide constructive operators, they should allow promotion of the
left-hand operand (at least in the case where the class has a single-parameter
ctor that is not marked with <a href="ctors.html#faq-10.19" title="[10.19] Why am I getting an error after declaring a Foo object via Foo x(Bar())?">the
<tt>explicit</tt> keyword<!--rawtext:[10.19]:rawtext--></a>).  For example, if your class <tt>Fraction</tt>
supports promotion from <tt>int</tt> to <tt>Fraction</tt> (via the
non-<tt>explicit</tt> ctor <nobr><tt>Fraction::Fraction(int)</tt></nobr>), and if you allow
<nobr><tt>x - y</tt></nobr> for two <tt>Fraction</tt> objects, you should also allow <nobr><tt>42 -
y</tt></nobr>.  In practice that simply means that your <nobr><tt>operator-()</tt></nobr> should not
be a member function of <tt>Fraction</tt>.  Typically you will make it a
<a href="friends.html" title="[14] Friends">friend<!--rawtext:[14]:rawtext--></a>, if for no other reason than to
<a href="inline-functions.html#faq-9.9" title="[9.9] With inline member functions that are defined outside the class, is it best to put the inline keyword next to the declaration within the class body, next to the definition outside the class body, or both?">force it into the <nobr><tt>public:</tt></nobr> part of
the class<!--rawtext:[9.9]:rawtext--></a>, but even if it is not a friend, it should not be a
member.</li>
<li>In general, your operator should change its operand(s) if and only if the
operands get changed when you apply the same operator to intrinsic types.
<nobr><tt>x == y</tt></nobr> and <nobr><tt>x &lt;&lt; y</tt></nobr> should not change either operand; <nobr><tt>x *=
y</tt></nobr> and <nobr><tt>x &lt;&lt;= y</tt></nobr> should (but only the left-hand operand).</li>
<li>If you define <nobr><tt>x++</tt></nobr> and <nobr><tt>++x</tt></nobr>, maintain the usual identities.
For example, <nobr><tt>x++</tt></nobr> and <nobr><tt>++x</tt></nobr> should have should have the same
observable effect on <tt>x</tt>, and should differ only in what they return.
<nobr><tt>++x</tt></nobr> should return <tt>x</tt> by reference; <nobr><tt>x++</tt></nobr> should either
return a copy (by value) of the original state of <tt>x</tt> or should have a
<tt>void</tt> return-type.  You're usually better off returning a copy of the
original state of <tt>x</tt> by value, especially if your class will be used in
generic algorithms.  The easy way to do that is to implement <nobr><tt>x++</tt></nobr> using
three lines: make a local copy of <nobr><tt>*this</tt></nobr>, call <nobr><tt>++x</tt></nobr> (i.e.,
<nobr><tt>this-&gt;operator++()</tt></nobr>), then return the local copy.  Similar comments for
<nobr><tt>x--</tt></nobr> and <nobr><tt>--x</tt></nobr>.</li>
<li>If you define <nobr><tt>++x</tt></nobr> and <nobr><tt>x += 1</tt></nobr>, maintain the usual
identities.  For example, these expressions should have the same observable
behavior, including the same result.  Among other things, that means your
<nobr><tt>+=</tt></nobr> operator should return <tt>x</tt> by reference.  Similar comments
for <nobr><tt>--x</tt></nobr> and <nobr><tt>x -= 1</tt></nobr>.</li>
<li>If you define <nobr><tt>*p</tt></nobr> and <nobr><tt>p[0]</tt></nobr> for pointer-like objects,
maintain the usual identities.  For example, these two expressions should have
the same result and neither should change <tt>p</tt>.</li>
<li>If you define <nobr><tt>p[i]</tt></nobr> and <nobr><tt>*(p+i)</tt></nobr> for pointer-like objects,
maintain the usual identities.  For example, these two expressions should have
the same result and neither should change <tt>p</tt>.  Similar comments for
<nobr><tt>p[-i]</tt></nobr> and <nobr><tt>*(p-i)</tt></nobr>.</li>
<li>Subscript operators generally come in pairs; see on
<a href="const-correctness.html#faq-18.12" title="[18.12] What's the deal with &quot;const-overloading&quot;?"><tt>const</tt>-overloading<!--rawtext:[18.12]:rawtext--></a>.</li>
<li>If you define <nobr><tt>x == y</tt></nobr>, then <nobr><tt>x == y</tt></nobr> should be true if and
only if the two objects are behaviorally equivalent.  In this bullet, the term
&quot;behaviorally equivalent&quot; means the observable behavior of any operation or
sequence of operations applied to <tt>x</tt> will be the same as when applied
to <tt>y</tt>.  The term &quot;operation&quot; means methods, friends, operators, or just
about anything else you can do with these objects (except, of course, the
address-of operator).  You won't always be able to achieve that goal, but you
ought to get close, and you ought to document any variances (other than the
address-of operator).</li>
<li>If you define <nobr><tt>x == y</tt></nobr> and <nobr><tt>x = y</tt></nobr>, maintain the usual
identities.  For example, after an assignment, the two objects should be
equal.  Even if you don't define <nobr><tt>x == y</tt></nobr>, the two objects should be
behaviorally equivalent (see above for the meaning of that phrase) after an
assignment.</li>
<li>If you define <nobr><tt>x == y</tt></nobr> and <nobr><tt>x != y</tt></nobr>, you should maintain the
usual identities.  For example, these expressions should return something
convertible to <tt>bool</tt>, neither should change its operands, and <nobr><tt>x ==
y</tt></nobr> should have the same result as <nobr><tt>!(x != y)</tt></nobr>, and vice versa.</li>
<li>If you define inequality operators like <nobr><tt>x &lt;= y</tt></nobr> and <nobr><tt>x &lt; y</tt></nobr>,
you should maintain the usual identities.  For example, if <nobr><tt>x &lt; y</tt></nobr> and
<nobr><tt>y &lt; z</tt></nobr> are both true, then <nobr><tt>x &lt; z</tt></nobr> should also be true, etc.
Similar comments for <nobr><tt>x &gt;= y</tt></nobr> and <nobr><tt>x &gt; y</tt></nobr>.</li>
<li>If you define inequality operators like <nobr><tt>x &lt; y</tt></nobr> and <nobr><tt>x &gt;= y</tt></nobr>,
you should maintain the usual identities.  For example, <nobr><tt>x &lt; y</tt></nobr> should
have the result as <nobr><tt>!(x &gt;= y)</tt></nobr>.  You can't always do that, but you
should get close and you should document any variances.  Similar comments for
<nobr><tt>x &gt; y</tt></nobr> and <nobr><tt>!(x &lt;= y)</tt></nobr>, etc.</li>
<li>Avoid overloading short-circuiting operators: <nobr><tt>x || y</tt></nobr> or <nobr><tt>x &amp;&amp;
y</tt></nobr>.  The overloaded versions of these do not short-circuit &#151; they
evaluate both operands even if the left-hand operand &quot;determines&quot; the outcome,
so that confuses users.</li>
<li>Avoid overloading the comma operator: <nobr><tt>x, y</tt></nobr>.  The overloaded comma
operator does not have the same ordering properties that it has when it is not
overloaded, and that confuses users.</li>
<li>Don't overload an operator that is non-intuitive to your users.  This is
called the Doctrine of Least Surprise.  For example, altough C++ uses
<nobr><tt>std::cout &lt;&lt; x</tt></nobr> for printing, and although printing is techincally
called inserting, and although inserting sort of sounds like what happens when
you push an element onto a stack, don't overload <nobr><tt>myStack &lt;&lt; x</tt></nobr> to push
an element onto a stack.  It might make sense when you're really tired or
otherwise mentally impaired, and a few of your friends might think it's
&quot;kewl,&quot; but just say No.</li>
<li>Use common sense.  If you don't see &quot;your&quot; operator listed here, you can
figure it out.  Just remember the ultimate goals of operator overloading: to
make life easier for your users, in particular to make their code cheaper to
write and more obvious.</li>
</ol>
<p>Caveat: the list is not exhaustive.  That means there are other entries that
you might consider &quot;missing.&quot; I know.
<p>Caveat: the list contains guidelines, not hard and fast rules.  That means
almost all of the entries have exceptions, and most of those exceptions are
not explicitly stated.  I know.
<p>Caveat: please don't email me about the additions or exceptions.  I've already
spent way too much time on this particular answer.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.10"></a>
<div class=FaqTitle><h3>[13.10] How do I create a subscript <tt>operator</tt> for a <tt>Matrix</tt> class?</h3></div>
<p>Use <nobr><tt>operator()</tt></nobr> rather than <nobr><tt>operator[]</tt></nobr>.
<p>When you have multiple subscripts, the cleanest way to do it is with
<nobr><tt>operator()</tt></nobr> rather than with <nobr><tt>operator[]</tt></nobr>.  The reason is that
<nobr><tt>operator[]</tt></nobr> always takes exactly one parameter, but <nobr><tt>operator()</tt></nobr>
can take any number of parameters (in the case of a rectangular matrix, two
parameters are needed).
<p>For example:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Matrix&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Matrix(unsigned&nbsp;rows,&nbsp;unsigned&nbsp;cols);<br>
&nbsp;&nbsp;&nbsp;double&amp;&nbsp;operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;<a href="const-correctness.html#faq-18.12" title="[18.12] What's the deal with &quot;const-overloading&quot;?">subscript&nbsp;operators&nbsp;often&nbsp;come&nbsp;in&nbsp;pairs<!--rawtext:[18.12]:rawtext--></a></small></em><tt><br>
&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)&nbsp;const;&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;<a href="const-correctness.html#faq-18.12" title="[18.12] What's the deal with &quot;const-overloading&quot;?">subscript&nbsp;operators&nbsp;often&nbsp;come&nbsp;in&nbsp;pairs<!--rawtext:[18.12]:rawtext--></a></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;~Matrix();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Destructor</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Matrix(const&nbsp;Matrix&amp;&nbsp;m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Copy&nbsp;constructor</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Matrix&amp;&nbsp;operator=&nbsp;(const&nbsp;Matrix&amp;&nbsp;m);&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Assignment&nbsp;operator</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;unsigned&nbsp;rows_,&nbsp;cols_;<br>
&nbsp;&nbsp;&nbsp;double*&nbsp;data_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;Matrix::Matrix(unsigned&nbsp;rows,&nbsp;unsigned&nbsp;cols)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;rows_&nbsp;(rows)<br>
&nbsp;&nbsp;&nbsp;,&nbsp;cols_&nbsp;(cols)<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>//data_&nbsp;&lt;--initialized&nbsp;below&nbsp;(after&nbsp;the&nbsp;'if/throw'&nbsp;statement)</small></em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(rows&nbsp;==&nbsp;0&nbsp;||&nbsp;cols&nbsp;==&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;BadIndex(&quot;Matrix&nbsp;constructor&nbsp;has&nbsp;0&nbsp;size&quot;);<br>
&nbsp;&nbsp;&nbsp;data_&nbsp;=&nbsp;new&nbsp;double[rows&nbsp;*&nbsp;cols];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;Matrix::~Matrix()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;delete[]&nbsp;data_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;double&amp;&nbsp;Matrix::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;rows_&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;cols_)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;BadIndex(&quot;Matrix&nbsp;subscript&nbsp;out&nbsp;of&nbsp;bounds&quot;);<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[cols_*row&nbsp;+&nbsp;col];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;double&nbsp;Matrix::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;rows_&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;cols_)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;BadIndex(&quot;const&nbsp;Matrix&nbsp;subscript&nbsp;out&nbsp;of&nbsp;bounds&quot;);<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[cols_*row&nbsp;+&nbsp;col];<br>
&nbsp;}
</tt>
</div>
<p>Then you can access an element of <tt>Matrix</tt> <tt>m</tt> using <nobr><tt>m(i,j)</tt></nobr>
rather than <nobr><tt>m[i][j]</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Matrix&nbsp;m(10,10);<br>
&nbsp;&nbsp;&nbsp;m(5,8)&nbsp;=&nbsp;106.15;<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;m(5,8);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p><a href="operator-overloading.html#faq-13.11" title="[13.11] Why shouldn't my Matrix class's interface look like an array-of-array?">See the next FAQ<!--rawtext:[13.11]:rawtext--></a> for more detail on the
reasons to use <nobr><tt>m(i,j)</tt></nobr> <em>vs.</em> <nobr><tt>m[i][j]</tt></nobr>.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.11"></a>
<div class=FaqTitle><h3>[13.11] Why shouldn't my <tt>Matrix</tt> class's interface look like an array-of-array?</h3></div>
<p>Here's what this FAQ is really all about: Some people build a Matrix class that
has an <nobr><tt>operator[]</tt></nobr> that returns a reference to an <tt>Array</tt> object (or perhaps to a <a href="containers.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">raw array<!--rawtext:[34.1]:rawtext--></a>, shudder),
and that <tt>Array</tt> object has an <nobr><tt>operator[]</tt></nobr> that returns an element
of the Matrix (e.g., a reference to a <tt>double</tt>).  Thus they access
elements of the matrix using syntax like <nobr><tt>m[i][j]</tt></nobr> rather than
<a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">syntax like <nobr><tt>m(i,j)</tt></nobr><!--rawtext:[13.10]:rawtext--></a>.
<p>The array-of-array solution obviously works, but it is less flexible than
<a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">the <nobr><tt>operator()</tt></nobr> approach<!--rawtext:[13.10]:rawtext--></a>.  Specifically,
there are easy performance tuning tricks that can be done with the
<nobr><tt>operator()</tt></nobr> approach that are more difficult in the <nobr><tt>[][]</tt></nobr>
approach, and therefore the <nobr><tt>[][]</tt></nobr> approach is more likely to lead to bad
performance, at least in some cases.
<p>For example, the easiest way to implement the <nobr><tt>[][]</tt></nobr> approach is to use a
physical layout of the matrix as a dense matrix that is stored in row-major
form (or is it column-major; I can't ever remember).  In contrast,
<a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">the <nobr><tt>operator()</tt></nobr> approach<!--rawtext:[13.10]:rawtext--></a> totally hides
the physical layout of the matrix, and that can lead to better performance in
some cases.
<p>Put it this way: the <nobr><tt>operator()</tt></nobr> approach is never worse than, and
sometimes better than, the <nobr><tt>[][]</tt></nobr> approach.
<ul>
<li>The <nobr><tt>operator()</tt></nobr> approach is never worse because it is easy to
implement the dense, row-major physical layout using the <nobr><tt>operator()</tt></nobr>
approach, so when that configuration happens to be the optimal layout from a
performance standpoint, the <nobr><tt>operator()</tt></nobr> approach is just as easy as the
<nobr><tt>[][]</tt></nobr> approach (perhaps the <nobr><tt>operator()</tt></nobr> approach is a tiny bit
easier, but I won't quibble over minor nits).</li>
<li>The <nobr><tt>operator()</tt></nobr> approach is sometimes better because whenever the
optimal layout for a given application happens to be something other than
dense, row-major, the implementation is often significantly easier using the
<nobr><tt>operator()</tt></nobr> approach compared to the <nobr><tt>[][]</tt></nobr> approach.</li>
</ul>
<p>As an example of when a physical layout makes a significant difference, a
recent project happened to access the matrix elements in columns (that is, the
algorithm accesses all the elements in one column, then the elements in
another, etc.), and if the physical layout is row-major, the accesses can
&quot;stride the cache&quot;.  For example, if the rows happen to be almost as big as the
processor's cache size, the machine can end up with a &quot;cache miss&quot; for almost
every element access.  In this particular project, we got a 20% improvement in
performance by changing the mapping from the logical layout (row,column) to the
physical layout (column,row).
<p>Of course there are many examples of this sort of thing from numerical methods,
and sparse matrices are a whole other dimension on this issue.  Since it is, in
general, easier to implement a sparse matrix or swap row/column ordering using
the <nobr><tt>operator()</tt></nobr> approach, the <nobr><tt>operator()</tt></nobr> approach loses nothing
and may gain something &#151; it has no down-side and a potential up-side.
<p>Use <a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">the <nobr><tt>operator()</tt></nobr> approach<!--rawtext:[13.10]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.12"></a>
<div class=FaqTitle><h3>[13.12] I still don't get it. Why shouldn't my <tt>Matrix</tt> class's interface look like an array-of-array? <span class=Updated>&nbsp;Updated!&nbsp;</span></h3></div>
<small><em>[Recently fixed call to <nobr><tt>Matrix::Row</tt></nobr> ctor thanks to <a href="mailto:(NOSPAM)jrp(AT)johnpavel(DOT)com" title="(NOSPAM)jrp(AT)johnpavel(DOT)com">John Pavel</a> (in 3/06).  <a href="exceptions.html#faq-17.8" title="[17.8] But MFC seems to encourage the use of catch-by-pointer; should I do the same?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[17.8]:rawtext--></a>.]</em></small>
<p>The same reasons you encapsulate your data structures, and the same reason you
check parameters to make sure they are valid.
<p>A few people use <nobr><tt>[][]</tt></nobr> despite <a href="operator-overloading.html#faq-13.11" title="[13.11] Why shouldn't my Matrix class's interface look like an array-of-array?">its
limitations<!--rawtext:[13.11]:rawtext--></a>, arguing that <nobr><tt>[][]</tt></nobr> is better because it is faster or
because it uses C-syntax.  The problem with the &quot;it's faster&quot; argument is that
it's not &#151; at least not on the latest version of two of the world's best
known C++ compilers.  The problem with the &quot;uses C-syntax&quot; argument is that
C++ is not C.  Plus, oh yea, the C-syntax makes it harder to change the data
structure and harder to check parameter values.
<p>The point of the previous two FAQs is that <nobr><tt>m(i,j)</tt></nobr> gives you a clean,
simple way to check all the parameters and to hide (and therefore, if you want
to, change) the internal data structure.  The world already has way too many
exposed data structures and way too many out-of-bounds parameters, and those
cost way too much money and cause way too many delays and way too many
defects.
<p>Now everybody knows that <em>you</em> are different.  You are clairvoiant with
perfect knowledge of the future, and you <em>know</em> that no one will ever
find any benefit from changing your matrix's internal data structure.  Plus
you are a <em>good</em> programmer, unlike those slobs out there that
occasionally pass wrong parameters, so you don't need to worry about pesky
little things like parameter checking.  But even though you don't need to
worry about maintenance costs (no one ever needs to change your code), there
might be one or two other programmers who aren't quite perfect yet.  For them,
maintenance costs are high, defects are real, and requirements change.
Believe it or not, every once in a while need to (better sit down) change
their code.
<p>Okay, my thongue wath in my theek.  But there was a point.  The point was that
encapsulation and parameter-checking are not crutches for the weak.  It's
smart to use techniques that make encapsulation and/or parameter checking
easy.  The <nobr><tt>m(i,j)</tt></nobr> syntax is one of those techniques.
<p>Having said all that, if you find yourself maintaining a billion-line app
where the original team used <nobr><tt>m[i][j]</tt></nobr>, or even if you are writing a
brand new app and you just plain <em>want</em> to use <nobr><tt>m[i][j]</tt></nobr>, you can
still encapsulate the data structure and/or check all your parameters.  It's
not even that hard.  However it does require a level of sophistication that,
like it or not, the average C++ programmers fears.  Fortunately you are not
average, so read on.
<p>If you merely want to check parameters, just make sure the outer
<nobr><tt>operator[]</tt></nobr> returns an object rather than a <a href="containers.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">raw
array<!--rawtext:[34.1]:rawtext--></a>, then that object's <nobr><tt>operator[]</tt></nobr> can check its parameter in
the usual way.  Beware that this can slow down your program.  In particular,
if these inner array-like objects end up allocating their own block of memory
for their row of the matrix, the performance overhead for creating /
destroying your matrix objects can grow dramatically.  The <em>theoretical</em>
cost is still O(rows*cols), but in practice, the overhead of the memory
allocator (<tt>new</tt> or <tt>malloc</tt>) can be <em>much</em> larger than
anything else, and that overhead can swamp the other costs.  For instance, on
two of the world's best known C++ compilers, the separate-allocation-per-row
technique was 10x slower than the <a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">than
one-allocation-for-the-entire-matrix technique<!--rawtext:[13.10]:rawtext--></a>.  10% is one thing, 10x
is another.
<p>If you want to check the parameters without the above overhead and/or if you
want to encapsulate (and possibly change) the matrix's internal data
structure, follow these steps:
<ol>
<li>Add <nobr><tt>operator()(unsigned row, unsigned col)</tt></nobr> to the <tt>Matrix</tt>
class.</li>
<li>Create nested class <nobr><tt>Matrix::Row</tt></nobr>.  It should have a ctor with
parameters <nobr><tt>(Matrix&amp; matrix, unsigned row)</tt></nobr>, and it should store those
two values in its <tt>this</tt> object.</li>
<li>Change <nobr><tt>Matrix::operator[](unsigned row)</tt></nobr> so it returns an object of
class <nobr><tt>Matrix::Row</tt></nobr>, e.g., <nobr><tt>{ return Row(*this,row); }</tt></nobr>.</li>
<li>Class <nobr><tt>Matrix::Row</tt></nobr> then defines its own <nobr><tt>operator[](unsigned
col)</tt></nobr> which turns around and calls, you guessed it,
<nobr><tt>Matrix::operator()(unsigned row, unsigned col)</tt></nobr>.  If the
<nobr><tt>Matrix::Row</tt></nobr> data members are called <nobr><tt>Matrix&amp; matrix_</tt></nobr> and
<nobr><tt>unsigned row_</tt></nobr>, the code for <nobr><tt>Matrix::Row::operator[](unsigned
col)</tt></nobr> will be <nobr><tt>{ return matrix_(row_, col); }</tt></nobr></li>
</ol>
<p>Next you will <a href="const-correctness.html#faq-18.12" title="[18.12] What's the deal with &quot;const-overloading&quot;?">enable <tt>const</tt> overloading<!--rawtext:[18.12]:rawtext--></a>
by repeating the above steps.  You will create the <tt>const</tt> version of
the various methods, and you will create a new nested class, probably called
<nobr><tt>Matrix::ConstRow</tt></nobr>.  Don't forget to use <nobr><tt>const Matrix&amp;</tt></nobr> instead
of <nobr><tt>Matrix&amp;</tt></nobr>.
<p>Final step: <a href="operator-overloading.html#faq-13.11" title="[13.11] Why shouldn't my Matrix class's interface look like an array-of-array?">find the joker who failed to read the
previous FAQ<!--rawtext:[13.11]:rawtext--></a> and thonk him in the noggin.
<p>If you have a decent compiler and if you judiciously use
<a href="inline-functions.html#faq-9.1" title="[9.1] What's the deal with inline functions?">inlining<!--rawtext:[9.1]:rawtext--></a>, the compiler should optimize away
the temporary objects.  In other words, the above will hopefully not be slower
than what it would have been if you had <a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">directly
called <nobr><tt>Matrix::operator()(unsigned row, unsigned col)</tt></nobr><!--rawtext:[13.10]:rawtext--></a> in the
first place.  Of course you could have made your life simpler and avoided most
of the above work by <a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">directly calling
<nobr><tt>Matrix::operator()(unsigned row, unsigned col)</tt></nobr><!--rawtext:[13.10]:rawtext--></a> in the first
place.  So you might as well <a href="operator-overloading.html#faq-13.10" title="[13.10] How do I create a subscript operator for a Matrix class?">directly call
<nobr><tt>Matrix::operator()(unsigned row, unsigned col)</tt></nobr><!--rawtext:[13.10]:rawtext--></a> in the first
place.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.13"></a>
<div class=FaqTitle><h3>[13.13] Should I design my classes from the outside (interfaces first) or from the inside (data first)?</h3></div>
<p>From the outside!
<p>A good interface provides a <a href="classes-and-objects.html#faq-7.3" title="[7.3] When is an interface &quot;good&quot;?"><em>simplified</em> view that
is expressed in the <em>vocabulary of a user</em><!--rawtext:[7.3]:rawtext--></a>.  In the case of OO
software, the interface is normally the set of public methods of either a
single class or a <a href="friends.html#faq-14.2" title="[14.2] Do friends violate encapsulation?">tight group of classes<!--rawtext:[14.2]:rawtext--></a>.
<p>First think about what the object logically represents, not how you intend to
physically build it.  For example, suppose you have a <tt>Stack</tt> class that will
be built by containing a <tt>LinkedList</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Stack&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;LinkedList&nbsp;list_;<br>
&nbsp;};
</tt>
</div>
<p>Should the Stack have a <nobr><tt>get()</tt></nobr> method that returns the <tt>LinkedList</tt>?  Or a
<nobr><tt>set()</tt></nobr> method that takes a <tt>LinkedList</tt>?  Or a constructor that takes a
<tt>LinkedList</tt>?  Obviously the answer is <em>No,</em> since you should design your
interfaces from the outside-in.  I.e., users of <tt>Stack</tt> objects don't care
about <tt>LinkedList</tt>s; they care about pushing and popping.
<p>Now for another example that is a bit more subtle.  Suppose class <tt>LinkedList</tt>
is built using a linked list of <tt>Node</tt> objects, where each <tt>Node</tt> object has a
pointer to the next <tt>Node</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Node&nbsp;{&nbsp;</tt><em><small>/*...*/</small></em><tt>&nbsp;};<br>
&nbsp;<br>
&nbsp;class&nbsp;LinkedList&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;Node*&nbsp;first_;<br>
&nbsp;};
</tt>
</div>
<p>Should the <tt>LinkedList</tt> class have a <nobr><tt>get()</tt></nobr> method that will let users access
the first <tt>Node</tt>?  Should the <tt>Node</tt> object have a <nobr><tt>get()</tt></nobr> method that will let
users follow that <tt>Node</tt> to the next <tt>Node</tt> in the chain?  In other words, what
should a <tt>LinkedList</tt> look like from the outside?  Is a <tt>LinkedList</tt> really a
chain of <tt>Node</tt> objects?  Or is that just an implementation detail?  And if it
is just an implementation detail, how will the <tt>LinkedList</tt> let users access
each of the elements in the <tt>LinkedList</tt> one at a time?
<p>The key insight is the realization that a <tt>LinkedList</tt> is <em>not</em> a chain
of <tt>Node</tt>s.  That may be <em>how</em> it is built, but that is not <em>what</em>
it is.  What it is is a sequence of elements.  Therefore the <tt>LinkedList</tt>
abstraction should provide a <tt>LinkedListIterator</tt> <tt>class</tt> as well, and that
<tt>LinkedListIterator</tt> might have an <nobr><tt>operator++</tt></nobr> to go to the next
element, and it might have a <nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> pair to access its <em>value</em>
stored in the <tt>Node</tt> (the value in the <tt>Node</tt> element is solely the
responsibility of the <tt>LinkedList</tt> user, which is why there is a
<nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> pair that allows the user to freely manipulate that value).
<p>Starting from the user's perspective, we might want our <tt>LinkedList</tt> <tt>class</tt> to
support operations that look similar to accessing an array using pointer
arithmetic:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;userCode(LinkedList&amp;&nbsp;a)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;for&nbsp;(LinkedListIterator&nbsp;p&nbsp;=&nbsp;a.begin();&nbsp;p&nbsp;!=&nbsp;a.end();&nbsp;++p)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*p&nbsp;&lt;&lt;&nbsp;'\n';<br>
&nbsp;}
</tt>
</div>
<p>To implement this interface, <tt>LinkedList</tt> will need a <nobr><tt>begin()</tt></nobr> method and an
<nobr><tt>end()</tt></nobr> method.  These return a <tt>LinkedListIterator</tt> object.  The
<tt>LinkedListIterator</tt> will need a method to go forward, <nobr><tt>++p</tt></nobr>; a method to
access the current element, <nobr><tt>*p</tt></nobr>; and a comparison operator, <nobr><tt>p !=
a.end()</tt></nobr>.
<p>The code follows.  The important thing to notice is that <tt>LinkedList</tt> does
<em>not</em> have any methods that let users access <tt>Node</tt>s.  <tt>Node</tt>s are an
implementation technique that is <em>completely</em> buried.  This makes the
<tt>LinkedList</tt> class safer (no chance a user will mess up the invariants and
linkages between the various nodes), easier to use (users don't need to expend
extra effort keeping the node-count equal to the actual number of nodes, or
any other infrastructure stuff), and more flexible (by changing a single
<tt>typedef</tt>, users could change their code from using <tt>LinkedList</tt> to some
other list-like class and the bulk of their code would compile cleanly and
hopefully with improved performance characteristics).
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;cassert&gt;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Poor&nbsp;man's&nbsp;exception&nbsp;handling</small></em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;LinkedListIterator;<br>
&nbsp;class&nbsp;LinkedList;<br>
&nbsp;<br>
&nbsp;class&nbsp;Node&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;No&nbsp;<tt>public</tt>&nbsp;members;&nbsp;this&nbsp;is&nbsp;a&nbsp;&quot;<tt>private</tt>&nbsp;<tt>class</tt>&quot;</small></em><tt><br>
&nbsp;&nbsp;&nbsp;friend&nbsp;class&nbsp;LinkedListIterator;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;<a href="friends.html" title="[14] Friends">A&nbsp;friend&nbsp;class<!--rawtext:[14]:rawtext--></a></small></em><tt><br>
&nbsp;&nbsp;&nbsp;friend&nbsp;class&nbsp;LinkedList;<br>
&nbsp;&nbsp;&nbsp;Node*&nbsp;next_;<br>
&nbsp;&nbsp;&nbsp;int&nbsp;elem_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;class&nbsp;LinkedListIterator&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;bool&nbsp;operator==&nbsp;(LinkedListIterator&nbsp;i)&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;bool&nbsp;operator!=&nbsp;(LinkedListIterator&nbsp;i)&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;void&nbsp;operator++&nbsp;();&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Go&nbsp;to&nbsp;the&nbsp;next&nbsp;element</small></em><tt><br>
&nbsp;&nbsp;&nbsp;int&amp;&nbsp;operator*&nbsp;&nbsp;();&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Access&nbsp;the&nbsp;current&nbsp;element</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;LinkedListIterator(Node*&nbsp;p);<br>
&nbsp;&nbsp;&nbsp;Node*&nbsp;p_;<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;class&nbsp;LinkedList;&nbsp;&nbsp;</tt><em><small>//&nbsp;so&nbsp;LinkedList&nbsp;can&nbsp;construct&nbsp;a&nbsp;LinkedListIterator</small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;class&nbsp;LinkedList&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;void&nbsp;append(int&nbsp;elem);&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Adds&nbsp;<tt>elem</tt>&nbsp;after&nbsp;the&nbsp;end</small></em><tt><br>
&nbsp;&nbsp;&nbsp;void&nbsp;prepend(int&nbsp;elem);&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;Adds&nbsp;<tt>elem</tt>&nbsp;before&nbsp;the&nbsp;beginning</small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;LinkedListIterator&nbsp;begin();<br>
&nbsp;&nbsp;&nbsp;LinkedListIterator&nbsp;end();<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;Node*&nbsp;first_;<br>
&nbsp;};
</tt>
</div>
<p>Here are the methods that are obviously inlinable (probably in the same header
file):
<p><div class=CodeBlock>
<tt>
&nbsp;inline&nbsp;bool&nbsp;LinkedListIterator::operator==&nbsp;(LinkedListIterator&nbsp;i)&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return&nbsp;p_&nbsp;==&nbsp;i.p_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;bool&nbsp;LinkedListIterator::operator!=&nbsp;(LinkedListIterator&nbsp;i)&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return&nbsp;p_&nbsp;!=&nbsp;i.p_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;void&nbsp;LinkedListIterator::operator++()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;assert(p_&nbsp;!=&nbsp;NULL);&nbsp;&nbsp;</tt><em><small>//&nbsp;or&nbsp;<nobr><tt>if&nbsp;(p_==NULL)&nbsp;throw&nbsp;</tt>...<tt></tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;p_&nbsp;=&nbsp;p_-&gt;next_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;int&amp;&nbsp;LinkedListIterator::operator*()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;assert(p_&nbsp;!=&nbsp;NULL);&nbsp;&nbsp;</tt><em><small>//&nbsp;or&nbsp;<nobr><tt>if&nbsp;(p_==NULL)&nbsp;throw&nbsp;</tt>...<tt></tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;p_-&gt;elem_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;LinkedListIterator::LinkedListIterator(Node*&nbsp;p)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;p_(p)<br>
&nbsp;{&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;LinkedListIterator&nbsp;LinkedList::begin()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return&nbsp;first_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;LinkedListIterator&nbsp;LinkedList::end()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br>
&nbsp;}
</tt>
</div>
<p>Conclusion: The linked list had two different kinds of data.  The values of the
elements stored in the linked list are the responsibility of the user of the
linked list (and <em>only</em> the user; the linked list itself makes no attempt
to prohibit users from changing the third element to 5), and the linked list's
infrastructure data (<tt>next</tt> pointers, etc.), whose values are the
responsibility of the linked list (and <em>only</em> the linked list; e.g., the
linked list does not let users change (or even look at!) the various
<tt>next</tt> pointers).
<p>Thus the only <nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> methods were to get and set the <em>elements</em>
of the linked list, but not the infrastructure of the linked list.  Since the
linked list hides the infrastructure pointers/etc., it is able to make very
strong promises regarding that infrastructure (e.g., if it were a doubly linked
list, it might guarantee that every forward pointer was matched by a backwards
pointer from the next <tt>Node</tt>).
<p>So, we see here an example of where the values of <em>some</em> of a class's
data is the responsibility of <em>users</em> (in which case the class needs to
have <nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> methods for that data) but the data that the class wants
to control does not necessarily have <nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> methods.
<p>Note: the purpose of this example is <em>not</em> to show you how to write a
linked-list class.  In fact you should <em>not</em> &quot;roll your own&quot; linked-list
class since you should use one of the &quot;container classes&quot; provided with your
compiler.  Ideally you'll use one of the <a href="class-libraries.html#faq-37.1" title="[37.1] What is the &quot;STL&quot;?">standard container
classes<!--rawtext:[37.1]:rawtext--></a> such as the <nobr><tt>std::list&lt;T&gt;</tt></nobr> template.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.14"></a>
<div class=FaqTitle><h3>[13.14] How can I overload the prefix and postfix forms of operators <nobr><tt>++</tt></nobr> and <nobr><tt>--</tt></nobr>?</h3></div>
<p>Via a dummy parameter.
<p>Since the prefix and postfix <nobr><tt>++</tt></nobr> operators can have two definitions,
the C++ language gives us two different signatures.  Both are called
<nobr><tt>operator++()</tt></nobr>, but the prefix version takes no parameters and the
postfix version takes a dummy <tt>int</tt>.  (Although this discussion revolves
around the <nobr><tt>++</tt></nobr> operator, the <nobr><tt>--</tt></nobr> operator is completely
symmetric, and all the rules and guidelines that apply to one also apply to
the other.)
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Number&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Number&amp;&nbsp;operator++&nbsp;();&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;prefix&nbsp;++</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Number&nbsp;&nbsp;operator++&nbsp;(int);&nbsp;</tt><em><small>//&nbsp;postfix&nbsp;++</small></em><tt><br>
&nbsp;};
</tt>
</div>
<p>Note the different return types: the prefix version returns by reference, the
postfix version by value.  If that's not immediately obvious to you, it should
be after you see the definitions (and after you remember that <nobr><tt>y = x++</tt></nobr>
and <nobr><tt>y = ++x</tt></nobr> set <tt>y</tt> to different things).
<p><div class=CodeBlock>
<tt>
&nbsp;Number&amp;&nbsp;Number::operator++&nbsp;()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Number&nbsp;Number::operator++&nbsp;(int)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Number&nbsp;ans&nbsp;=&nbsp;*this;<br>
&nbsp;&nbsp;&nbsp;++(*this);&nbsp;&nbsp;</tt><em><small>//&nbsp;or&nbsp;just&nbsp;call&nbsp;<nobr><tt>operator++()</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}
</tt>
</div>
<p>The other option for the postfix version is to return nothing:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Number&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Number&amp;&nbsp;operator++&nbsp;();<br>
&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;operator++&nbsp;(int);<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;Number&amp;&nbsp;Number::operator++&nbsp;()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;Number::operator++&nbsp;(int)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;++(*this);&nbsp;&nbsp;</tt><em><small>//&nbsp;or&nbsp;just&nbsp;call&nbsp;<nobr><tt>operator++()</tt></nobr></small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>However you must *not* make the postfix version return the 'this' object by
reference; you have been warned.
<p>Here's how you use these operators:
<p><div class=CodeBlock>
<tt>
&nbsp;Number&nbsp;x&nbsp;=&nbsp;</tt><em><small>/*&nbsp;...&nbsp;*/</small></em><tt>;<br>
&nbsp;++x;&nbsp;&nbsp;</tt><em><small>//&nbsp;calls&nbsp;<nobr><tt>Number::operator++()</tt></nobr>,&nbsp;i.e.,&nbsp;calls&nbsp;<nobr><tt>x.operator++()</tt></nobr></small></em><tt><br>
&nbsp;x++;&nbsp;&nbsp;</tt><em><small>//&nbsp;calls&nbsp;<nobr><tt>Number::operator++(int)</tt></nobr>,&nbsp;i.e.,&nbsp;calls&nbsp;<nobr><tt>x.operator++(0)</tt></nobr></small></em><tt>
</tt>
</div>
<p>Assuming the return types are not 'void', you can use them in larger
expressions:
<p><div class=CodeBlock>
<tt>
&nbsp;Number&nbsp;x&nbsp;=&nbsp;</tt><em><small>/*&nbsp;...&nbsp;*/</small></em><tt>;<br>
&nbsp;Number&nbsp;y&nbsp;=&nbsp;++x;&nbsp;&nbsp;</tt><em><small>//&nbsp;<tt>y</tt>&nbsp;will&nbsp;be&nbsp;the&nbsp;new&nbsp;value&nbsp;of&nbsp;<tt>x</tt></small></em><tt><br>
&nbsp;Number&nbsp;z&nbsp;=&nbsp;x++;&nbsp;&nbsp;</tt><em><small>//&nbsp;<tt>z</tt>&nbsp;will&nbsp;be&nbsp;the&nbsp;old&nbsp;value&nbsp;of&nbsp;<tt>x</tt></small></em><tt>
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.15"></a>
<div class=FaqTitle><h3>[13.15] Which is more efficient: <nobr><tt>i++</tt></nobr> or <nobr><tt>++i</tt></nobr>?</h3></div>
<p><nobr><tt>++i</tt></nobr> is sometimes faster than, and is never slower than, <nobr><tt>i++</tt></nobr>.
<p>For intrinsic types like <tt>int</tt>, it doesn't matter: <nobr><tt>++i</tt></nobr> and
<nobr><tt>i++</tt></nobr> are the same speed.  For class types like iterators or the
previous FAQ's <tt>Number</tt> class, <nobr><tt>++i</tt></nobr> very well might be faster
than <nobr><tt>i++</tt></nobr> since the latter might make a copy of the <tt>this</tt>
object.
<p>The overhead of <nobr><tt>i++</tt></nobr>, if it is there at all, won't probably make any
practical difference unless your app is CPU bound.  For example, if your app
spends most of its time waiting for someone to click a mouse, doing disk I/O,
network I/O, or database queries, then it won't hurt your performance to waste
a few CPU cycles.  <em>However</em> it's just as easy to type <nobr><tt>++i</tt></nobr> as
<nobr><tt>i++</tt></nobr>, so why not use the former unless you actually need the old value
of <tt>i</tt>.
<p>So if you're writing <nobr><tt>i++</tt></nobr> as a statement rather than as part of a
larger expression, why not just write <nobr><tt>++i</tt></nobr> instead?  You never lose
anything, and you sometimes gain something.  Old line C programmers are used
to writing <nobr><tt>i++</tt></nobr> instead of <nobr><tt>++i</tt></nobr>.  E.g., they'll say, <nobr><tt>for (i
= 0;</tt></nobr> <nobr><tt>i &lt; 10;</tt></nobr> <nobr><tt>i++) </tt>...<tt></tt></nobr>.  Since this uses <nobr><tt>i++</tt></nobr> as a
statement, not as a part of a larger expression, then you might want to use
<nobr><tt>++i</tt></nobr> instead.  For symmetry, I personally advocate that style even when
it doesn't improve speed, e.g., for intrinsic types and for class types with
postfix operators that return <tt>void</tt>.
<p>Obviously when <nobr><tt>i++</tt></nobr> appears as a part of a larger expression, that's
different: it's being used because it's the only logically correct solution,
not because it's an old habit you picked up while programming in C.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="bottom"></a>
<a href="mailto:cline@parashift.com" title="cline@parashift.com"><img src="mbox.gif" height=26 width=89 alt="E-Mail">&nbsp;E-mail the author</a><br>
[&nbsp;<a href="index-2.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>
|&nbsp;<a href="index-2.html#table-of-contents" title="Table of contents">Table&nbsp;of&nbsp;contents</a>
|&nbsp;<a href="subject-index.html" title="Subject index; 5111 links to 3243 topics">Subject&nbsp;index</a>
|&nbsp;<a href="copy-permissions.html#faq-1.1" title="[1.1] Author">About&nbsp;the&nbsp;author</a>
|&nbsp;<a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">&copy;</a>
|&nbsp;<a href="on-line-availability.html#faq-2.2" title="[2.2] What happened to the one-click-download option?">Download&nbsp;your&nbsp;own&nbsp;copy</a>&nbsp;]<br>
<small>Revised Mar 1, 2006</small>
</body>

<!-- Mirrored from www.dietmar-kuehl.de/mirror/c++-faq/operator-overloading.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 18 Sep 2025 13:11:21 GMT -->
</html>
