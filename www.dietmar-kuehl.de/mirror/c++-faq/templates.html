<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>

<!-- Mirrored from www.dietmar-kuehl.de/mirror/c++-faq/templates.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 18 Sep 2025 13:11:23 GMT -->
<head>
<title>[35] Templates &nbsp;Updated!&nbsp;, C++ FAQ Lite</title>
<meta name="FILENAME" content="templates.html">
<meta name="ABSTRACT" content="[35] Templates [Updated!], C++ FAQ Lite">
<meta name="OWNER"    content="cline@parashift.com">
<meta name="AUTHOR"   content="Marshall Cline, cline@parashift.com">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rev=made href="mailto:cline@parashift.com">
<style type='text/css'>
  <!--
  body       { font-family: arial; color: black; background: white }
  .CodeBlock { color: black; background-color: #dfdfdf; margin-left: 30px; margin-right: 30px; padding: 5pt }
  .CodeBlock small tt { font-size: small }
  .FaqTitle  { color: black; background-color: gold }
  .Updated   { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #ffff00; border: solid #e0e000 1px; }
  .New       { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #00ff00; border: solid #00d000 1px; }
  ul         { margin-bottom: 1px; margin-top: 1px }
  ol         { margin-bottom: 1px; margin-top: 1px }
  li         { margin-bottom: 4px; margin-top: 4px }
  -->
</style>
</head>
<body>
<h1><a name="top"></a>[35] Templates <span class=Updated>&nbsp;Updated!&nbsp;</span><br>
<small><small>(Part of <a href="index-2.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>, <a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">Copyright&nbsp;&copy; 1991-2006</a>, <a href="http://www.parashift.com/" title="www.parashift.com/" target='_blank'>Marshall Cline</a>, <a href="mailto:cline@parashift.com" title="cline@parashift.com"><tt>cline@parashift.com</tt></a>)</small></small></h1>
<hr>
<h3>FAQs in section [35]:</h3>
<ul>
<li><a href="templates.html#faq-35.1" title="[35.1] What's the idea behind templates?">[35.1] What's the idea behind templates?</a></li>
<li><a href="templates.html#faq-35.2" title="[35.2] What's the syntax / semantics for a &quot;class template&quot;?">[35.2] What's the syntax / semantics for a &quot;class template&quot;?</a></li>
<li><a href="templates.html#faq-35.3" title="[35.3] What's the syntax / semantics for a &quot;function template&quot;?">[35.3] What's the syntax / semantics for a &quot;function template&quot;?</a></li>
<li><a href="templates.html#faq-35.4" title="[35.4] How do I explicitly select which version of a function template should get called?">[35.4] How do I explicitly select which version of a function template should get called?</a></li>
<li><a href="templates.html#faq-35.5" title="[35.5] What is a &quot;parameterized type&quot;?">[35.5] What is a &quot;parameterized type&quot;?</a></li>
<li><a href="templates.html#faq-35.6" title="[35.6] What is &quot;genericity&quot;?">[35.6] What is &quot;genericity&quot;?</a></li>
<li><a href="templates.html#faq-35.7" title="[35.7] My template function does something special when the template type T is int or std::string; how do I write my template so it uses the special code when T is one of those specific types?">[35.7] My template function does something special when the template type <tt>T</tt> is <tt>int</tt> or <nobr><tt>std::string</tt></nobr>; how do I write my template so it uses the special code when <tt>T</tt> is one of those specific types?</a> <span class=New>&nbsp;New!&nbsp;</span></li>
<li><a href="templates.html#faq-35.8" title="[35.8] Huh? Can you provide an example of template specialization that doesn't use foo and bar?">[35.8] Huh? Can you provide an example of template specialization that doesn't use <tt>foo</tt> and <tt>bar</tt>?</a> <span class=New>&nbsp;New!&nbsp;</span></li>
<li><a href="templates.html#faq-35.9" title="[35.9] But most of the code in my template function is the same; is there some way to get the benefits of template specialization without duplicating all that source code?">[35.9] But most of the code in my template function is the same; is there some way to get the benefits of template specialization without duplicating all that source code?</a> <span class=New>&nbsp;New!&nbsp;</span></li>
<li><a href="templates.html#faq-35.10" title="[35.10] All those templates and template specializations must slow down my program, right?">[35.10] All those templates and template specializations must slow down my program, right?</a> <span class=New>&nbsp;New!&nbsp;</span></li>
<li><a href="templates.html#faq-35.11" title="[35.11] So templates are overloading, right?">[35.11] So templates are overloading, right?</a> <span class=New>&nbsp;New!&nbsp;</span></li>
<li><a href="templates.html#faq-35.12" title="[35.12] Why can't I separate the definition of my templates class from it's declaration and put it inside a .cpp file?">[35.12] Why can't I separate the definition of my templates class from it's declaration and put it inside a .cpp file?</a> <span class=Updated>&nbsp;Updated!&nbsp;</span></li>
<li><a href="templates.html#faq-35.13" title="[35.13] How can I avoid linker errors with my template functions?">[35.13] How can I avoid linker errors with my template functions?</a> <span class=Updated>&nbsp;Updated!&nbsp;</span></li>
<li><a href="templates.html#faq-35.14" title="[35.14] How does the C++ keyword export help with template linker errors?">[35.14] How does the C++ keyword <tt>export</tt> help with template linker errors?</a> <span class=New>&nbsp;New!&nbsp;</span></li>
<li><a href="templates.html#faq-35.15" title="[35.15] How can I avoid linker errors with my template classes?">[35.15] How can I avoid linker errors with my template classes?</a></li>
<li><a href="templates.html#faq-35.16" title="[35.16] Why do I get linker errors when I use template friends?">[35.16] Why do I get linker errors when I use template friends?</a></li>
<li><a href="templates.html#faq-35.17" title="[35.17] How can any human hope to understand these overly verbose template-based error messages?">[35.17] How can any human hope to understand these overly verbose template-based error messages?</a></li>
<li><a href="templates.html#faq-35.18" title="[35.18] Why am I getting errors when my template-derived-class accesses something it inherited from its template-base-class?">[35.18] Why am I getting errors when my template-derived-class accesses something it inherited from its template-base-class?</a></li>
<li><a href="templates.html#faq-35.19" title="[35.19] Can the previous problem hurt me silently? Is it possible that the compiler will silently generate the wrong code?">[35.19] Can the previous problem hurt me silently? Is it possible that the compiler will silently generate the wrong code?</a></li>
</ul>
<p><hr>
<p><a name="faq-35.1"></a>
<div class=FaqTitle><h3>[35.1] What's the idea behind templates?</h3></div>
<p>A template is a cookie-cutter that specifies how to cut cookies that all look
pretty much the same (although the cookies can be made of various kinds of
dough, they'll all have the same basic shape).  In the same way, a class
template is a cookie cutter for a description of how to build a family of
classes that all look basically the same, and a function template describes
how to build a family of similar looking functions.
<p>Class templates are often used to build type safe containers (although this
only scratches the surface for how they can be used).
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.2"></a>
<div class=FaqTitle><h3>[35.2] What's the syntax / semantics for a &quot;class template&quot;?</h3></div>
<p>Consider a container <tt>class</tt> <tt>Array</tt> that acts like an array of integers:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;This&nbsp;would&nbsp;go&nbsp;into&nbsp;a&nbsp;header&nbsp;file&nbsp;such&nbsp;as&nbsp;&quot;<tt>Array.h</tt>&quot;</small></em><tt><br>
&nbsp;class&nbsp;Array&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Array(int&nbsp;len=10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;len_(len),&nbsp;data_(new&nbsp;int[len])&nbsp;{&nbsp;}<br>
&nbsp;&nbsp;~Array()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;delete[]&nbsp;data_;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;int&nbsp;len()&nbsp;const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;len_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;const&nbsp;int&amp;&nbsp;operator[](int&nbsp;i)&nbsp;const&nbsp;{&nbsp;return&nbsp;data_[check(i)];&nbsp;}&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;<a href="const-correctness.html#faq-18.12" title="[18.12] What's the deal with &quot;const-overloading&quot;?">subscript&nbsp;operators&nbsp;often&nbsp;come&nbsp;in&nbsp;pairs<!--rawtext:[18.12]:rawtext--></a></small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&amp;&nbsp;operator[](int&nbsp;i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;data_[check(i)];&nbsp;}&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;<a href="const-correctness.html#faq-18.12" title="[18.12] What's the deal with &quot;const-overloading&quot;?">subscript&nbsp;operators&nbsp;often&nbsp;come&nbsp;in&nbsp;pairs<!--rawtext:[18.12]:rawtext--></a></small></em><tt><br>
&nbsp;&nbsp;&nbsp;Array(const&nbsp;Array&amp;);<br>
&nbsp;&nbsp;&nbsp;Array&amp;&nbsp;operator=&nbsp;(const&nbsp;Array&amp;);<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;len_;<br>
&nbsp;&nbsp;&nbsp;int*&nbsp;data_;<br>
&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;check(int&nbsp;i)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;if&nbsp;(i&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;i&nbsp;&gt;=&nbsp;len_)&nbsp;throw&nbsp;BoundsViol(&quot;Array&quot;,&nbsp;i,&nbsp;len_);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;&nbsp;}<br>
&nbsp;};
</tt>
</div>
<p>Repeating the above over and over for Array of float, of char, of
<nobr><tt>std::string</tt></nobr>, of Array-of-<nobr><tt>std::string</tt></nobr>, etc, will become tedious.
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;This&nbsp;would&nbsp;go&nbsp;into&nbsp;a&nbsp;header&nbsp;file&nbsp;such&nbsp;as&nbsp;&quot;<tt>Array.h</tt>&quot;</small></em><tt><br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;Array&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Array(int&nbsp;len=10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;len_(len),&nbsp;data_(new&nbsp;T[len])&nbsp;{&nbsp;}<br>
&nbsp;&nbsp;~Array()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;delete[]&nbsp;data_;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;int&nbsp;len()&nbsp;const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;len_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;const&nbsp;T&amp;&nbsp;operator[](int&nbsp;i)&nbsp;const&nbsp;{&nbsp;return&nbsp;data_[check(i)];&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&amp;&nbsp;operator[](int&nbsp;i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;data_[check(i)];&nbsp;}<br>
&nbsp;&nbsp;&nbsp;Array(const&nbsp;Array&lt;T&gt;&amp;);<br>
&nbsp;&nbsp;&nbsp;Array&lt;T&gt;&amp;&nbsp;operator=&nbsp;(const&nbsp;Array&lt;T&gt;&amp;);<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;int&nbsp;len_;<br>
&nbsp;&nbsp;&nbsp;T*&nbsp;&nbsp;data_;<br>
&nbsp;&nbsp;&nbsp;int&nbsp;check(int&nbsp;i)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;if&nbsp;(i&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;i&nbsp;&gt;=&nbsp;len_)&nbsp;throw&nbsp;BoundsViol(&quot;Array&quot;,&nbsp;i,&nbsp;len_);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;&nbsp;}<br>
&nbsp;};
</tt>
</div>
<p>Unlike <a href="templates.html#faq-35.3" title="[35.3] What's the syntax / semantics for a &quot;function template&quot;?">template functions<!--rawtext:[35.3]:rawtext--></a>, template classes
(instantiations of class templates) need to be explicit about the parameters
over which they are instantiating:
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Array&lt;int&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ai;<br>
&nbsp;&nbsp;&nbsp;Array&lt;float&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;af;<br>
&nbsp;&nbsp;&nbsp;Array&lt;char*&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ac;<br>
&nbsp;&nbsp;&nbsp;Array&lt;std::string&gt;&nbsp;&nbsp;&nbsp;as;<br>
&nbsp;&nbsp;&nbsp;Array&lt;&nbsp;Array&lt;int&gt;&nbsp;&gt;&nbsp;&nbsp;aai;<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Note the space between the two <nobr><tt>&gt;</tt></nobr>'s in the last example.  Without this
space, the compiler would see a <nobr><tt>&gt;&gt;</tt></nobr> (right-shift) token instead of two
<nobr><tt>&gt;</tt></nobr>'s.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.3"></a>
<div class=FaqTitle><h3>[35.3] What's the syntax / semantics for a &quot;function template&quot;?</h3></div>
<p>Consider this function that swaps its two integer arguments:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;swap(int&amp;&nbsp;x,&nbsp;int&amp;&nbsp;y)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;int&nbsp;tmp&nbsp;=&nbsp;x;<br>
&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y;<br>
&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;tmp;<br>
&nbsp;}
</tt>
</div>
<p>If we also had to swap floats, longs, Strings, Sets, and FileSystems, we'd get
pretty tired of coding lines that look almost identical except for the type.
Mindless repetition is an ideal job for a computer, hence a function
template:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;swap(T&amp;&nbsp;x,&nbsp;T&amp;&nbsp;y)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;T&nbsp;tmp&nbsp;=&nbsp;x;<br>
&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y;<br>
&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;tmp;<br>
&nbsp;}
</tt>
</div>
<p>Every time we used <nobr><tt>swap()</tt></nobr> with a given pair of types, the compiler will go to
the above definition and will create yet another &quot;template function&quot; as an
instantiation of the above.  E.g.,
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,j;&nbsp;&nbsp;</tt><em><small>/*...*/</small></em><tt>&nbsp;&nbsp;swap(i,j);&nbsp;&nbsp;</tt><em><small>//&nbsp;Instantiates&nbsp;a&nbsp;swap&nbsp;for&nbsp;<tt>int</tt></small></em><tt><br>
&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a,b;&nbsp;&nbsp;</tt><em><small>/*...*/</small></em><tt>&nbsp;&nbsp;swap(a,b);&nbsp;&nbsp;</tt><em><small>//&nbsp;Instantiates&nbsp;a&nbsp;swap&nbsp;for&nbsp;<tt>float</tt></small></em><tt><br>
&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c,d;&nbsp;&nbsp;</tt><em><small>/*...*/</small></em><tt>&nbsp;&nbsp;swap(c,d);&nbsp;&nbsp;</tt><em><small>//&nbsp;Instantiates&nbsp;a&nbsp;swap&nbsp;for&nbsp;<tt>char</tt></small></em><tt><br>
&nbsp;&nbsp;&nbsp;std::string&nbsp;s,t;&nbsp;&nbsp;</tt><em><small>/*...*/</small></em><tt>&nbsp;&nbsp;swap(s,t);&nbsp;&nbsp;</tt><em><small>//&nbsp;Instantiates&nbsp;a&nbsp;swap&nbsp;for&nbsp;<nobr><tt>std::string</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Note: A &quot;template function&quot; is the instantiation of a &quot;function template&quot;.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.4"></a>
<div class=FaqTitle><h3>[35.4] How do I explicitly select which version of a function template should get called?</h3></div>
<p>When you call a function template, the compiler tries to <em>deduce</em> the
template type.  Most of the time it can do that successfully, but every once
in a while you may want to help the compiler deduce the right type &#151; either
because it cannot deduce the type at all, or perhaps because it would deduce
the wrong type.
<p>For example, you might be calling a function template that doesn't have any
parameters of its template argument types, or you might want to force the
compiler to do certain promotions on the arguments before selecting the
correct function template.  In these cases you'll need to explicitly tell the
compiler which instantiation of the function template should be called.
<p>Here is a sample function template where the template parameter <tt>T</tt> does
not appear in the function's parameter list.  In this case the compiler
<em>cannot</em> deduce the template parameter types when the function is
called.
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;f()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>To call this function with <tt>T</tt> being an <tt>int</tt> or a <nobr><tt>std::string</tt></nobr>, you
could say:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;string&gt;<br>
&nbsp;<br>
&nbsp;void&nbsp;sample()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;f&lt;int&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;type&nbsp;<tt>T</tt>&nbsp;will&nbsp;be&nbsp;<tt>int</tt>&nbsp;in&nbsp;this&nbsp;call</small></em><tt><br>
&nbsp;&nbsp;&nbsp;f&lt;std::string&gt;();&nbsp;&nbsp;</tt><em><small>//&nbsp;type&nbsp;<tt>T</tt>&nbsp;will&nbsp;be&nbsp;<nobr><tt>std::string</tt></nobr>&nbsp;in&nbsp;this&nbsp;call</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Here is another function whose template parameters appear in the function's
list of formal parameters (that is, the compiler <em>can</em> deduce the
template type from the actual arguments):
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;g(T&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Now if you want to force the actual arguments to be promoted before the
compiler deduces the template type, you can use the above technique.  E.g., if
you simply called <nobr><tt>g(42)</tt></nobr> you would get <nobr><tt>g&lt;int&gt;(42)</tt></nobr>, but if you
wanted to pass <tt>42</tt> to <nobr><tt>g&lt;long&gt;()</tt></nobr>, you could say this:
<nobr><tt>g&lt;long&gt;(42)</tt></nobr>.  (Of course you could also promote the parameter
explicitly, such as either <nobr><tt>g(long(42))</tt></nobr> or even <nobr><tt>g(42L)</tt></nobr>, but
that ruins the example.)
<p>Similarly if you said <nobr><tt>g(&quot;xyz&quot;)</tt></nobr> you'd end up calling
<nobr><tt>g&lt;char*&gt;(char*)</tt></nobr>, but if you wanted to call the <nobr><tt>std::string</tt></nobr>
version of <nobr><tt>g&lt;&gt;()</tt></nobr> you could say <nobr><tt>g&lt;std::string&gt;(&quot;xyz&quot;)</tt></nobr>.  (Again
you could also promote the argument, such as <nobr><tt>g(std::string(&quot;xyz&quot;))</tt></nobr>,
but that's another story.)
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.5"></a>
<div class=FaqTitle><h3>[35.5] What is a &quot;parameterized type&quot;?</h3></div>
<p>Another way to say, &quot;class templates.&quot;
<p>A parameterized type is a type that is parameterized over another type or some
value.  <nobr><tt>List&lt;int&gt;</tt></nobr> is a type (<tt>List</tt>) parameterized over another type (<tt>int</tt>).
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.6"></a>
<div class=FaqTitle><h3>[35.6] What is &quot;genericity&quot;?</h3></div>
<p>Yet another way to say, &quot;class templates.&quot;
<p>Not to be confused with &quot;generality&quot; (which just means avoiding solutions which
are overly specific), &quot;genericity&quot; means class templates.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.7"></a>
<div class=FaqTitle><h3>[35.7] My template function does something special when the template type <tt>T</tt> is <tt>int</tt> or <nobr><tt>std::string</tt></nobr>; how do I write my template so it uses the special code when <tt>T</tt> is one of those specific types? <span class=New>&nbsp;New!&nbsp;</span></h3></div>
<small><em>[Recently created thanks to <a href="mailto:(NOSPAM)v(DOT)bazarov(AT)comcast(DOT)net" title="(NOSPAM)v(DOT)bazarov(AT)comcast(DOT)net">Victor Bazarov</a> (in 10/05).  <a href="templates.html#faq-35.8" title="[35.8] Huh? Can you provide an example of template specialization that doesn't use foo and bar?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[35.8]:rawtext--></a>.]</em></small>
<p>Before showing how to do this, let's make sure you're not shooting yourself in
the foot.  Does the function's behavior <em>appear</em> different to your
users?  In other words, is the <em>observable behavior</em> different in some
substantive way?  If so, you're probably shooting yourself in the foot and you
will probably confuse your users &#151; you're probably better off using
different functions with different names &#151; don't use templates, don't use
overloading.  For example, if the code for <tt>int</tt> inserts something into
a container and sorts the result, but the code for <nobr><tt>std::string</tt></nobr> removes
something from a container and does not sort the result, those two functions
ought not to be an overloaded pair &#151; their <em>observable behavior</em> is
different so they ought to have different names.
<p>However if the function's observable behavior is consistent for all the
<tt>T</tt> types with the differences limited to implementation details, then
you can proceed.  Let's proceed with an example of this (conceptual only; not
C++):
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;foo(const&nbsp;T&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;switch&nbsp;(typeof(T))&nbsp;{&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;conceptual&nbsp;only;&nbsp;not&nbsp;C++</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;int:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;implementation&nbsp;details&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;<tt>int</tt></small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;std::string:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;implementation&nbsp;details&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;<nobr><tt>std::string</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;implementation&nbsp;details&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;neither&nbsp;<tt>int</tt>&nbsp;nor&nbsp;<nobr><tt>std::string</tt></nobr></small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;}
</tt>
</div>
<p>One way to implement the above is via template specialization.  Instead of a
<tt>switch</tt>-statement, you end up breaking up the code into separate
functions.  The first function is the <tt>default</tt> case &#151; the code to be
used when <tt>T</tt> is anything other than <tt>int</tt> or <nobr><tt>std::string</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;foo(const&nbsp;T&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;implementation&nbsp;details&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;neither&nbsp;<tt>int</tt>&nbsp;nor&nbsp;<nobr><tt>std::string</tt></nobr></small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Next are the two specializations, first for the <tt>int</tt> case...
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;&gt;<br>
&nbsp;void&nbsp;foo&lt;int&gt;(const&nbsp;int&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;implementation&nbsp;details&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;<tt>int</tt></small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>...and next for the <nobr><tt>std::string</tt></nobr> case...
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;&gt;<br>
&nbsp;void&nbsp;foo&lt;std::string&gt;(const&nbsp;std::string&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;implementation&nbsp;details&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;<nobr><tt>std::string</tt></nobr></small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>That's it; you're done.  The compiler will automagically select the correct
specialization when it sees which <tt>T</tt> you are using.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.8"></a>
<div class=FaqTitle><h3>[35.8] Huh? Can you provide an example of template specialization that doesn't use <tt>foo</tt> and <tt>bar</tt>? <span class=New>&nbsp;New!&nbsp;</span></h3></div>
<small><em>[Recently created (in 10/05) and rewrote the last paragraph for clarity (in 3/06).  <a href="templates.html#faq-35.9" title="[35.9] But most of the code in my template function is the same; is there some way to get the benefits of template specialization without duplicating all that source code?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[35.9]:rawtext--></a>.]</em></small>
<p>Yes.
<p>One of several ways I personally use <a href="templates.html#faq-35.7" title="[35.7] My template function does something special when the template type T is int or std::string; how do I write my template so it uses the special code when T is one of those specific types?">template
specialization<!--rawtext:[35.7]:rawtext--></a> is for stringification.  I usually use a template to
<a href="misc-technical-issues.html#faq-39.1" title="[39.1] How do I convert a value (a number, for example) to a std::string?">stringify various objects of various types<!--rawtext:[39.1]:rawtext--></a>,
but I often need to specialize the code for stringifying certain specific
types.  For instance, when stringifying <tt>bool</tt>s I prefer <nobr><tt>&quot;true&quot;</tt></nobr>
and <nobr><tt>&quot;false&quot;</tt></nobr> over <nobr><tt>&quot;1&quot;</tt></nobr> and <nobr><tt>&quot;0&quot;</tt></nobr> so I use
<nobr><tt>std::boolalpha</tt></nobr> when <tt>T</tt> is <tt>bool</tt>.  Also I often prefer
floating point output to contain all the digits (so I can see very small
differences, etc.) so I use <nobr><tt>std::setprecision</tt></nobr> when <tt>T</tt> is a
floating point type.  The end result usually looks something like this:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;#include&nbsp;&lt;sstream&gt;<br>
&nbsp;#include&nbsp;&lt;iomanip&gt;<br>
&nbsp;#include&nbsp;&lt;string&gt;<br>
&nbsp;#include&nbsp;&lt;limits&gt;<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;&nbsp;inline&nbsp;std::string&nbsp;stringify(const&nbsp;T&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::ostringstream&nbsp;out;<br>
&nbsp;&nbsp;&nbsp;out&nbsp;&lt;&lt;&nbsp;x;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;out.str();<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;&gt;&nbsp;inline&nbsp;std::string&nbsp;stringify&lt;bool&gt;(const&nbsp;bool&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::ostringstream&nbsp;out;<br>
&nbsp;&nbsp;&nbsp;out&nbsp;&lt;&lt;&nbsp;std::boolalpha&nbsp;&lt;&lt;&nbsp;x;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;out.str();<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;&gt;&nbsp;inline&nbsp;std::string&nbsp;stringify&lt;double&gt;(const&nbsp;double&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;const&nbsp;int&nbsp;sigdigits&nbsp;=&nbsp;std::numeric_limits&lt;double&gt;::digits10;<br>
&nbsp;&nbsp;&nbsp;std::ostringstream&nbsp;out;<br>
&nbsp;&nbsp;&nbsp;out&nbsp;&lt;&lt;&nbsp;std::setprecision(sigdigits)&nbsp;&lt;&lt;&nbsp;x;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;out.str();<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;&gt;&nbsp;inline&nbsp;std::string&nbsp;stringify&lt;float&gt;(const&nbsp;float&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;const&nbsp;int&nbsp;sigdigits&nbsp;=&nbsp;std::numeric_limits&lt;float&gt;::digits10;<br>
&nbsp;&nbsp;&nbsp;std::ostringstream&nbsp;out;<br>
&nbsp;&nbsp;&nbsp;out&nbsp;&lt;&lt;&nbsp;std::setprecision(sigdigits)&nbsp;&lt;&lt;&nbsp;x;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;out.str();<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;&gt;&nbsp;inline&nbsp;std::string&nbsp;stringify&lt;long&nbsp;double&gt;(const&nbsp;long&nbsp;double&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;const&nbsp;int&nbsp;sigdigits&nbsp;=&nbsp;std::numeric_limits&lt;long&nbsp;double&gt;::digits10;<br>
&nbsp;&nbsp;&nbsp;std::ostringstream&nbsp;out;<br>
&nbsp;&nbsp;&nbsp;out&nbsp;&lt;&lt;&nbsp;std::setprecision(sigdigits)&nbsp;&lt;&lt;&nbsp;x;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;out.str();<br>
&nbsp;}
</tt>
</div>
<p>Conceptually they all do the same thing: stringify the parameter.  That means
the <em>observable behavior</em> is consistent, therefore the specializations
do not confuse callers.  However the details for implementing that observable
behavior is slightly different for <tt>bool</tt> and floating point types, so
template specialization is a good approach.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.9"></a>
<div class=FaqTitle><h3>[35.9] But most of the code in my template function is the same; is there some way to get the benefits of template specialization without duplicating all that source code? <span class=New>&nbsp;New!&nbsp;</span></h3></div>
<small><em>[Recently created thanks to <a href="mailto:(NOSPAM)v(DOT)bazarov(AT)comcast(DOT)net" title="(NOSPAM)v(DOT)bazarov(AT)comcast(DOT)net">Victor Bazarov</a> (in 10/05) and reworked the code-commentary to improve clarity (in 3/06).  <a href="templates.html#faq-35.10" title="[35.10] All those templates and template specializations must slow down my program, right?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[35.10]:rawtext--></a>.]</em></small>
<p>Yes.
<p>For example, suppose your template function has a bunch of common code along
with a relatively small amount of <tt>T</tt>-specific code (conceptual only;
not C++):
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;foo(const&nbsp;T&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;common&nbsp;code&nbsp;that&nbsp;works&nbsp;for&nbsp;all&nbsp;<tt>T</tt>&nbsp;types&nbsp;...</small></em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;switch&nbsp;(typeof(T))&nbsp;{&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;conceptual&nbsp;only;&nbsp;not&nbsp;C++</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;int:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;small&nbsp;amount&nbsp;of&nbsp;code&nbsp;used&nbsp;only&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;<tt>int</tt>&nbsp;...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;std::string:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;small&nbsp;amount&nbsp;of&nbsp;code&nbsp;used&nbsp;only&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;<nobr><tt>std::string</tt></nobr>&nbsp;...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;small&nbsp;amount&nbsp;of&nbsp;code&nbsp;used&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;neither&nbsp;<tt>int</tt>&nbsp;nor&nbsp;<nobr><tt>std::string</tt></nobr>&nbsp;...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;more&nbsp;common&nbsp;code&nbsp;that&nbsp;works&nbsp;for&nbsp;all&nbsp;<tt>T</tt>&nbsp;types&nbsp;...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>If you blindly applied the advice from <a href="templates.html#faq-35.7" title="[35.7] My template function does something special when the template type T is int or std::string; how do I write my template so it uses the special code when T is one of those specific types?">the FAQ
on template specialization<!--rawtext:[35.7]:rawtext--></a>, you would end up duplicating all that code
before and after the pseudo-switch statement.  The way to get the best of both
worlds &#151; to get the benefits of <tt>T</tt>-specific pieces without
duplicating the entire function, is to extract the pseudo-switch statement
portion into a separate function <nobr><tt>foo_part()</tt></nobr>, and
<a href="templates.html#faq-35.7" title="[35.7] My template function does something special when the template type T is int or std::string; how do I write my template so it uses the special code when T is one of those specific types?">use template specialization<!--rawtext:[35.7]:rawtext--></a> on that
separate function:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;&nbsp;inline&nbsp;void&nbsp;foo_part(const&nbsp;T&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;small&nbsp;amount&nbsp;of&nbsp;code&nbsp;used&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;neither&nbsp;<tt>int</tt>&nbsp;nor&nbsp;<nobr><tt>std::string</tt></nobr>&nbsp;...</small></em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;&gt;&nbsp;inline&nbsp;void&nbsp;foo_part&lt;int&gt;(const&nbsp;int&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;small&nbsp;amount&nbsp;of&nbsp;code&nbsp;used&nbsp;only&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;<tt>int</tt>&nbsp;...</small></em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;&gt;&nbsp;inline&nbsp;void&nbsp;foo_part&lt;std::string&gt;(const&nbsp;std::string&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;small&nbsp;amount&nbsp;of&nbsp;code&nbsp;used&nbsp;only&nbsp;when&nbsp;<tt>T</tt>&nbsp;is&nbsp;<nobr><tt>std::string</tt></nobr>&nbsp;...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>The main <nobr><tt>foo()</tt></nobr> function would be a simple template &#151; no
specializations.  Note that the pseudo-switch statement has been replaced by a
call to <nobr><tt>foo_part()</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;foo(const&nbsp;T&amp;&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;common&nbsp;code&nbsp;that&nbsp;works&nbsp;for&nbsp;all&nbsp;<tt>T</tt>&nbsp;types&nbsp;...</small></em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;foo_part(x);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...&nbsp;more&nbsp;common&nbsp;code&nbsp;that&nbsp;works&nbsp;for&nbsp;all&nbsp;<tt>T</tt>&nbsp;types&nbsp;...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>As you can see, the body of <nobr><tt>foo()</tt></nobr> now doesn't mention any particular
<tt>T</tt>.  It all gets figured out automatically.  The compiler generates
<tt>foo</tt> for you based on type <tt>T</tt>, and will generate the correctly
typed <tt>foo_part</tt> function based on the actual compile-time known type of
the <tt>x</tt> argument.  Proper specializations of <tt>foo_part</tt> will be
instantiated.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.10"></a>
<div class=FaqTitle><h3>[35.10] All those templates and template specializations must slow down my program, right? <span class=New>&nbsp;New!&nbsp;</span></h3></div>
<small><em>[Recently created thanks to <a href="mailto:(NOSPAM)v(DOT)bazarov(AT)comcast(DOT)net" title="(NOSPAM)v(DOT)bazarov(AT)comcast(DOT)net">Victor Bazarov</a> (in 10/05).  <a href="templates.html#faq-35.11" title="[35.11] So templates are overloading, right?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[35.11]:rawtext--></a>.]</em></small>
<p>Wrong.
<p>This is a quality-of-implementation issue so your results may vary.  However
there is usually no slow-down at all.  If anything, the templates might affect
the speed of compilation slightly, but once the types are resolved by the
compiler at compile-time, it will typically generate code that is just as fast
as with non-template functions, including inline-expanding appropriate
functions, etc.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.11"></a>
<div class=FaqTitle><h3>[35.11] So templates are overloading, right? <span class=New>&nbsp;New!&nbsp;</span></h3></div>
<small><em>[Recently created thanks to <a href="mailto:(NOSPAM)v(DOT)bazarov(AT)comcast(DOT)net" title="(NOSPAM)v(DOT)bazarov(AT)comcast(DOT)net">Victor Bazarov</a> (in 10/05).  <a href="templates.html#faq-35.12" title="[35.12] Why can't I separate the definition of my templates class from it's declaration and put it inside a .cpp file?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[35.12]:rawtext--></a>.]</em></small>
<p>Yes and no.
<p>Function templates participate in name resolution for overloaded functions,
but the rules are different.  For a template to be considered in overload
resolution, the type has to match exactly.  If the types do not match exactly,
the conversions are not considered and the template is simply dropped from the
set of viable functions.  That's what is known as &quot;SFINAE&quot; &#151; Substitution
Failure Is Not An Error.  Example:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;#include&nbsp;&lt;typeinfo&gt;<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;&nbsp;void&nbsp;foo(T*&nbsp;x)<br>
&nbsp;{&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;foo&lt;&quot;&nbsp;&lt;&lt;&nbsp;typeid(T).name()&nbsp;&lt;&lt;&nbsp;&quot;&gt;(T*)\n&quot;;&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;foo(int&nbsp;x)<br>
&nbsp;{&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;foo(int)\n&quot;;&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;foo(double&nbsp;x)<br>
&nbsp;{&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;foo(double)\n&quot;;&nbsp;}<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo(42);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;matches&nbsp;<nobr><tt>foo(int)</tt></nobr>&nbsp;exactly</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo(42.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;matches&nbsp;<nobr><tt>foo(double)</tt></nobr>&nbsp;exactly</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo(&quot;abcdef&quot;);&nbsp;&nbsp;</tt><em><small>//&nbsp;matches&nbsp;<nobr><tt>foo&lt;T&gt;(T*)</tt></nobr>&nbsp;with&nbsp;<tt>T</tt>&nbsp;=&nbsp;<tt>char</tt></small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>
&nbsp;}
</tt>
</div>
<p>In this example, <nobr><tt>foo&lt;T&gt;</tt></nobr> cannot be considered for the first or the
second call to <tt>foo</tt> in the body of <tt>main</tt> because neither 42 nor
42.0 gives the compiler any information to deduce <tt>T</tt>.  The third call,
however, includes <nobr><tt>foo&lt;T&gt;</tt></nobr> with <tt>T</tt> = <tt>char</tt> and it wins.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.12"></a>
<div class=FaqTitle><h3>[35.12] Why can't I separate the definition of my templates class from it's declaration and put it inside a .cpp file? <span class=Updated>&nbsp;Updated!&nbsp;</span></h3></div>
<small><em>[Recently added some caveats and pointed people to the newly added FAQ on the <tt>export</tt> keyword (in 10/05).  <a href="templates.html#faq-35.13" title="[35.13] How can I avoid linker errors with my template functions?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[35.13]:rawtext--></a>.]</em></small>
<p>If all you want to know is <em>how</em> to fix this situation, read the
<a href="templates.html#faq-35.13" title="[35.13] How can I avoid linker errors with my template functions?">next<!--rawtext:[35.13]:rawtext--></a>
<a href="templates.html#faq-35.14" title="[35.14] How does the C++ keyword export help with template linker errors?">two<!--rawtext:[35.14]:rawtext--></a> FAQs.  But
in order to understand <em>why</em> things are the way they are, first accept
these facts:
<ol>
<li>A template is not a class or a function.  A template is a
&quot;pattern&quot; that the compiler uses to generate a family of
<a href="templates.html#faq-35.2" title="[35.2] What's the syntax / semantics for a &quot;class template&quot;?">classes<!--rawtext:[35.2]:rawtext--></a> or <a href="templates.html#faq-35.3" title="[35.3] What's the syntax / semantics for a &quot;function template&quot;?">functions<!--rawtext:[35.3]:rawtext--></a>.</li>
<li>In order for the compiler to generate the code, it must see
both the template definition (not just declaration) and the specific
types/whatever used to &quot;fill in&quot; the template.  For example, if you're
trying to use a <nobr><tt>Foo&lt;int&gt;</tt></nobr>, the compiler must see both the <tt>Foo</tt>
template and the fact that you're trying to make a specific
<nobr><tt>Foo&lt;int&gt;</tt></nobr>.</li>
<li>Your compiler probably doesn't remember the details of one
<tt>.cpp</tt> file while it is compiling another <tt>.cpp</tt> file.  It
<em>could</em>, but most do not and if you are reading this FAQ, it
almost definitely does not.  BTW this is called the &quot;separate
compilation model.&quot;</li>
</ol>
<p>Now based on those facts, here's an example that shows why things are the way
they are.  Suppose you have a template <tt>Foo</tt> defined like this:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo();<br>
&nbsp;&nbsp;&nbsp;void&nbsp;someMethod(T&nbsp;x);<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;T&nbsp;x;<br>
&nbsp;};
</tt>
</div>
<p>Along with similar definitions for the member functions:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;Foo&lt;T&gt;::Foo()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;Foo&lt;T&gt;::someMethod(T&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Now suppose you have some code in file <tt>Bar.cpp</tt> that uses
<nobr><tt>Foo&lt;int&gt;</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;Bar.cpp</small></em><tt><br>
&nbsp;<br>
&nbsp;void&nbsp;blah_blah_blah()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;Foo&lt;int&gt;&nbsp;f;<br>
&nbsp;&nbsp;&nbsp;f.someMethod(5);<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Clearly somebody somewhere is going to have to use the &quot;pattern&quot; for
the constructor definition and for the <nobr><tt>someMethod()</tt></nobr> definition and
instantiate those when <tt>T</tt> is actually <tt>int</tt>.  But if you had put the
definition of the constructor and <nobr><tt>someMethod()</tt></nobr> into file
<tt>Foo.cpp</tt>, the compiler would see the template code when it
compiled <tt>Foo.cpp</tt> and it would see <nobr><tt>Foo&lt;int&gt;</tt></nobr> when it
compiled <tt>Bar.cpp</tt>, but there would never be a time when it saw
both the template code and <nobr><tt>Foo&lt;int&gt;</tt></nobr>.  So by rule #2 above, it
could never generate the code for <nobr><tt>Foo&lt;int&gt;::someMethod()</tt></nobr>.
<p><em>A note to the experts:</em> I have obviously made several simplifications
above.  This was intentional so please don't complain too loudly.  If you know
the difference between a <tt>.cpp</tt> file and a compilation unit, the
difference between a class template and a template class, and the fact that
templates really aren't just glorified macros, then don't complain: this
particular question/answer wasn't aimed at you to begin with.  I simplified
things so newbies would &quot;get it,&quot; even if doing so offends some experts.
<p><em>Reminder:</em> Read the
<a href="templates.html#faq-35.13" title="[35.13] How can I avoid linker errors with my template functions?">next<!--rawtext:[35.13]:rawtext--></a>
<a href="templates.html#faq-35.14" title="[35.14] How does the C++ keyword export help with template linker errors?">two<!--rawtext:[35.14]:rawtext--></a> FAQs for
some solutions to this problem.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.13"></a>
<div class=FaqTitle><h3>[35.13] How can I avoid linker errors with my template functions? <span class=Updated>&nbsp;Updated!&nbsp;</span></h3></div>
<small><em>[Recently added some caveats and pointed people to the newly added FAQ on the <tt>export</tt> keyword (in 10/05).  <a href="templates.html#faq-35.14" title="[35.14] How does the C++ keyword export help with template linker errors?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[35.14]:rawtext--></a>.]</em></small>
<p>Tell your C++ compiler which instantiations to make while it is compiling your
template function's .cpp file.
<p>As an example, consider the header file <tt>foo.h</tt> which contains the
following template function declaration:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;foo.h&quot;</small></em><tt><br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;extern&nbsp;void&nbsp;foo();
</tt>
</div>
<p>Now suppose file <tt>foo.cpp</tt> actually defines that template function:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;foo.cpp&quot;</small></em><tt><br>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;#include&nbsp;&quot;foo.h&quot;<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;foo()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Here&nbsp;I&nbsp;am!\n&quot;;<br>
&nbsp;}
</tt>
</div>
<p>Suppose file <tt>main.cpp</tt> uses this template function by calling
<nobr><tt>foo&lt;int&gt;()</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;main.cpp&quot;</small></em><tt><br>
&nbsp;#include&nbsp;&quot;foo.h&quot;<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;foo&lt;int&gt;();<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>If you compile and (try to) link these two .cpp files, most compilers will
generate linker errors.  There are three solutions for this.  The first
solution is to physically move the definition of the template function into
the .h file, even if it is not an <tt>inline</tt> function.  This solution may
(or may not!) cause significant code bloat, meaning your executable size may
increase dramatically (or, if your compiler is smart enough, may not; try it
and see).
<p>The other solution is to leave the definition of the template function in the
.cpp file and simply add the line <nobr><tt>template void foo&lt;int&gt;();</tt></nobr> to that
file:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;foo.cpp&quot;</small></em><tt><br>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;#include&nbsp;&quot;foo.h&quot;<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;&nbsp;void&nbsp;foo()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Here&nbsp;I&nbsp;am!\n&quot;;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&nbsp;void&nbsp;foo&lt;int&gt;();
</tt>
</div>
<p>If you can't modify <tt>foo.cpp</tt>, simply create a new .cpp file such as
<nobr><tt>foo-impl.cpp</tt></nobr> as follows:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;foo-impl.cpp&quot;</small></em><tt><br>
&nbsp;#include&nbsp;&quot;foo.cpp&quot;<br>
&nbsp;<br>
&nbsp;template&nbsp;void&nbsp;foo&lt;int&gt;();
</tt>
</div>
<p>Notice that <nobr><tt>foo-impl.cpp</tt></nobr> <nobr><tt>#include</tt></nobr>s a .cpp file, not a .h file.
If that's confusing, click your heels twice, think of Kansas, and repeat after
me, &quot;I will do it anyway even though it's confusing.&quot; You can trust me on
this one.  But if you don't trust me or are simply curious,
<a href="templates.html#faq-35.12" title="[35.12] Why can't I separate the definition of my templates class from it's declaration and put it inside a .cpp file?">the rationale is given earlier<!--rawtext:[35.12]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.14"></a>
<div class=FaqTitle><h3>[35.14] How does the C++ keyword <tt>export</tt> help with template linker errors? <span class=New>&nbsp;New!&nbsp;</span></h3></div>
<small><em>[Recently created thanks to <a href="http://www.cs.technion.ac.il/users/yechiel" title="www.cs.technion.ac.il/users/yechiel" target='_blank'>Yechiel Kimchi</a> (in 10/05).  <a href="compiler-dependencies.html#faq-38.1" title="[38.1] Where can I download a free C++ compiler?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[38.1]:rawtext--></a>.]</em></small>
<p>The C++ keyword <tt>export</tt> is designed to eliminate the need to
<a href="templates.html#faq-35.13" title="[35.13] How can I avoid linker errors with my template functions?">include a template definition<!--rawtext:[35.13]:rawtext--></a>
(either by providing the definition in the header file or by including the
implementation file).  However, at the time of this writing, the only
well-known compiler that supports this capability is
<a href="http://www.comeaucomputing.com/tryitout" title="www.comeaucomputing.com/tryitout" target='_blank'>Comeau C++</a>.  The
future of the <tt>export</tt> keyword is unknown.  Without taking sides in the
debate, I will simply report that some compiler vendors are indicating they
might never implement it, and that the C++ standards committee has decided to
leave it in.
<p>If you want your code to work with compilers that do not support the
<tt>export</tt> keyword, yet to also take advantage of the <tt>export</tt>
keyword with compilers that support it, define your template header-files like
this:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;Foo.h</small></em><tt><br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;#ifndef&nbsp;USE_EXPORT_KEYWORD<br>
&nbsp;&nbsp;&nbsp;#include&nbsp;&quot;Foo.cpp&quot;<br>
&nbsp;#endif
</tt>
</div>
<p>And define your non-inline functions in a source-file like this:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;Foo.cpp</small></em><tt><br>
&nbsp;<br>
&nbsp;#ifndef&nbsp;USE_EXPORT_KEYWORD<br>
&nbsp;&nbsp;&nbsp;#define&nbsp;export&nbsp;</tt><em><small>/*nothing*/</small></em><tt><br>
&nbsp;#endif<br>
&nbsp;<br>
&nbsp;export&nbsp;template&lt;typename&nbsp;T&gt;&nbsp;...
</tt>
</div>
<p>Then, if/when your compiler supports the <tt>export</tt> keyword, and if for
whatever reason you want to exploit that feature, just define the symbol
<tt>USE_EXPORT_KEYWORD</tt>.
<p>The point is that you can program today <em>as if</em> your compiler has the
<tt>export</tt> keyword, and if/when your compiler actually does support that
keyword, undefine the <tt>NO_EXPORT_KEYWORD</tt> symbol, recompile, and you
will be exploiting that feature.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.15"></a>
<div class=FaqTitle><h3>[35.15] How can I avoid linker errors with my template classes?</h3></div>
<p>Tell your C++ compiler which instantiations to make while it is compiling your
template class's .cpp file.
<p>(If you've already read the previous FAQ, this answer is completely symmetric
with that one, so you can probably skip this answer.)
<p>As an example, consider the header file <tt>Foo.h</tt> which contains the
following template class.  Note that method <nobr><tt>Foo&lt;T&gt;::f()</tt></nobr> is inline and
methods <nobr><tt>Foo&lt;T&gt;::g()</tt></nobr> and <nobr><tt>Foo&lt;T&gt;::h()</tt></nobr> are not.
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;Foo.h&quot;</small></em><tt><br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;void&nbsp;f();<br>
&nbsp;&nbsp;&nbsp;void&nbsp;g();<br>
&nbsp;&nbsp;&nbsp;void&nbsp;h();<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;inline<br>
&nbsp;void&nbsp;Foo&lt;T&gt;::f()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>Now suppose file <tt>Foo.cpp</tt> actually defines the non-<tt>inline</tt>
methods <nobr><tt>Foo&lt;T&gt;::g()</tt></nobr> and <nobr><tt>Foo&lt;T&gt;::h()</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;Foo.cpp&quot;</small></em><tt><br>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;#include&nbsp;&quot;Foo.h&quot;<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;Foo&lt;T&gt;::g()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Foo&lt;T&gt;::g()\n&quot;;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;void&nbsp;Foo&lt;T&gt;::h()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Foo&lt;T&gt;::h()\n&quot;;<br>
&nbsp;}
</tt>
</div>
<p>Suppose file <tt>main.cpp</tt> uses this template class by creating a
<nobr><tt>Foo&lt;int&gt;</tt></nobr> and calling its methods:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;main.cpp&quot;</small></em><tt><br>
&nbsp;#include&nbsp;&quot;Foo.h&quot;<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Foo&lt;int&gt;&nbsp;x;<br>
&nbsp;&nbsp;&nbsp;x.f();<br>
&nbsp;&nbsp;&nbsp;x.g();<br>
&nbsp;&nbsp;&nbsp;x.h();<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>If you compile and (try to) link these two .cpp files, most compilers will
generate linker errors.  There are three solutions for this.  The first
solution is to physically move the definition of the template functions into
the .h file, even if they are not <tt>inline</tt> functions.  This solution may
(or may not!) cause significant code bloat, meaning your executable size may
increase dramatically (or, if your compiler is smart enough, may not; try it
and see).
<p>The other solution is to leave the definition of the template function in the
.cpp file and simply add the line <nobr><tt>template class Foo&lt;int&gt;;</tt></nobr> to that file:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;Foo.cpp&quot;</small></em><tt><br>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;#include&nbsp;&quot;Foo.h&quot;<br>
&nbsp;<br>
&nbsp;</tt><em><small>...definition&nbsp;of&nbsp;Foo&lt;T&gt;::f()&nbsp;is&nbsp;unchanged&nbsp;--&nbsp;see&nbsp;above...</small></em><tt><br>
&nbsp;</tt><em><small>...definition&nbsp;of&nbsp;Foo&lt;T&gt;::g()&nbsp;is&nbsp;unchanged&nbsp;--&nbsp;see&nbsp;above...</small></em><tt><br>
&nbsp;<br>
&nbsp;template&nbsp;class&nbsp;Foo&lt;int&gt;;
</tt>
</div>
<p>If you can't modify <tt>Foo.cpp</tt>, simply create a new .cpp file such as
<nobr><tt>Foo-impl.cpp</tt></nobr> as follows:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em><small>//&nbsp;File&nbsp;&quot;Foo-impl.cpp&quot;</small></em><tt><br>
&nbsp;#include&nbsp;&quot;Foo.cpp&quot;<br>
&nbsp;<br>
&nbsp;template&nbsp;class&nbsp;Foo&lt;int&gt;;
</tt>
</div>
<p>Notice that <nobr><tt>Foo-impl.cpp</tt></nobr> <nobr><tt>#include</tt></nobr>s a .cpp file, not a .h file.
If that's confusing, click your heels twice, think of Kansas, and repeat after
me, &quot;I will do it anyway even though it's confusing.&quot; You can trust me on
this one.  But if you don't trust me or are simply curious,
<a href="templates.html#faq-35.12" title="[35.12] Why can't I separate the definition of my templates class from it's declaration and put it inside a .cpp file?">the rationale is given earlier<!--rawtext:[35.12]:rawtext--></a>.
<p>If you are using <a href="http://www.comeaucomputing.com/tryitout" title="www.comeaucomputing.com/tryitout" target='_blank'>Comeau
C++</a>, you probably want to check out the <tt>export</tt> keyword.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.16"></a>
<div class=FaqTitle><h3>[35.16] Why do I get linker errors when I use template friends?</h3></div>
<p>Ah, the intricacies of template friends.  Here's an example of what people
often want to do:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(const&nbsp;T&amp;&nbsp;value&nbsp;=&nbsp;T());<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;Foo&lt;T&gt;&nbsp;operator+&nbsp;(const&nbsp;Foo&lt;T&gt;&amp;&nbsp;lhs,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;rhs);<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;std::ostream&amp;&nbsp;operator&lt;&lt;&nbsp;(std::ostream&amp;&nbsp;o,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;x);<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;T&nbsp;value_;<br>
&nbsp;};
</tt>
</div>
<p>Naturally the template will need to actually be <em>used</em> somewhere:
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Foo&lt;int&gt;&nbsp;lhs(1);<br>
&nbsp;&nbsp;&nbsp;Foo&lt;int&gt;&nbsp;rhs(2);<br>
&nbsp;&nbsp;&nbsp;Foo&lt;int&gt;&nbsp;result&nbsp;=&nbsp;lhs&nbsp;+&nbsp;rhs;<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;result;<br>
&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;}
</tt>
</div>
<p>And of course the various member and friend functions will need to be defined
somewhere:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;Foo&lt;T&gt;::Foo(const&nbsp;T&amp;&nbsp;value&nbsp;=&nbsp;T())<br>
&nbsp;&nbsp;&nbsp;:&nbsp;value_(value)<br>
&nbsp;{&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;Foo&lt;T&gt;&nbsp;operator+&nbsp;(const&nbsp;Foo&lt;T&gt;&amp;&nbsp;lhs,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;rhs)<br>
&nbsp;{&nbsp;return&nbsp;Foo&lt;T&gt;(lhs.value_&nbsp;+&nbsp;rhs.value_);&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;std::ostream&amp;&nbsp;operator&lt;&lt;&nbsp;(std::ostream&amp;&nbsp;o,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;x)<br>
&nbsp;{&nbsp;return&nbsp;o&nbsp;&lt;&lt;&nbsp;x.value_;&nbsp;}
</tt>
</div>
<p>The snag happens when the compiler sees the <tt>friend</tt> lines way up in the
class definition proper.  At that moment it does not yet know the
<tt>friend</tt> functions are themselves templates; it assumes they are
non-templates like this:
<p><div class=CodeBlock>
<tt>
&nbsp;Foo&lt;int&gt;&nbsp;operator+&nbsp;(const&nbsp;Foo&lt;int&gt;&amp;&nbsp;lhs,&nbsp;const&nbsp;Foo&lt;int&gt;&amp;&nbsp;rhs)<br>
&nbsp;{&nbsp;...&nbsp;}<br>
&nbsp;<br>
&nbsp;std::ostream&amp;&nbsp;operator&lt;&lt;&nbsp;(std::ostream&amp;&nbsp;o,&nbsp;const&nbsp;Foo&lt;int&gt;&amp;&nbsp;x)<br>
&nbsp;{&nbsp;...&nbsp;}
</tt>
</div>
<p>When you call the <nobr><tt>operator+</tt></nobr> or <nobr><tt>operator&lt;&lt;</tt></nobr> functions, this
assumption causes the compiler to generate a call to the <em>non</em>-template
functions, but the linker will give you an &quot;undefined external&quot; error because
you never actually defined those <em>non</em>-template functions.
<p>The solution is to convince the compiler <em>while it is examining the class
body proper</em> that the <nobr><tt>operator+</tt></nobr> and <nobr><tt>operator&lt;&lt;</tt></nobr> functions
are themselves templates.  There are several ways to do this; one simple
approach is pre-declare each template friend function <em>above</em> the
definition of template class <tt>Foo</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;&nbsp;class&nbsp;Foo;&nbsp;&nbsp;</tt><em><small>//&nbsp;pre-declare&nbsp;the&nbsp;template&nbsp;class&nbsp;itself</small></em><tt><br>
&nbsp;template&lt;typename&nbsp;T&gt;&nbsp;Foo&lt;T&gt;&nbsp;operator+&nbsp;(const&nbsp;Foo&lt;T&gt;&amp;&nbsp;lhs,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;rhs);<br>
&nbsp;template&lt;typename&nbsp;T&gt;&nbsp;std::ostream&amp;&nbsp;operator&lt;&lt;&nbsp;(std::ostream&amp;&nbsp;o,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;x);
</tt>
</div>
<p>Also you add <nobr><tt>&lt;&gt;</tt></nobr> in the <tt>friend</tt> lines, as shown:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(const&nbsp;T&amp;&nbsp;value&nbsp;=&nbsp;T());<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;Foo&lt;T&gt;&nbsp;operator+&nbsp;&lt;&gt;&nbsp;(const&nbsp;Foo&lt;T&gt;&amp;&nbsp;lhs,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;rhs);<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;std::ostream&amp;&nbsp;operator&lt;&lt;&nbsp;&lt;&gt;&nbsp;(std::ostream&amp;&nbsp;o,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;x);<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;T&nbsp;value_;<br>
&nbsp;};
</tt>
</div>
<p>After the compiler sees that magic stuff, it will be better informed about the
<tt>friend</tt> functions.  In particular, it will realize that the
<tt>friend</tt> lines are referring to functions that are themselves templates.
That eliminates the confusion.
<p>Another approach is to <em>define</em> the <tt>friend</tt> function within the
class body at the same moment you declare it to be a <tt>friend</tt>.  For
example:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(const&nbsp;T&amp;&nbsp;value&nbsp;=&nbsp;T());<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;Foo&lt;T&gt;&nbsp;operator+&nbsp;(const&nbsp;Foo&lt;T&gt;&amp;&nbsp;lhs,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;rhs)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;std::ostream&amp;&nbsp;operator&lt;&lt;&nbsp;(std::ostream&amp;&nbsp;o,&nbsp;const&nbsp;Foo&lt;T&gt;&amp;&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>...</small></em><tt><br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;T&nbsp;value_;<br>
&nbsp;};
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.17"></a>
<div class=FaqTitle><h3>[35.17] How can any human hope to understand these overly verbose template-based error messages?</h3></div>
<p>Here's a free tool that
<a href="http://www.bdsoft.com/tools/stlfilt.html" title="www.bdsoft.com/tools/stlfilt.html" target='_blank'>transforms error messages
into something more understandable</a>.  At the time of this writing, it
works with the following compilers: Comeau C++, Intel C++, CodeWarrior C++,
gcc, Borland C++, Microsoft Visual C++, and EDG C++.
<p>Here's an example showing some unfiltered gcc error messages:
<p><div class=CodeBlock>
<tt>
&nbsp;rtmap.cpp:&nbsp;In&nbsp;function&nbsp;`int&nbsp;main()':<br>
&nbsp;rtmap.cpp:19:&nbsp;invalid&nbsp;conversion&nbsp;from&nbsp;`int'&nbsp;to&nbsp;`<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::_Rb_tree_node&lt;std::pair&lt;const&nbsp;int,&nbsp;double&gt;&nbsp;&gt;*'<br>
&nbsp;rtmap.cpp:19:&nbsp;&nbsp;&nbsp;initializing&nbsp;argument&nbsp;1&nbsp;of&nbsp;`std::_Rb_tree_iterator&lt;_Val,&nbsp;_Ref,<br>
&nbsp;&nbsp;&nbsp;&nbsp;_Ptr&gt;::_Rb_tree_iterator(std::_Rb_tree_node&lt;_Val&gt;*)&nbsp;[with&nbsp;_Val&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;const&nbsp;int,&nbsp;double&gt;,&nbsp;_Ref&nbsp;=&nbsp;std::pair&lt;const&nbsp;int,&nbsp;double&gt;&amp;,&nbsp;_Ptr&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;const&nbsp;int,&nbsp;double&gt;*]'<br>
&nbsp;rtmap.cpp:20:&nbsp;invalid&nbsp;conversion&nbsp;from&nbsp;`int'&nbsp;to&nbsp;`<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::_Rb_tree_node&lt;std::pair&lt;const&nbsp;int,&nbsp;double&gt;&nbsp;&gt;*'<br>
&nbsp;rtmap.cpp:20:&nbsp;&nbsp;&nbsp;initializing&nbsp;argument&nbsp;1&nbsp;of&nbsp;`std::_Rb_tree_iterator&lt;_Val,&nbsp;_Ref,<br>
&nbsp;&nbsp;&nbsp;&nbsp;_Ptr&gt;::_Rb_tree_iterator(std::_Rb_tree_node&lt;_Val&gt;*)&nbsp;[with&nbsp;_Val&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;const&nbsp;int,&nbsp;double&gt;,&nbsp;_Ref&nbsp;=&nbsp;std::pair&lt;const&nbsp;int,&nbsp;double&gt;&amp;,&nbsp;_Ptr&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;const&nbsp;int,&nbsp;double&gt;*]'<br>
&nbsp;E:/GCC3/include/c++/3.2/bits/stl_tree.h:&nbsp;In&nbsp;member&nbsp;function&nbsp;`void<br>
&nbsp;&nbsp;&nbsp;&nbsp;std::_Rb_tree&lt;_Key,&nbsp;_Val,&nbsp;_KeyOfValue,&nbsp;_Compare,&nbsp;_Alloc&gt;::insert_unique(_II,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_II)&nbsp;[with&nbsp;_InputIterator&nbsp;=&nbsp;int,&nbsp;_Key&nbsp;=&nbsp;int,&nbsp;_Val&nbsp;=&nbsp;std::pair&lt;const&nbsp;int,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double&gt;,&nbsp;_KeyOfValue&nbsp;=&nbsp;std::_Select1st&lt;std::pair&lt;const&nbsp;int,&nbsp;double&gt;&nbsp;&gt;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;_Compare&nbsp;=&nbsp;std::less&lt;int&gt;,&nbsp;_Alloc&nbsp;=&nbsp;std::allocator&lt;std::pair&lt;const&nbsp;int,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double&gt;&nbsp;&gt;]':<br>
&nbsp;E:/GCC3/include/c++/3.2/bits/stl_map.h:272:&nbsp;&nbsp;&nbsp;instantiated&nbsp;from&nbsp;`void&nbsp;std::map&lt;_<br>
&nbsp;Key,&nbsp;_Tp,&nbsp;_Compare,&nbsp;_Alloc&gt;::insert(_InputIterator,&nbsp;_InputIterator)&nbsp;[with&nbsp;_Input<br>
&nbsp;Iterator&nbsp;=&nbsp;int,&nbsp;_Key&nbsp;=&nbsp;int,&nbsp;_Tp&nbsp;=&nbsp;double,&nbsp;_Compare&nbsp;=&nbsp;std::less&lt;int&gt;,&nbsp;_Alloc&nbsp;=&nbsp;st<br>
&nbsp;d::allocator&lt;std::pair&lt;const&nbsp;int,&nbsp;double&gt;&nbsp;&gt;]'<br>
&nbsp;rtmap.cpp:21:&nbsp;&nbsp;&nbsp;instantiated&nbsp;from&nbsp;here<br>
&nbsp;E:/GCC3/include/c++/3.2/bits/stl_tree.h:1161:&nbsp;invalid&nbsp;type&nbsp;argument&nbsp;of&nbsp;`unary&nbsp;*<br>
&nbsp;&nbsp;&nbsp;&nbsp;'
</tt>
</div>
<p>Here's what the filtered error messages look like (note: you can configure the
tool so it shows more information; this output was generated with settings to
strip things down to a minimum):
<p><div class=CodeBlock>
<tt>
&nbsp;rtmap.cpp:&nbsp;In&nbsp;function&nbsp;`int&nbsp;main()':<br>
&nbsp;rtmap.cpp:19:&nbsp;invalid&nbsp;conversion&nbsp;from&nbsp;`int'&nbsp;to&nbsp;`iter'<br>
&nbsp;rtmap.cpp:19:&nbsp;&nbsp;&nbsp;initializing&nbsp;argument&nbsp;1&nbsp;of&nbsp;`iter(iter)'<br>
&nbsp;rtmap.cpp:20:&nbsp;invalid&nbsp;conversion&nbsp;from&nbsp;`int'&nbsp;to&nbsp;`iter'<br>
&nbsp;rtmap.cpp:20:&nbsp;&nbsp;&nbsp;initializing&nbsp;argument&nbsp;1&nbsp;of&nbsp;`iter(iter)'<br>
&nbsp;stl_tree.h:&nbsp;In&nbsp;member&nbsp;function&nbsp;`void&nbsp;map&lt;int,double&gt;::insert_unique(_II,&nbsp;_II)':<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[STL&nbsp;Decryptor:&nbsp;Suppressed&nbsp;1&nbsp;more&nbsp;STL&nbsp;standard&nbsp;header&nbsp;message]<br>
&nbsp;rtmap.cpp:21:&nbsp;&nbsp;&nbsp;instantiated&nbsp;from&nbsp;here<br>
&nbsp;stl_tree.h:1161:&nbsp;invalid&nbsp;type&nbsp;argument&nbsp;of&nbsp;`unary&nbsp;*'
</tt>
</div>
<p>Here is the source code to generate the above example:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;map&gt;<br>
&nbsp;#include&nbsp;&lt;algorithm&gt;<br>
&nbsp;#include&nbsp;&lt;cmath&gt;<br>
&nbsp;<br>
&nbsp;const&nbsp;int&nbsp;values[]&nbsp;=&nbsp;{&nbsp;1,2,3,4,5&nbsp;};<br>
&nbsp;const&nbsp;int&nbsp;NVALS&nbsp;=&nbsp;sizeof&nbsp;values&nbsp;/&nbsp;sizeof&nbsp;(int);<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;namespace&nbsp;std;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;map&lt;int,&nbsp;double&gt;&nbsp;valmap;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valmap&nbsp;m;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;NVALS;&nbsp;i++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.insert(make_pair(values[i],&nbsp;pow(values[i],&nbsp;.5)));<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valmap::iterator&nbsp;it&nbsp;=&nbsp;100;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;error</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valmap::iterator&nbsp;it2(100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;error</small></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.insert(1,2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em><small>//&nbsp;error</small></em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>
&nbsp;}
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.18"></a>
<div class=FaqTitle><h3>[35.18] Why am I getting errors when my template-derived-class accesses something it inherited from its template-base-class?</h3></div>
<p>Perhaps surprisingly, the following code is not valid C++, even though some compilers accept it:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;B&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;void&nbsp;f()&nbsp;{&nbsp;}<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;D&nbsp;:&nbsp;public&nbsp;B&lt;T&gt;&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;void&nbsp;g()<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f();&nbsp;&nbsp;</tt><em><small><big>&#8592;</big>&nbsp;compiler&nbsp;might&nbsp;give&nbsp;an&nbsp;error&nbsp;here</small></em><tt><br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;};
</tt>
</div>
<p>This might hurt your head; better if you sit down.
<p>Within <nobr><tt>D&lt;T&gt;::g()</tt></nobr>, the name <tt>f</tt> does not depend on template
parameter <tt>T</tt>, so <tt>f</tt> is known as a <em>nondependent name</em>.
<nobr><tt>B&lt;T&gt;</tt></nobr>, on the other hand, is dependent on template parameter <tt>T</tt>
so <nobr><tt>B&lt;T&gt;</tt></nobr> is called a <em>dependent name</em>.
<p>Here's the rule: the compiler does not look in dependent base classes (like
<nobr><tt>B&lt;T&gt;</tt></nobr>) when looking up nondependent names (like <tt>f</tt>).
<p>This doesn't mean that inheritance doesn't work.  Class <nobr><tt>D&lt;int&gt;</tt></nobr> is
still derived from class <nobr><tt>B&lt;int&gt;</tt></nobr>, the compiler still lets you
implicitly do the is-a conversions (e.g., <nobr><tt>D&lt;int&gt;*</tt></nobr> to <nobr><tt>B&lt;int&gt;*</tt></nobr>),
dynamic binding still works when virtual functions are invoked, etc.  But
there is an issue about how names are looked up.
<p>Workarounds:
<ul>
<li>Change the call from <nobr><tt>f()</tt></nobr> to <nobr><tt>this-&gt;f()</tt></nobr>.  Since <tt>this</tt>
is always implicitly dependent in a template, <nobr><tt>this-&gt;f</tt></nobr> is dependent and
the lookup is therefore deferred until the template is actually instantiated,
at which point all base classes are considered.</li>
<li>Insert <nobr><tt>using B&lt;T&gt;::f;</tt></nobr> just prior to calling <nobr><tt>f()</tt></nobr>.</li>
<li>Change the call from <nobr><tt>f()</tt></nobr> to <nobr><tt>B&lt;T&gt;::f()</tt></nobr>.  Note however that
this might not give you what you want if <nobr><tt>f()</tt></nobr> is virtual, since it
inhibits the virtual dispatch mechanism.</li>
</ul>
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-35.19"></a>
<div class=FaqTitle><h3>[35.19] Can the previous problem hurt me silently? Is it possible that the compiler will silently generate the wrong code?</h3></div>
<p>Yes.
<p>Since <a href="templates.html#faq-35.18" title="[35.18] Why am I getting errors when my template-derived-class accesses something it inherited from its template-base-class?">the non-dependent name <tt>f</tt> is not looked up in the dependent
base-class <nobr><tt>B&lt;T&gt;</tt></nobr><!--rawtext:[35.18]:rawtext--></a>, the compiler will search the enclosing scope (such as
the enclosing namespace) for the name <tt>f</tt>.  This can cause it to
silently(!) do the wrong thing.
<p>For example:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;f()&nbsp;{&nbsp;}&nbsp;&nbsp;</tt><em><small>//&nbsp;a&nbsp;global&nbsp;(&quot;namespace&nbsp;scope&quot;)&nbsp;function</small></em><tt><br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;B&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;void&nbsp;f()&nbsp;{&nbsp;}<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;template&lt;typename&nbsp;T&gt;<br>
&nbsp;class&nbsp;D&nbsp;:&nbsp;public&nbsp;B&lt;T&gt;&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;void&nbsp;g()<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f();<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;};
</tt>
</div>
<p>Here the call within <nobr><tt>D&lt;T&gt;::g()</tt></nobr> will silently(!) call <nobr><tt>::f()</tt></nobr>
rather than <nobr><tt>B&lt;T&gt;::f()</tt></nobr>.
<p>You have been warned.
<p><small>[&nbsp;<a href="#top" title="Top of section [35] Templates">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [35] Templates">Bottom</a> |&nbsp;<a href="containers.html" title="[34] Container classes">Previous&nbsp;section</a> |&nbsp;<a href="serialization.html" title="[36] Serialization and Unserialization">Next&nbsp;section</a> |&nbsp;<a href="index-2.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="bottom"></a>
<a href="mailto:cline@parashift.com" title="cline@parashift.com"><img src="mbox.gif" height=26 width=89 alt="E-Mail">&nbsp;E-mail the author</a><br>
[&nbsp;<a href="index-2.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>
|&nbsp;<a href="index-2.html#table-of-contents" title="Table of contents">Table&nbsp;of&nbsp;contents</a>
|&nbsp;<a href="subject-index.html" title="Subject index; 5111 links to 3243 topics">Subject&nbsp;index</a>
|&nbsp;<a href="copy-permissions.html#faq-1.1" title="[1.1] Author">About&nbsp;the&nbsp;author</a>
|&nbsp;<a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">&copy;</a>
|&nbsp;<a href="on-line-availability.html#faq-2.2" title="[2.2] What happened to the one-click-download option?">Download&nbsp;your&nbsp;own&nbsp;copy</a>&nbsp;]<br>
<small>Revised Mar 1, 2006</small>
</body>

<!-- Mirrored from www.dietmar-kuehl.de/mirror/c++-faq/templates.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 18 Sep 2025 13:11:23 GMT -->
</html>
